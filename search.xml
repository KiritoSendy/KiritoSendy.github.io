<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AHK 基础</title>
    <url>/ahk/ahk_01.html</url>
    <content><![CDATA[<h1 id="安装-AutoHotkey"><a href="#安装-AutoHotkey" class="headerlink" title="安装 AutoHotkey"></a>安装 AutoHotkey</h1><p>在安装 <code>Autohotkey</code> 过程中, 需要选择安装 <code>UNICODE</code> 或者 <code>ANSI</code> 版本. </p>
<p>简单点说, 如果你想要它支持非英文字符和数字, 那就选择 <code>UNICODE</code> 版. </p>
<p><strong>[注]</strong> <font color='red'>AHK 脚本文件的命名中不能包含空格! 切记! 切记!</font></p>
<h1 id="热键-amp-热字串"><a href="#热键-amp-热字串" class="headerlink" title="热键 &amp; 热字串"></a>热键 &amp; 热字串</h1><ol>
<li>热键是用来触发某些动作的按键或组合按键. 如: <code>^j::</code></li>
</ol>
<p>热键是通过一对 <code>::</code> 创建的. 按键名或组合按键名必须在 <code>::</code> 左边. 代码则跟在后面, 以 <code>Return</code> 结束.</p>
<ol start="2">
<li>热字串主要用于扩展缩写(自动替换). 如: <code>::js::</code></li>
</ol>
<p>热字串在要触发的文本两边各有一对 <code>::</code>. 替换后的文本在第二对 <code>::</code> 的右边.</p>
<h2 id="常用的修饰键-amp-符号"><a href="#常用的修饰键-amp-符号" class="headerlink" title="常用的修饰键 &amp; 符号"></a>常用的修饰键 &amp; 符号</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#</td>
<td align="left">Win</td>
</tr>
<tr>
<td align="center">!</td>
<td align="left">Alt</td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">Control</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">Shift</td>
</tr>
</tbody></table>
<ol>
<li>可以通过在两个按键 (除手柄键) 之间, 使用 <code>&amp;</code> 来定义一个组合热键, 注意按键和 <code>&amp;</code> 之间必须加空格. 如: <code>Numpad1 &amp; Numpad2::</code></li>
</ol>
<blockquote>
<p><strong>[注意]</strong> 使用 <code>&amp;</code> 的时候记得在左面按键的前面加上 <code>~</code>, 表示当左面的按键单独按下的时候也要进行处理, 不然左面的按键就失效了. 比如上面的例子中, <code>Numpad1</code> 就会失效. 但是加上 <code>~</code> 符号后, 像这样: <code>~Numpad1 &amp; Numpad2::</code>, 这样 <code>Numpad1</code> 就不会失效了.</p>
</blockquote>
<ol start="2">
<li>热字串的修饰符在第一对 <code>::</code> 之间, 用 <code>*</code> 号进行修饰时, 无需按下结束符, 文本便会自动替换. 如: <code>:*:ftw::</code>.</li>
</ol>
<h2 id="如何设置脚本只在特定窗口生效"><a href="#如何设置脚本只在特定窗口生效" class="headerlink" title="如何设置脚本只在特定窗口生效"></a>如何设置脚本只在特定窗口生效</h2><p>在脚本代码的最上方添加高级命令: <code>#IfWinActive</code> 或者 <code>#IfWinExist</code>. </p>
<h1 id="发送按键-模拟键盘输入"><a href="#发送按键-模拟键盘输入" class="headerlink" title="发送按键, 模拟键盘输入"></a>发送按键, 模拟键盘输入</h1><blockquote>
<p><strong>[注意]</strong> <code>Send</code> 方法发送文本的时候, 如果要发送这些字符: <code>! + # ^</code>, 这些代表键盘按键的特殊字符, 需要用大括号 <code>&#123; &#125;</code> 括起来. 比如: <code>Send, my first &#123;+&#125; script&#123;!&#125;</code>.</p>
<p><strong>[注意]</strong> 当然也有代表键盘按键的字串, 如: <code>Space</code>, <code>Enter</code>, 这些也要用大括号 <code>&#123; &#125;</code> 括起来. 如: </p>
<p><code>Send, Multiple Enter lines have Enter been sent. ; 错误</code></p>
<p><code>Send, Multiple&#123;Enter&#125;lines have&#123;Enter&#125;been sent. ; 正确</code></p>
<p><strong>[注意]</strong> 如果模拟键盘输入时遇到了中文输入法的问题, 可以使用 {Text} 参数, 在 SendInput 后面加入这个参数后, 后面的文本就不会以键盘输入的方式进行输出, 而是直接以文本的形式输出, 避免中文输入法导致的问题. 比如 &#39;this is a message &#39; 在中文输入法下会变成 &#39;thisis啊message&#39;, 加入 {Text} 就可以解决这个问题.</p>
<p><code>SendInput, &#123;Text&#125;administrator</code></p>
<p>但是由于在中文输入法下会有一个输入提示框, 在 SendInput 处加 {Text} 确实可以避免在触发热键后的输入由于中文输入法而无法正确输入的问题, 但是这里还有另一个问题, 就是 &quot;触发&quot;! 在中文输入法下按下热键只有当热键的字符数<font color='red'><strong>小于等于 2 个</strong></font>的时候才会正常生效!</p>
<p>比如要写一个 administrator 的热键, 触发条件推荐写 <code>:*:am::</code>, 而不要写 <code>:*:admin::</code>, 不信自己在中文输入法下试用一下就知道了!</p>
</blockquote>
]]></content>
      <categories>
        <category>AutoHotKey</category>
      </categories>
      <tags>
        <tag>AHK</tag>
      </tags>
  </entry>
  <entry>
    <title>AHK 中的一些琐碎知识</title>
    <url>/ahk/ahk_02.html</url>
    <content><![CDATA[<h1 id="Scancode"><a href="#Scancode" class="headerlink" title="Scancode"></a>Scancode</h1><p>AHK 中某些符号无法直接在热键触发条件中编写, 这个时候就需要使用到 Scancode. 比如下面一个单引号和双引号互换的例子, 这里的热键触发条件便是键盘上的引号键.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc028::</span><br><span class="line">  sendinput,&#123;Text&#125;&quot;</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">+sc028::</span><br><span class="line">  sendinput,&#123;Text&#125;&#39;</span><br><span class="line">return</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AutoHotKey</category>
      </categories>
      <tags>
        <tag>AHK</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏开发笔试面试经历之字节跳动</title>
    <url>/apply/game_apply_bytedance.html</url>
    <content><![CDATA[<p>最近找工作, 那叫一个惨, 哈哈, 记录一下自己面试字节跳动时技术岗提问的问题吧! </p>
<a id="more"></a> 

<h2 id="字节跳动-2019-09-19-游戏客户端开发实习生-面试"><a href="#字节跳动-2019-09-19-游戏客户端开发实习生-面试" class="headerlink" title="字节跳动 2019.09.19 游戏客户端开发实习生 面试"></a>字节跳动 2019.09.19 游戏客户端开发实习生 面试</h2><p>面试方式: 使用 牛客网 在线面试, 但是由于自己的笔记本电脑不给力, 音频调试过了, 但是视频调试怎么也过不了, 于是换用了 Zoom 视频通话. 面试官是技术员, 怎么说呢～ 真 <strong>·</strong> 一拳超人! 一根都不剩! </p>
<h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1, 自我介绍"></a>1, 自我介绍</h3><p>说了自己的个人信息: 姓名, 年龄, 学校, 专业等. 之后说了些和自己的性格爱好相关的事, 再往后说了自己主要学习的课程, 最后说自己在校的一些经历. 不过可能是面试官不太想听我在学校的经历, 反正我就说了一点点, 面试官就直接问我了. (就是说我的自我介绍直接被打断了...)</p>
<h4 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h4><blockquote>
<p>说自我介绍的时候, 一定要只说自己已经充分准备了的东西.</p>
</blockquote>
<blockquote>
<p>我就实在了, 因为学过C语言, 我就直接说了在校学过C语言, 但是我已经好几年没用过C语言了, 于是接下来的事可想而知, 太尴尬了...</p>
</blockquote>
<h3 id="2-专业知识"><a href="#2-专业知识" class="headerlink" title="2, 专业知识"></a>2, 专业知识</h3><ol>
<li>C语言常量指针和指针常量的区别, 并写出一个常量指针和指针常量. </li>
</ol>
<blockquote>
<p>马后炮解答: </p>
<p>指针常量: 指针所指向的位置不能改变（p 不能改变）, 即指针本身是一个常量, 但是指针所指向的内容可以改变（*P 可以改变）. </p>
<p>声明: int * const p = &a; (const 修饰的是 p)</p>
<p>指针常量必须在声明的同时对其初始化, 不允许先声明一个指针常量随后再对其赋值, 这和声明一般的常量是一样的. </p>
<p>常量指针: 具有只能够读取内存中数据（*P 不可以改变）, 却不能够修改内存中数据的属性的指针（P 可以改变）, 全称为: 指向常量的指针, 简称常量指针. </p>
<p>声明: const int * p; int const * p; (const 修饰的是 *P)</p>
<p>可以将一个常量的地址赋值给一个对应类型的常量指针, 因为常量指针不能够通过指针修改内部数据. 只能防止通过指针引用修改内存中的数据, 并不保护指针所指向的对象. </p>
</blockquote>
<ol start="2">
<li>C语言程序运行时的内存分配情况. </li>
</ol>
<blockquote>
<p>马后炮解答: </p>
<p>对于一个由C语言编写的程序而言, 内存主要可以分为以下5个部分组成: 栈, 堆, BSS段, 数据段, 代码段. 栈和堆在程序运行中由系统分配空间, BSS段, 数据段, 代码段在程序编译期间由编译器分配空间. </p>
<p>(运行时)栈: 栈是一种由高地址向低地址扩展的数据结构, 是一块连续的内存区域, 通常存放程序临时创建的局部变量, 其中还包括函数调用时所用到的形参, 调用后的返回值等. </p>
<p>(运行时)堆: 堆是一种由低地址向高地址扩展的数据结构, 是一块不连续的内存区域. 通常存放程序运行中动态分配的存储空间. </p>
<p>(编译时)BSS段: Block Started by Symbol 的简称, 通常是指用来存放程序中未初始化的全局变量和静态变量. </p>
<p>(编译时)数据段: 数据段通常是指用来存放程序中已初始化的全局变量和静态变量以及字符串常量. </p>
<p>(编译时)代码段: 通常是指用来存放程序执行代码的一块内存区域. 这部分区域的大小在程序运行前就已经确定. </p>
</blockquote>
<p>数据结构中, 怎么判断链表里面有环? </p>
<blockquote>
<p>马后炮解答: </p>
<p><strong>如何判断一个链表中是否有环</strong>: 使用追赶法, 设定两个指针 slow, fast, 从头指针开始, 每次分别前进1步, 2步. 如存在环, 则两者必定相遇, 如不存在环, fast 遇到 NULL 退出. </p>
<p><strong>如何知道环的长度</strong>: 依旧先使用追赶法(双指针法), 求出 slow, fast 两指针的碰撞点 P (相遇点), 之后 slow, fast 指针再次从碰撞点 P 出发, 直到两者再次碰撞, 期间 slow 经过的结点数量就是环的长度. <strong>碰撞点不一定是环的连接结点</strong></p>
<p><strong>如何找出环的连接结点</strong>: 设置每次都只前进 1 步的两个指针, 分别从头结点和碰撞点出发, 他们所相遇的结点就是连接点. </p>
<p><strong>如何求出头结点到连接点的长度</strong>: 求连接点的时候, 从头结点出发的指针直到和另外一个指针相遇, 中间经过的结点的数量就是头结点到连接点的长度. </p>
<p><strong>带环链表的长度是多少</strong>: 头结点到连接点的长度 + 环的长度. </p>
</blockquote>
<p>数据结构中, 怎么取得链表的中间元素? </p>
<blockquote>
<p>马后炮解答: </p>
<p>一般方法: 首先循环遍历链表获得链表长度 L, 然后再次循环遍历链表查找 L/2 处的中间节点. 在这种情况下, 其时间复杂度由两次循环决定: <code>O（L+L/2）=O(3L/2)</code>. </p>
<p>优化方法: (双指针法)设置两个指针 <code>*search</code>, <code>*mid</code>, 初始时, 都指向头结点. 其中 <code>*search</code> 的移动速度为 <code>*mid</code> 的两倍（search 为 2, mid 为 1）. 相同时间内,  <code>*search</code> 经过的结点应该是 <code>*mid</code> 结点个数的 2 倍, 也就说, 当 <code>*search</code> 结点到达链表终点时, <code>*mid</code> 在链表中间结点处. </p>
</blockquote>
<p>什么是闭包?</p>
<blockquote>
<p> 闭包技术其实就是虽然使用的变量已经脱离其作用域了, 但是由于它和作用域存在上下文关系, 从而可以在当前环境中继续使用其上下文环境中所定义的一种函数对象. </p>
</blockquote>
<p>拆装箱是什么?</p>
<blockquote>
<p>C# 中, 将 对象类型 Object 赋值 给 值类型 int float double, 叫做拆箱. </p>
<p>C# 中, 将 值类型 int float double 赋值 给 对象类型 Object, 叫做装箱. </p>
</blockquote>
]]></content>
      <categories>
        <category>Apply</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏开发笔试面试经历之多益网络</title>
    <url>/apply/game_apply_duoyi.html</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="多益网络-2019-09-06-大数据与算法工程师-笔试"><a href="#多益网络-2019-09-06-大数据与算法工程师-笔试" class="headerlink" title="多益网络 2019.09.06 大数据与算法工程师 笔试"></a>多益网络 2019.09.06 大数据与算法工程师 笔试</h2><ol>
<li>最小堆 H, 使用数组进行保存, 最开始有 5 个数字: 2 3 5 8 10, 依次插入 7 1, 写出插入后数组中保存的数字序列. </li>
</ol>
<blockquote>
<p>堆可以用一个 <strong>完全二叉树</strong> 结构表示, 并且满足以下性质: </p>
<p>大顶堆: 任意一个结点的值必须大于它的左右孩子的值. </p>
<p>小顶堆: 任意一个结点的值必须小于它的左右孩子的值. </p>
<p>答案: 1 3 2 8 10 7 5</p>
</blockquote>
<ol start="2">
<li>判断题: </li>
</ol>
<ul>
<li><p>数组和链表中的元素都可以随机访问 (❌) </p>
</li>
<li><p>数组和链表插入元素删除元素的复杂度都是O(1) (❌) </p>
</li>
<li><p>哈希索引无法做范围查询 (✔) </p>
</li>
</ul>
<blockquote>
<p>数组可以随机访问, 但是链表只能遍历访问. </p>
<p>数组和链表插入元素删除元素的复杂度都是O(n). </p>
<p>哈希索引只能用于定值查询, 无法用于范围查询. 哈希索引进行排序操作无任何意义. </p>
</blockquote>
<ol start="3">
<li>对 25 15 30 10 50 3 5 60 进行快速排序. </li>
</ol>
<blockquote>
<p>第一趟: 5 15 3 10 25 50 30 60 (pivot: 25)</p>
<p>第二趟: 3 5 15 10 25 30 50 60 (pivot: 5 50)</p>
<p>第三趟: 3 5 10 15 25 30 50 60 (pivot: 15)</p>
</blockquote>
<ol start="4">
<li>判断题: </li>
</ol>
<ul>
<li><p>指针的值是指指针本身存储的值, 这个值是地址, 不是数值.  (✔) </p>
</li>
<li><p>指针可以为空, 可以有多级指针 (✔) </p>
</li>
<li><p>数组作为参数传入函数, 会退化为一级指针 (✔) </p>
</li>
<li><p>sizeof(指针) 所得到的值是指针所指向的变量的大小 (❌) </p>
</li>
<li><p>树的前序遍历, 中序遍历, 后序遍历中, 叶子结点的前后顺序是一样的.  (✔) </p>
</li>
</ul>
<ol start="5">
<li>哈希表的查找效率问题. 哈希表的长度是 10, 哈希表中一共 8 个关键字: 75 33 52 41 12 88 66 27, 哈希函数是: H(K) = key MOD 7, 解决冲突的方法采用: 线性探测再散列法, 则等概率查找成功的平均查找长度为多少. </li>
</ol>
<blockquote>
<p>所有关键字对 7 取余: 4 1 2 3 1 3 5 4</p>
<p>由于一共有 8 个关键字, 则平均查找长度是: </p>
<p>(1/8) * (4+1+2+3+1+3+5+4) = 23/8</p>
</blockquote>
<ol start="6">
<li>网络通信: TCP 建立连接的过程采用三次握手, 已知第三次握手报文发送序列: 1000, 确认序列: 2000, 写出第二次握手的发送序列和确认序列. </li>
</ol>
<blockquote>
<p>TCP 建立连接的三次握手分别是:</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th>发送序列</th>
<th align="left">确认序列</th>
</tr>
</thead>
<tbody><tr>
<td align="left">客户端</td>
<td>X</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">服务器</td>
<td>Y</td>
<td align="left">X+1</td>
</tr>
<tr>
<td align="left">客户端</td>
<td>X+1</td>
<td align="left">Y+1</td>
</tr>
</tbody></table>
<blockquote>
<p>题目已知 X+1=1000, Y+1=2000, 则第二次握手的发送序列和确认序列是: 1999, 1000</p>
</blockquote>
<ol start="7">
<li>进程之间的同步和互斥分别表明了各个进程之间的 () . </li>
</ol>
<ul>
<li><p>A 相互独立与互相制约</p>
</li>
<li><p>B 协调与竞争</p>
</li>
<li><p>C 不同状态</p>
</li>
<li><p>D 动态性和独立性</p>
</li>
</ul>
<blockquote>
<p>进程互斥, 同步的概念是并发进程下存在的概念, 有了并发进程, 就产生了资源的竞争与协作, 从而就要通过进程的互斥, 同步, 通信来解决资源的竞争与协作问题, 选 B. </p>
<p>进程的互斥 (mutual exclusion ) 是解决进程间竞争关系( 间接制约关系) 的手段.  进程互斥指若干个进程要使用同一共享资源时, 任何时刻最多允许一个进程去使用, 其他要使用该资源的进程必须等待, 直到占有资源的进程释放该资源. </p>
<p>进程的同步 (Synchronization) 是解决进程间协作关系( 直接制约关系) 的手段. 进程同步指两个以上进程基于某个条件来协调它们的活动. 一个进程的执行依赖于另一个协作进程的消息或信号, 当一个进程没有得到来自于另一个进程的消息或信号时则需等待, 直到消息或信号到达才被唤醒. </p>
</blockquote>
<ol start="8">
<li>表达式: a * (b + c) - d 的后缀表达式是? </li>
</ol>
<blockquote>
<p>前缀表达式: 运算符放在两个运算数的前面. +*-bcad</p>
<p>中缀表达式: 运算符放在两个运算数的中间. (b+c)*a-d</p>
<p>后缀表达式: 运算符放在两个运算符的后面. bc+a*d-</p>
</blockquote>
<ol start="9">
<li>假设循环队列的结构是: </li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    DataType data[Maxsize];<span class="comment">//数组队列</span></span><br><span class="line">    <span class="keyword">int</span> front;<span class="comment">//队头</span></span><br><span class="line">    <span class="keyword">int</span> rear;<span class="comment">//队尾</span></span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure>

<p>若有一个 Queue 类型的队列 Q, 判断这个队列满和空的条件是? </p>
<blockquote>
<p>判断满: Q.front == (Q.rear + 1) % Maxsize (取余运算)</p>
<p>判断空: Q.front == Q.rear</p>
</blockquote>
<ol start="10">
<li>桶排序的时间复杂度是? 是否稳定. </li>
</ol>
<blockquote>
<ul>
<li>桶排序的平均时间复杂度为线性的 O(N+C), 其中C=N*(logN-logM). 如果相对于同样的 N, 桶数量 M 越大, 其效率越高, 最好的时间复杂度达到O(N).  (N: 待排序数的数量 M: 桶的数量)</li>
<li>桶排序的空间复杂度为O(N+M), 如果输入数据非常庞大, 而桶的数量也非常多, 则空间代价无疑是昂贵的. </li>
<li>桶排序是稳定的. </li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="left">插入类排序方案</th>
<th align="left">时间复杂度</th>
<th align="left">空间复杂度</th>
<th align="left">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">直接插入排序</td>
<td align="left">O(n^2)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">折半插入排序</td>
<td align="left">O(n^2)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">二路插入排序</td>
<td align="left">O(n^2)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">希尔排序</td>
<td align="left">O(n^(1.3-2))</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">选择类排序方案</th>
<th align="left">时间复杂度</th>
<th align="left">空间复杂度</th>
<th align="left">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">简单选择排序</td>
<td align="left">O(n^2)</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
</tr>
<tr>
<td align="left">堆排序</td>
<td align="left">O(nlogn)</td>
<td align="left">O(1)</td>
<td align="left">不稳定</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">交换类排序方案</th>
<th align="left">时间复杂度</th>
<th align="left">空间复杂度</th>
<th align="left">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">冒泡排序</td>
<td align="left">O(n^2)</td>
<td align="left">O(1)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">快速排序</td>
<td align="left">O(nlogn)</td>
<td align="left">O(nlogn)</td>
<td align="left">不稳定</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">其他排序方案</th>
<th align="left">时间复杂度</th>
<th align="left">空间复杂度</th>
<th align="left">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">归并排序</td>
<td align="left">O(nlogn)</td>
<td align="left">O(nlogn)</td>
<td align="left">稳定</td>
</tr>
<tr>
<td align="left">基数排序</td>
<td align="left">O(d(r+n))</td>
<td align="left">O(rd+n)</td>
<td align="left">稳定</td>
</tr>
</tbody></table>
<blockquote>
<p>基数排序中 r: 关键字的基数 n: 关键字的个数 d: 长度</p>
</blockquote>
<ol start="11">
<li>建立一个有序单链表的时间复杂度是多少. </li>
</ol>
<blockquote>
<p>对单链表而言, 一些快速的排序算法是用不了的, 只能用直接插入等 O(n^2) 级的排序算法来实现排序. 答案: O(n^2)</p>
</blockquote>
<ol start="12">
<li>权值为 4 9 2 7 5 12 组成的 Huffman 树, 带权路径长度是? </li>
</ol>
<blockquote>
<p> 打造哈夫曼树: </p>
<p> 第一层: 39</p>
<p> 第二层: 23 16</p>
<p> 第三层: 11 12 7 9</p>
<p> 第四层:  6 5</p>
<p> 第五层:  2 4</p>
<p> 带权路径长度: 2 * 4 + 4 * 4 + 5 * 3 + 12 * 2 + 7 * 2 + 9 * 2 = 95</p>
</blockquote>
<ol start="13">
<li>有序表有 1000 个元素, 使用二分查找, 最多要比较多少次才能知道所查找元素是否在查找序列中. </li>
</ol>
<blockquote>
<p>二分查找的比较次数是: logN, 这里是向上取整, 所以是 10 次. </p>
<p>如果已经确定待查找元素就在序列中了, 则向下取整, 需要比较 9 次. </p>
</blockquote>
<ol start="14">
<li>如何迅速判断两个单向无环链表为交叉链表? </li>
</ol>
<blockquote>
<p> 交叉链表: 两个链表, 从某个结点开始, 后续所有结点完全相同,  X 型相交是不可能出现的. 因为想要出现 X 型相交, 那么相交点就拥有了两个 next 指针. 例如: </p>
<p> A: 1 2 3 4 8 9 10 11</p>
<p> B: 7 6 5 4 8 9 10 11</p>
<p> 对于两个无环链表, 有两种可取的办法: </p>
<ul>
<li><p>人为构造环, 将链表A的尾节点指向链表B, 再判断是否构环成功. 从链表B的头指针往下遍历, 如果能够回到B, 则说明相交. </p>
</li>
<li><p><strong>判断两链表最后一个节点是否相同</strong>, 如果相交, 则尾节点肯定是同一节点. (答案)</p>
<p>引申问题: 如何找出两个交叉链表的相交结点? </p>
</li>
<li><p>首先遍历两个链表到表尾(NULL), 记录下两个链表的长度: LA, LB, 并求出两个链表的长度差(绝对值) |LA - LB|. </p>
</li>
<li><p>之后再次遍历两个链表, 让长的那个链表先行遍历 |LA - LB| 个结点, 之后两者同步遍历并判断结点是否相等, 即可找出相交结点. </p>
<p>引申问题: 如何判断一个单链表是否存在环? </p>
</li>
<li><p>使用追赶法. 设置两个指针 slow 和 fast, slow 的速度是每次移动 1 个单位, fast 的速度是每次移动 2 个单位, 这样如果存在环, 两者必定会在某处相遇. 如果 fast 指针走到了 NULL 都没有和 slow 相遇, 说明没有环. </p>
<p>引申问题: 如何得到这个环的长度? </p>
</li>
<li><p>先使用追赶法, 记录下两个指针相遇的位置 P (碰撞点, 相遇点). </p>
</li>
<li><p>之后从 碰撞点 P 出发, 依旧使用追赶法, slow 每次一个单位, fast 每次 2 个单位, 当他们两个再次相遇时, slow 经过的结点数就是环的长度. </p>
</li>
<li><p>证明: 设环的长度是 X, 当 slow 指针经过了 X 个结点时(正好绕了一圈, 回到起点 P). fast 刚好经过了 2X 个结点(正好绕了两圈, 回到起点 P), 此时两者必定相遇. </p>
<p>引申问题: 如何得到这个环的 <strong>环入口结点</strong>? </p>
</li>
<li><p>定理: 定义两个指针, 分别从<strong>链表头结点</strong>和<strong>碰撞结点 P</strong>出发, 速度都是一次移动 1 个单位, 则两者必定会在<strong>环的入口结点</strong>相遇. </p>
</li>
<li><p>证明: 根据最开始使用的追赶法可知, slow 指针走过的结点数是从链表头结点到碰撞点 P 的长度, 设从链表头结点到环的入口结点的距离是 a, 从环的入口结点到碰撞点的距离是 b, 则 slow 走过的距离是: a+b. fast 指针走过的结点数是 slow 指针走过的结点数再加上 n 圈环的长度, 同时也是 slow 指针走过的结点数的 2 倍, 设环的长度为 L, 则 <code>2(a+b) = (a+b) + nL</code>, 化简后: <code>a+b = nL</code> =&gt;  <code>a+b = (n-1)L + L</code> =&gt;  <code>a = (n-1)L + (L-b)</code>. 证明完毕. </p>
</li>
</ul>
</blockquote>
<ol start="15">
<li>数据库保护分为哪四部分? </li>
</ol>
<blockquote>
<p> 安全性控制, 完整性控制, 并发性控制, 数据恢复</p>
</blockquote>
<ol start="16">
<li><p>说明 Linux 下多路复用 IO 接口 epoll 和 select 的区别及其适用场景. </p>
</li>
<li><p>说明资源在进程和线程上如何分配. </p>
</li>
<li><p>编程题: 判断输入的数字是否是梦想数. (输入数据是正整数)</p>
</li>
</ol>
<blockquote>
<p>梦想数: 对数字进行每一位平方后求和运算, 无限循环下去, 如果最后得到的个位数是 1, 则这个数字是梦想数. </p>
<p>例如: 19</p>
<p>1 + 81 = 82</p>
<p>64 + 4 = 68</p>
<p>36 + 64 = 100</p>
<p>1 + 0 + 0 = 1</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line">namespace _02_判断一个数字是不是梦想数</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> numberStr;</span><br><span class="line">            <span class="keyword">int</span> number;</span><br><span class="line">            <span class="keyword">int</span> temp, result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//读取一个数字字符串</span></span><br><span class="line">                numberStr = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//字符串转换为数字</span></span><br><span class="line">                number = Convert.ToInt32(numberStr);</span><br><span class="line">                <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//取出每一位数字并进行平方和运算</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)<span class="comment">//只要结果不是个位数, 就一直无限循环, 进行平方和运算</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> (number &gt;  <span class="number">0</span>)<span class="comment">//进行一个平方和运算</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        temp = number % <span class="number">10</span>;<span class="comment">//对 10 取余, 取出当前的个位数</span></span><br><span class="line">                        number /= <span class="number">10</span>;<span class="comment">//除以 10, 舍弃个位数</span></span><br><span class="line"></span><br><span class="line">                        result += temp * temp;<span class="comment">//平方求和</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (result / <span class="number">10</span> != <span class="number">0</span>)<span class="comment">//只要结果还不是个位数, 就准备进行下次平方和计算</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        number = result;<span class="comment">//重点</span></span><br><span class="line">                        result = <span class="number">0</span>;<span class="comment">//重点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">//如果结果是个位数了</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//判断是不是 1</span></span><br><span class="line">                        <span class="keyword">if</span> (result == <span class="number">1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            Console.WriteLine(<span class="string">&quot;是梦想数&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (result / <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            Console.WriteLine(<span class="string">&quot;不是梦想数&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;按任意键结束&quot;</span>);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Apply</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏开发笔试面试经历之巨人网络</title>
    <url>/apply/game_apply_giant.html</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="巨人网络-2019-09-06-游戏开发工程师-笔试"><a href="#巨人网络-2019-09-06-游戏开发工程师-笔试" class="headerlink" title="巨人网络 2019.09.06 游戏开发工程师 笔试"></a>巨人网络 2019.09.06 游戏开发工程师 笔试</h2><ol>
<li>选择题</li>
</ol>
<ul>
<li>A 类模板的成员函数都是函数模板, 类模板实例化后, 成员函数都随之实例化.  (❌) </li>
<li>B 一个类定义中, 只要有一个函数模板, 则这个类是类模板.  (❌) </li>
<li>C 函数模板必须由程序员实例化为可执行的函数模板.  (❌) </li>
<li>D 函数模板的实例化是由编译器实现的.  (✔) </li>
</ul>
<blockquote>
<p>马后炮解答: </p>
<ol>
<li>类模板的成员函数都是函数模板. </li>
<li>类模板实例化后, 成员函数 (即函数模板) 会随之实例化, 但是没使用过成员函数 (即函数模板) 的不会随之实例化. </li>
<li>函数模板必须由 <strong>编译器</strong> 根据 <strong>程序员的调用类型</strong> 实例化为 <strong>可执行的函数</strong>. </li>
</ol>
</blockquote>
<ol start="2">
<li>选择题</li>
</ol>
<ul>
<li>A 进程是程序运行的最小单位.  (❌) </li>
<li>B 线程是资源分配的最小单位.  (❌) </li>
<li>C 在 Linux 中, 进程比线程安全, 进程不会共享数据.  (❌) </li>
<li>D 进程有独立的地址空间, 线程没有独立的地址空间.  (✔) </li>
</ul>
<blockquote>
<p>马后炮解答: </p>
<ol>
<li>进程是资源分配的最小单位. </li>
<li>线程是程序运行的最小单位. </li>
<li>Linux 中, 进程可以共享数据. </li>
</ol>
</blockquote>
<ol start="3">
<li>选择题</li>
</ol>
<ul>
<li>下列编程语句需要加锁的是? </li>
<li>A ++X; </li>
<li>B X++; </li>
<li>C X=Y; </li>
<li>D X=1; </li>
</ul>
<blockquote>
<p>马后炮解答: </p>
<p>X=Y: 在 X86 上它包含两个操作: 读取 y 至寄存器, 再把该值写入 x. 读 y 的值这个操作本身是原子的, 把值写入 x 也是原子的, 但是两者合起来不是原子操作, 所以需要进行同步. </p>
<p>++X 和 X++ 这样的操作在多线程环境下是需要同步的. 因为 X86 会按三条指令的形式来处理这种语句: 从内存中读 x 的值到寄存器中, 对寄存器加 1, 再把新值写回 x 所处的内存地址. </p>
<p>X=1: 是原子操作, 不可再分. </p>
<p>答案: ABC</p>
</blockquote>
<ol start="4">
<li>选择题</li>
</ol>
<ul>
<li>A sizeof (指针): 可以得到指针所指向的内容的大小.  (❌) </li>
<li>B sizeof (数组名): 可以取得数组的容量.  (✔) </li>
<li>C 指针可以随时指向任意类型的内存块.  (❌) </li>
<li>D 可以在程序运行中改变数组长度.  (✔) </li>
</ul>
<blockquote>
<p>马后炮解答: </p>
<ol>
<li><strong>sizeof 不是函数</strong>. 因为 sizeof 写参数的时候, 有时候可以不加括号, 而且它可以直接以变量类型作为参数: <code>sizeof (int)</code>. </li>
<li><strong>sizeof 不是一元操作符</strong>. 因为 sizeof 语句是在编译阶段求值的. 比如下面的语句: </li>
</ol>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include&quot;stdio.h&quot; </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="keyword">sizeof</span> (a = <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">&quot;a 的值是: %d, b的值是: %d&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在编译阶段就会被翻译成如下代码, 运行结果自然是: <code>a 的值是: 0, b的值是: 4</code></p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include&quot;stdio.h&quot; </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int b = sizeof (a = 3);</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>; <span class="comment">// sizeof (a = 3); 会被直接编译成 4, 所以 &quot;a = 3;&quot; 并不会运行</span></span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">&quot;a 的值是: %d, b的值是: %d&quot;</span>, a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li><p>sizeof 的后面直接写数据类型的关键字时, 必须加括号. <code>sizeof (int);</code></p>
</li>
<li><p>sizeof 使用时的各种情况: </p>
<p>sizeof (固有数据类型, 例如 int float double bool): 取得类型的字节长度. 对于拥有自定义 typedef 类型的语言, 返回的是原数据类型的字节长度. </p>
<p>sizeof (函数类型, 例如 <code>int Add(int a, int b)</code>): 取得返回值的类型的字节长度. 当返回值是 void 类型时, 编译器会报错. </p>
<p>sizeof (任何指针类型, 例如变量指针, 函数指针)): 取得指针的长度, 也就是 4. </p>
<p>Sizeof (数组名): 取得数组的容量. </p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Apply</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP 开发经验笔记</title>
    <url>/asp/asp_learnnotes.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="一个简单快速的日志式调试方法"><a href="#一个简单快速的日志式调试方法" class="headerlink" title="一个简单快速的日志式调试方法"></a>一个简单快速的日志式调试方法</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 日志目录默认为当前目录</span></span><br><span class="line"><span class="keyword">string</span> logFilePath = Server.MapPath(DateTime.Now.ToString(<span class="string">&quot;yyyy-MM-dd&quot;</span>) + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line"><span class="keyword">string</span> content = <span class="string">&quot;需要输出的日志内容!&quot;</span>;</span><br><span class="line">content = <span class="keyword">string</span>.Format(<span class="string">&quot;&#123;0&#125; : &#123;1&#125;&#123;2&#125;&quot;</span>, DateTime.Now.ToString(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>), content, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">System.IO.File.AppendAllText(logFilePath, content, System.Text.Encoding.UTF8);</span><br></pre></td></tr></table></figure>

<h1 id="PL-SQL-存储过程中用户无操作权限"><a href="#PL-SQL-存储过程中用户无操作权限" class="headerlink" title="PL/SQL 存储过程中用户无操作权限"></a>PL/SQL 存储过程中用户无操作权限</h1><p>在存储过程中加入 <code>Authid Current_User</code> 即可. 例如:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE PROCEDURE SELECT_DATA_ZXN Authid Current_User AS</span><br><span class="line">  <span class="function">str_sql <span class="title">VARCHAR2</span>(<span class="params"><span class="number">2000</span></span>)</span>;</span><br><span class="line">BEGIN</span><br><span class="line">  ......</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h1 id="获取配置文件中的信息"><a href="#获取配置文件中的信息" class="headerlink" title="获取配置文件中的信息"></a>获取配置文件中的信息</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取 web.config 的信息</span></span><br><span class="line">System.Configuration.ConfigurationManager.AppSettings[<span class="string">&quot;KeyName&quot;</span>].ToString();</span><br></pre></td></tr></table></figure>

<h1 id="PLSQL-调试-Oracle-存储过程时输出信息"><a href="#PLSQL-调试-Oracle-存储过程时输出信息" class="headerlink" title="PLSQL 调试 Oracle 存储过程时输出信息"></a>PLSQL 调试 Oracle 存储过程时输出信息</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--存储过程调试输出</span></span><br><span class="line">dbms_output.put_line();</span><br></pre></td></tr></table></figure>

<h1 id="调用前台-JavaScript-方法"><a href="#调用前台-JavaScript-方法" class="headerlink" title="调用前台 JavaScript 方法"></a>调用前台 JavaScript 方法</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后台 C# 调用前台 JavaScript 的自定义方法</span></span><br><span class="line">ClientScript.RegisterStartupScript(<span class="keyword">this</span>.GetType(), <span class="string">&quot;&quot;</span>, <span class="string">&quot;&lt;script&gt;myFunction();&lt;/script&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//后台 C# 调用前台 JavaScript 弹窗提示</span></span><br><span class="line">ClientScript.RegisterStartupScript(<span class="keyword">this</span>.GetType(), <span class="string">&quot;&quot;</span>, <span class="string">&quot;&lt;script&gt;alert(&#x27;弹窗信息!&#x27;);&lt;/script&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="获取电脑-IP"><a href="#获取电脑-IP" class="headerlink" title="获取电脑 IP"></a>获取电脑 IP</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录下电脑 IP 的方法</span></span><br><span class="line"><span class="keyword">string</span> ip = <span class="keyword">string</span>.Empty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(System.Web.HttpContext.Current.Request.ServerVariables[<span class="string">&quot;HTTP_VIA&quot;</span>] != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ip = System.Web.HttpContext.Current.Request.ServerVariables[<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>].Split(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123; <span class="string">&#x27;,&#x27;</span> &#125;)[<span class="number">0</span>].ToString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ip = System.Web.HttpContext.Current.Request.ServerVariables[<span class="string">&quot;REMOTE_ADDR&quot;</span>].ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模板下载功能"><a href="#模板下载功能" class="headerlink" title="模板下载功能"></a>模板下载功能</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 浏览器下载文件</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;modifyName&quot;&gt;</span>自定义文件名, 附带后缀<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DownloadFile</span>(<span class="params"><span class="keyword">string</span> modifyName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义变量: 文件名</span></span><br><span class="line">    <span class="keyword">string</span> fileName = <span class="keyword">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件在服务器的地址</span></span><br><span class="line">    <span class="keyword">string</span> url = Server.MapPath(<span class="string">&quot;../searchZclbList.xls&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断地址是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(url))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 提示 &quot;该文件暂不提供下载&quot;</span></span><br><span class="line">        Page.ClientScript.RegisterStartupScript(Page.GetType(), <span class="string">&quot;message&quot;</span>, <span class="string">&quot;&lt;script defer&gt;alert(&#x27;该文件暂不提供下载!&#x27;);&lt;/script&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断获取的是否为地址  </span></span><br><span class="line">    <span class="keyword">if</span> (url.IndexOf(<span class="string">&quot;\\&quot;</span>) &gt; <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// url 为地址时, 则截取 url 中的文件名作为文件名</span></span><br><span class="line">        fileName = url.Substring(url.LastIndexOf(<span class="string">&quot;\\&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// url 为文件名时, 直接获取文件名  </span></span><br><span class="line">        fileName = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义文件名, 附带后缀</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(modifyName))</span><br><span class="line">    &#123;</span><br><span class="line">        fileName = modifyName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以字符流的方式下载文件  </span></span><br><span class="line">    FileStream fileStream = <span class="keyword">new</span> FileStream(@url, FileMode.Open);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)fileStream.Length];</span><br><span class="line">    fileStream.Read(bytes, <span class="number">0</span>, bytes.Length);</span><br><span class="line">    fileStream.Close();</span><br><span class="line">    Response.ContentType = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知浏览器下载 </span></span><br><span class="line">    Response.AddHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=&quot;</span> + fileName);</span><br><span class="line">    Response.BinaryWrite(bytes);</span><br><span class="line">    Response.Flush();</span><br><span class="line">    Response.End();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最基本的图片查看器功能"><a href="#最基本的图片查看器功能" class="headerlink" title="最基本的图片查看器功能"></a>最基本的图片查看器功能</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前台</span></span><br><span class="line">&lt;asp:Image ID=<span class="string">&quot;Image&quot;</span> runat=<span class="string">&quot;server&quot;</span> ImageUrl=<span class="string">&quot;~/imagelook.jpg&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Page_Load</span>(<span class="params"><span class="keyword">object</span> sender, System.EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取图片</span></span><br><span class="line">        <span class="keyword">int</span> ImgID = Convert.ToInt32(Request.QueryString[<span class="string">&quot;imageid&quot;</span>] <span class="keyword">as</span> <span class="keyword">string</span>);</span><br><span class="line">        OracleConnection Con = <span class="keyword">new</span> googoSoftEAM.SQLServerDAL.SqlHelper().Connection;</span><br><span class="line">        String SqlCmd = <span class="string">&quot;select * from zc_image where imageid = :imageid and saasdm=&#x27;&quot;</span> + Session[<span class="string">&quot;saasdm&quot;</span>].ToString() + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        OracleCommand CmdObj = <span class="keyword">new</span> OracleCommand(SqlCmd, Con);</span><br><span class="line">        CmdObj.Parameters.Add(<span class="string">&quot;:ImageID&quot;</span>, OracleType.UInt32).Value = ImgID;</span><br><span class="line">        Con.Open();</span><br><span class="line">        OracleDataReader SqlReader = CmdObj.ExecuteReader();</span><br><span class="line">        SqlReader.Read();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 图片类型</span></span><br><span class="line">        <span class="keyword">string</span> imageType = (<span class="keyword">string</span>)SqlReader[<span class="string">&quot;imagecontenttype&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原版图片内容 [字节流]</span></span><br><span class="line">        MemoryStream bufferByte = <span class="keyword">new</span> MemoryStream((<span class="keyword">byte</span>[])SqlReader[<span class="string">&quot;imageData&quot;</span>]);</span><br><span class="line">        System.Drawing.Image imageOrigin = System.Drawing.Image.FromStream(bufferByte, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缩小文件 (计算缩小倍率) 缩小至 高度 targetHeight 左右</span></span><br><span class="line">        <span class="keyword">float</span> targetHeight = <span class="number">600.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> shrink = targetHeight / imageOrigin.Height;</span><br><span class="line">        <span class="keyword">float</span> w = shrink, h = shrink;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标图形</span></span><br><span class="line">        System.Drawing.Bitmap imageSmall = <span class="keyword">new</span> System.Drawing.Bitmap((<span class="keyword">int</span>)(imageOrigin.Width * shrink), (<span class="keyword">int</span>)(imageOrigin.Height * shrink));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个图形对象</span></span><br><span class="line">        Graphics graphics = Graphics.FromImage(imageSmall);</span><br><span class="line">        graphics.DrawImage(imageOrigin, <span class="keyword">new</span> Rectangle(<span class="number">0</span>, <span class="number">0</span>, imageSmall.Width, imageSmall.Height), <span class="keyword">new</span> Rectangle(<span class="number">0</span>, <span class="number">0</span>, imageOrigin.Width, imageOrigin.Height), GraphicsUnit.Pixel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出图片地址</span></span><br><span class="line">        <span class="keyword">string</span> ret_type = <span class="keyword">string</span>.Empty;</span><br><span class="line">        GetImageType(imageType, <span class="keyword">out</span> ret_type);</span><br><span class="line">        <span class="keyword">string</span> imagePath = Server.MapPath(<span class="string">&quot;../imagelook.&quot;</span> + ret_type);</span><br><span class="line">        <span class="keyword">if</span> (File.Exists(imagePath))</span><br><span class="line">        &#123;</span><br><span class="line">            File.Delete(imagePath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解决 Image 控件的刷新问题</span></span><br><span class="line">        <span class="comment">// 当 IE 检测到 Image 控件的引用地址没有变化时, 会直接从浏览器缓存中取图片.</span></span><br><span class="line">        <span class="comment">// 因此只要下一次访问时网页时, Image 控件的引用地址和这一次的引用地址不相同即可.</span></span><br><span class="line">        <span class="comment">// 于是在引用地址处加一个随机数参数, 使两次引用的图片地址不同!</span></span><br><span class="line">        imageSmall.Save(imagePath);</span><br><span class="line">        Image.ImageUrl = <span class="string">&quot;~/imagelook.&quot;</span> + ret_type + <span class="string">&quot;?&quot;</span> + <span class="keyword">new</span> Random().Next(<span class="number">100</span>).ToString();</span><br><span class="line">        Con.Close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Trace.Write(ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 根据所存图片类型返回图片格式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;imageType&quot;&gt;</span>图片类型<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;ret_type&quot;&gt;</span>返回的图片类型 (string)<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>返回的图片类型 (ImageFormat)<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="keyword">private</span> System.Drawing.Imaging.<span class="function">ImageFormat <span class="title">GetImageType</span>(<span class="params"><span class="keyword">string</span> imageType, <span class="keyword">out</span> <span class="keyword">string</span> ret_type</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (imageType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;image/gif&quot;</span>:</span><br><span class="line">            ret_type = <span class="string">&quot;gif&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> System.Drawing.Imaging.ImageFormat.Gif;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;image/bmp&quot;</span>:</span><br><span class="line">            ret_type = <span class="string">&quot;bmp&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> System.Drawing.Imaging.ImageFormat.Bmp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;image/x-png&quot;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;image/png&quot;</span>:</span><br><span class="line">            ret_type = <span class="string">&quot;png&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> System.Drawing.Imaging.ImageFormat.Png;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;image/pjpeg&quot;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;image/jpeg&quot;</span>:</span><br><span class="line">            ret_type = <span class="string">&quot;jpg&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> System.Drawing.Imaging.ImageFormat.Jpeg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ret_type = <span class="string">&quot;jpg&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> System.Drawing.Imaging.ImageFormat.Jpeg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="合并两个表结构完全一致的-DataTable"><a href="#合并两个表结构完全一致的-DataTable" class="headerlink" title="合并两个表结构完全一致的 DataTable"></a>合并两个表结构完全一致的 DataTable</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将 sum 表和 para 表合并到 sum 表中, 要求: &quot;sum 表&quot; 和 &quot;para 表&quot; 的表结构必须完全一样!</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;sum&quot;&gt;</span>待合并表之一, 同时也是结果表<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;para&quot;&gt;</span>仅作为待合并表之一<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddTableToTable</span>(<span class="params">DataTable sum, DataTable para</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历 para 表的每一行</span></span><br><span class="line">    <span class="keyword">foreach</span> (DataRow dataRow_para <span class="keyword">in</span> para.Rows)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//新建 sum 表的一行</span></span><br><span class="line">        DataRow dataRow_sum = sum.NewRow();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建的这一行取 para 表的数据</span></span><br><span class="line">        dataRow_sum.ItemArray = dataRow_para.ItemArray;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将新建的这一样加到 sum 表中</span></span><br><span class="line">        sum.Rows.Add(dataRow_sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网页实现-Enter-快捷键"><a href="#网页实现-Enter-快捷键" class="headerlink" title="网页实现 Enter 快捷键"></a>网页实现 Enter 快捷键</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器中 Enter 键有一个默认行为, 用户焦点在文本框中时键入 Enter, 会触发第一个按钮的 Click 事件.</span></span><br><span class="line"><span class="built_in">document</span>.onkeydown = keydown;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keydown</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.keyCode == <span class="number">13</span>) <span class="comment">// Enter 快捷键</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn_cx&quot;</span>).click();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 阻止浏览器的默认行为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="点击空白处触发-JS-中的函数"><a href="#点击空白处触发-JS-中的函数" class="headerlink" title="点击空白处触发 JS 中的函数"></a>点击空白处触发 JS 中的函数</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// document.onclick 事件注册</span></span><br><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ASP</category>
      </categories>
      <tags>
        <tag>ASP</tag>
      </tags>
  </entry>
  <entry>
    <title>Googosoft 网站部署步骤</title>
    <url>/asp/deploy_website.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="如何部署网站程序"><a href="#如何部署网站程序" class="headerlink" title="如何部署网站程序"></a>如何部署网站程序</h1><ol>
<li><p>打开 IIS 管理器 (Internet Information Service), 在 &quot;网站&quot; 处右键, 添加网站.</p>
</li>
<li><p>输入 <font color='red'><strong>网站名称, 物理路径, 修改端口号</strong></font>, 其他的像 &quot;&quot;类型&quot;&quot;, &quot;IP 地址&quot;, &quot;主机名&quot; 都不用动.</p>
<p>[<strong>注意</strong>] 物理路径填写时要多添加 <code>程序版本</code> 这一级别, 因为程序中有一个 js 用到了这一路径级别, 如果不添加 js 会返回错误的执行结果. 之后在这一层路径下再添加具体的程序文件, 如图:</p>
<p><img data-src="/images/deploy_website/WebsitePath.png" alt="目录设置"></p>
</li>
<li><p>选中具体的程序文件的顶层文件夹, <strong>右键</strong> =&gt; <strong>转换为应用程序</strong>.</p>
<p><img data-src="/images/deploy_website/ToApplication.png" alt="转换为应用程序"></p>
</li>
<li><p>选中网站, 双击 <code>MIME 类型</code> (图标由一个音符 ico, 一个图片 ico, 还有一个文本 ico 组成), 在右侧窗口单击 &quot;添加...&quot;, 输入: </p>
<p><code>.dmp application/x-dmp</code></p>
<p><code>.log application/x-log</code></p>
<p><code>.md application/x-md</code></p>
<blockquote>
<p>[<strong>注</strong>] <code>MIME 类型</code> 是用来控制下载的, 不添加这些类型, 用户也就无法下载这些类型的文件.</p>
</blockquote>
</li>
<li><p>双击 &quot;身份验证&quot;, 将 &quot;匿名身份验证&quot; 启用. (默认启用)</p>
</li>
<li><p>双击 &quot;默认文档&quot;, 添加 &quot;default5.aspx&quot; 文件. 当访问网站时如果不写明要访问的页面, 这时 IIS 就会从默认文档列表中从上往下依次寻找, 一旦找到存在的页面便会进行渲染, 因此假设你的网站默认开始页面是 StartPage.aspx, 那么你就需要将 StartPage.aspx 添加到默认文档列表中, 并将位置设置在第一位. (默认新添加的页面都在第一位)</p>
</li>
<li><p>选中 &quot;网站&quot; 上方的 &quot;应用程序池&quot;, 找到刚刚建好的网站, 右键, 基本设置:</p>
<p>.NET CLR 版本设置为: v2.0.50727, 托管管道模式设置为: 经典.</p>
</li>
<li><p>选中 &quot;网站&quot; 上方的 &quot;应用程序池&quot;, 找到刚刚建好的网站, 右键, 高级设置:</p>
<p>将 &quot;启用 32 位应用程序&quot; 设置为 true. 公司网站部署时一般都可以直接这样设置, 实际原因是因为使用了 32 位的 Oracle 客户端, 如果使用的是 64 位 Oracle 客户端, 那么就不需要开启此选项. 为了不打乱文章结构, 文章末尾会附加如何判断 Windows 上安装的 Oracle 客户端版本.</p>
</li>
<li><p>修改 Web.config 文件中的数据库位置.</p>
</li>
<li><p>修改 Web.config 文件中 impersonate=&quot;true&quot; 为 &quot;false&quot;.</p>
</li>
<li><p>设置目录权限. 网站右键, 编辑权限, 添加以下用户, 并给予完全控制权限, 确认.</p>
<p>  <strong><code>Everyone; NETWORK; NETWORK SERVICE</code></strong></p>
</li>
<li><p>防火墙添加入站规则, 否则他人无法访问. 控制面板-&gt;防火墙-&gt;高级设置-&gt;入站规则-&gt;新建规则-&gt;端口-&gt;TCP, 填入新建网站的端口-&gt;后面默认即可. (最后给这个规则起一个规范, 易识别的名字).</p>
</li>
</ol>
<h1 id="如何判断-Windows-上安装的-Oracle-客户端版本"><a href="#如何判断-Windows-上安装的-Oracle-客户端版本" class="headerlink" title="如何判断 Windows 上安装的 Oracle 客户端版本"></a>如何判断 Windows 上安装的 Oracle 客户端版本</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>🍀 Oracle 分为客户端和数据库, 即 Client 和 Database.</p>
<p>🌾 安装 Oracle 时, 正确的安装姿势是: </p>
<ul>
<li>如果认为自己的电脑上根本不可能会布置数据库, 那么只安装 Client 就可以了, 通过 Client 来访问其他电脑上的数据库.</li>
<li>如果认为自己电脑上还是有可能会布置数据库的, 那么就必须安装 Database 了, 但是不需要安装 Client! 不需要安装 Client! 不需要安装 Client! 原因就是 Database 安装包中自带 Client! 😂</li>
</ul>
<p>🌈 [<strong>注</strong>] 如果你电脑上已经同时安装了 Client 和 Database, 甚至安装了多个版本的 Client, 这... 抱歉, 对现在的我来说有点超纲...</p>
<h2 id="查看-comps-xml-和-config-xml"><a href="#查看-comps-xml-和-config-xml" class="headerlink" title="查看 comps.xml 和 config.xml"></a>查看 comps.xml 和 config.xml</h2><p>找到 Oracle 安装目录, 大概长这样: <code>\oracle\product\11.2.0\clienthome</code>, 之后再往下找 <code>\inventory\ContentsXML</code>, 里面有一个 <code>comps.xml</code> 和一个 <code>config.xml</code> 文件, 查看这两个文件, 如果 <code>PLAT=&quot;NT_AMD64&quot;</code> 说明安装的是 64 位 Oracle 客户端, 如果 <code>PLAT=&quot;NT_X86&quot;</code> 则说明安装的是 32 位 Oracle 客户端.</p>
<h1 id="如何判断-Windows-上安装的-Oracle-数据库版本"><a href="#如何判断-Windows-上安装的-Oracle-数据库版本" class="headerlink" title="如何判断 Windows 上安装的 Oracle 数据库版本"></a>如何判断 Windows 上安装的 Oracle 数据库版本</h1><p>打开 PLSQL Developer 或者 SQL Plus 执行下面的语句即可判断数据库的版本. (别漏了 ; 号哦!)</p>
<p><code>SELECT CASE LENGTH(address) WHEN 8 THEN &#39;32 位数据库&#39; WHEN 16 THEN &#39;64 位数据库&#39; END AS 数据库版本 FROM v$sql WHERE ROWNUM &lt; 2;</code></p>
]]></content>
      <categories>
        <category>ASP</category>
      </categories>
      <tags>
        <tag>网站部署</tag>
      </tags>
  </entry>
  <entry>
    <title>理解计算机中的字符编码</title>
    <url>/computer/computer_char_code.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天再一次体会到了 <strong>基础知识不扎实会带来无数的问题与困扰</strong> 这句话是多么地真实 ! ! 事情起因是我想巩固一下 SQL 知识, 于是用 SQL Developer 工具开始写 SQL, 但是当我用 SQL Developer 打开一个之前在 PL/SQL 上编辑的 SQL 文件的时候, 里面所有的中文全部乱码了 ! ! 我就知道我必须要解决 <code>编码</code> 这个困扰我许久的问题了. 于是上网搜索资料, 最后总结如下, 我使用了编码的发展顺序来组织文章结构 ( 大概, 或许, 应该, 差不多是这么个发展顺序吧, 哈哈 ! ), OK, 我们开始.</p>
<h1 id="字符集-和-编码规则"><a href="#字符集-和-编码规则" class="headerlink" title="字符集 和 编码规则"></a>字符集 和 编码规则</h1><p>这两个概念必须在最开始就要点出, 这也是这篇文章的重心所在. 字符集和编码规则是完全不同的两种事物: </p>
<p><strong>字符集</strong>: 为每一个字符分配一个唯一的 ID. </p>
<p><strong>编码规则</strong>: 定义如何将之前定义的 ID 转换为计算机中的字节序列的一整套规则. </p>
<p>这里不需要特别明白, 只需要知道有这样一个区别即可, 后面根据实例来理解它们会更容易.</p>
<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><p>在计算机内部, 所有信息最终都是一个二进制值. 每一个二进制位 (bit) 有 0 和 1 两种状态, 因此八个二进制位就可以组合出 256 种状态, 这被称为一个字节 (byte). 也就是说, 从 <code>0X00</code> 到 <code>0XFF</code> 的一个字节一共可以用来表示 256 种不同的状态, 如果让每一个状态对应一个符号, 就是 256 个符号.</p>
<h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p>于是美国就率先制定了一套字符编码, 来解决英语字符与二进制位之间的关系, 并做了统一规定. 这被称为 <code>ASCII</code>, 即 <code>美国信息交换标准代码</code>, 一直沿用至今. </p>
<p>由于 <code>ASCII</code> 提出的时候, 字符集和编码规则这两个概念尚未区分, 于是 <code>ASCII</code> 既表示字符集又表示编码规则. 不过为了好理解, 我们这里来一波强行解释! 上图!</p>
<p><img data-src="/images/computer_char_code/ascii.png" alt="ASCII"></p>
<h2 id="ASCII-字符集"><a href="#ASCII-字符集" class="headerlink" title="ASCII 字符集"></a>ASCII 字符集</h2><p>上图中的 <code>Bin</code> 和 <code>缩写/字符</code> 这两列就是字符集, 一共规定了 128 个字符以及这 128 个字符的 ID. </p>
<p>字符集就只是负责这个工作, 即给每个要表示的字符分配一个 ID, 至于这个 ID 在计算机中怎么表示, 是用 1 个字节还是 2 个字节还是可变长度字节是不需要字符集去考虑的. 即使是仅仅只有 128 个字符的 ASCII 字符集, 我在电脑中就喜欢用 2 个字节表示, 我硬盘空间有的是, 我就喜欢 1 个字节表示字符, 另 1 个字节在旁边站岗, 谁又管的着呢? 虽然这很蠢!</p>
<h2 id="ASCII-编码规则"><a href="#ASCII-编码规则" class="headerlink" title="ASCII 编码规则"></a>ASCII 编码规则</h2><ul>
<li>① 每个字符都使用 1 个字节表示.</li>
<li>② 这个字节的首位始终为 0.</li>
</ul>
<p>ASCII 字符集经过编码规则的限制之后, 在计算机中就表示为了: 0000.0000 到 0111.1111.</p>
<p>这样应该就有点明白字符集和编码规则的区别了吧. 其实当时那个年代 <code>字符集</code> 和 <code>编码规则</code> 这两个概念还没有明确建立, 因为没必要区分开, 默认情况下, 字符集所定义的 ID 的二进制形式就直接是编码规则, 但是随着时代的发展, 明确建立这两个概念就很有必要了. 比如后来提出的 Unicode 字符集, 在 2020 年 3 月的 <code>ISO/IEC 10646:2020</code> 版本中, 总共有 143924 个字符, 其中部分字符会占用 4 个字节, 总不能还是使用 <code>字符集所定义的 ID 的二进制形式就直接是编码规则</code> 这种简单的对应了吧, 因为这样的话所有的字符都要用 4 个字节, 原来只需 1 个字节的英文字母现在需要 4 个字节, 原来只需要 2 个字节的汉字现在也需要 4 个字节, 而且 Unicode 编码还在不断地补充进化, 所以这样实在是太浪费空间了! 我还要用硬盘存放珍贵的电影资源呢! 更大的影响是在网络传输方面, 原本只需传输 1 MB 的数据量, 现在却要传输 4 MB, 这太浪费资源了!</p>
<p>[注] ASCII 是后面一切编码的基础, 因此即使字符编码不断发展, 发展后的它们也都会考虑到和 ASCII 的兼容性, 因此你会看到后面的编码都会做出一些相应的措施来兼容 ASCII.</p>
<h1 id="扩展版-ASCII"><a href="#扩展版-ASCII" class="headerlink" title="扩展版 ASCII"></a>扩展版 ASCII</h1><p>随着计算机的普及, 计算机进入了欧洲国家, 但是 ASCII 中不包含其他语言的字符啊! 像希腊字母, 罗马字母等. 那么这些欧洲国家就很难受啊! 正好 ASCII 只使用了 1 个字节的后 7 位, 于是, 一些欧洲国家就决定, 利用 ASCII 编码规则中闲置的最高位编入新的符号 ( 你美国人不是才用了半个字节吗, 那好, 剩下的半个字节由我们来定义 ). 这样一来, 这些欧洲国家使用的编码体系, 就可以表示 256 个字符, 我们称之为 <code>扩展版 ASCII</code>.</p>
<h2 id="扩展版-ASCII-字符集"><a href="#扩展版-ASCII-字符集" class="headerlink" title="扩展版 ASCII 字符集"></a>扩展版 ASCII 字符集</h2><p>扩展版 ASCII 字符集规定了 256 个字符. 其中 128 个字符直接沿用了 ASCII, 以达到兼容的目的, 剩下的 128 个字符是欧洲国家自己定义的字符. 当然由于每个国家语言不同, 对于这 128 个字符, 不同的国家自然有不同的定义, 那么肯定也会有它们独特的称呼, 但本质上它们都属于扩展版 ASCII 字符集🤣. (是不是感觉开始出现了混乱的味道? 嗯哼~) 但是不管怎样, 所有这些扩展版 ASCII 字符集中, 0 ~ 127 表示的符号是一样的, 不一样的只是 128 ~ 255 这些字符. </p>
<h2 id="扩展版-ASCII-编码规则"><a href="#扩展版-ASCII-编码规则" class="headerlink" title="扩展版 ASCII 编码规则"></a>扩展版 ASCII 编码规则</h2><ul>
<li>① 每个字符使用 1 个字节表示.</li>
</ul>
<p>于是扩展版 ASCII  字符集经过编码规则的限制之后, 在计算机中就表示为了: 0000.0000 到 1111.1111. ASCII 和扩展版 ASCII 两者之间互不冲突, 相安无事. </p>
<p>从扩展版 ASCII 开始, 这种命名就具有了表示一个大类的意味, 在这个大类下, 具体会细分成很多字符集, 比如, 意大利有意大利的扩展版 ASCII, 法国有法国的扩展版 ASCII, 瑞士有瑞士的扩展版 ASCII. 其中最优秀的字符集扩展方案是 <code>ISO 8859-1</code>, 通常称之为 <code>Latin-1</code>, Latin-1 利用 128 ~ 255 这 128 个二进制数, 包括了足够的附加字符集来涵盖基本的西欧语言, 同时在 0 ~ 127 的范围内兼容 ASCII 编码规则.</p>
<h1 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h1><p>之后, 计算机进入了亚洲国家, 亚洲国家使用的符号就更多了, 其中我国的汉字就接近十万个! 常用字也有四千多个. 由于前面的 ASCII 和扩展版 ASCII 的单字节字符集只能表示 256 种符号, 这对于我们博大精深的汉语来说是肯定不够的, 于是单字节不行, 就必须使用多字节. 于是就诞生了一系列的多字节字符集, 其中一类就叫做 <code>ANSI 字符集</code>. </p>
<p>ANSI 字符集是从 0X0000 定义到 0XFFFF, 理论上来说, 只要全部的字符都使用 2 个字节表示, 就可以包含 65536 个字符 (但是实际的编码规则不会这么简单直接), 这对于任何单个国家的字符需求来说, 都能基本满足了. </p>
<p>ANSI 字符集定义了要表示的字符以及对应的 ID, 但是并不意味着将这些字符编到计算机中的时候会遵守 <code>字符集所定义的 ID 的二进制形式就直接是编码规则</code> 的游戏规则. 就比如后面会提到的 <code>GB 2312</code> 字符集使用的 <code>EUC-CN</code> 编码规则, 半角字符只占 1 个字节, 汉字和全角字符才会占用 2 个字节 (是不是已经开始有点晕了😵). </p>
<p>[注] 网络上有人说 ANSI 字符集是 ASCII 字符集 的扩展, 我想他应该是把我前面所提到的 ASCII 字符集和 ASCII 扩展字符集都统称为了 ASCII 字符集, 于是得出了他的这个结论. 我认为我的说法和他的说法没有绝对的谁对谁错, 只是不同的两种理解. 在现在这个信息交流如此便利的时代, 我也希望大家在非原则问题上不要过于较真. 不过本文中一直采用的是我自己的看法, 即 ASCII 字符集和 ASCII 扩展字符集不统称为 ASCII 字符集. 接下来让我们回到正题.</p>
<h2 id="ANSI-字符集"><a href="#ANSI-字符集" class="headerlink" title="ANSI 字符集"></a>ANSI 字符集</h2><p>ANSI 字符集中包含的字符具体是什么不好说, 因为不同国家的 ANSI 字符集包含的字符是不一样的, 和当时的 ASCII 扩展字符集的发展轨迹相同, 对于 ANSI 字符集, 不同的亚洲国家同样设计了他们各自的字符集 (这里我终于搜索到这些细分的 ANSI 字符集所对应的名字了 😂), 比如日本的 ANSI 字符集叫做 <code>JIS X 0208</code>, 韩国的叫做 <code>KS X 1001</code>, 我国的 ANSI 字符集叫做 <code>GB 2312</code>, 释义为: <strong><code>信息处理交换用汉字编码字符集基本集</code></strong>. 下面简单说一下 GB 2312 中所规定的字符集内容.</p>
<p>GB 2312 共收录 6763 个汉字, 其中一级汉字 3755 个, 二级汉字 3008 个, 同时收录了包括拉丁字母, 希腊字母, 日文平假名及片假名字母, 俄语西里尔字母在内的 682 个字符. </p>
<p>GB 2312 的出现, 基本满足了汉字的计算机处理需要, 它所收录的汉字已经覆盖中国大陆 99.75% 的使用频率.</p>
<h2 id="ANSI-编码规则"><a href="#ANSI-编码规则" class="headerlink" title="ANSI 编码规则"></a>ANSI 编码规则</h2><ul>
<li>① 不同的 ANSI 字符集会规定其独特的编码规则. </li>
</ul>
<p>这个还真的都不一样, 但是也都是有基准的. 比如我国的 GB 2312 字符集使用的 ANSI 编码规则叫做 <code>EUC-CN</code>, 日本的 JIS X 0208 字符集在 Windows 上使用的 ANSI 编码规则叫做 <code>EUC-JP</code>, 韩国的 KS X 1001 字符集使用的 ANSI 编码规则叫做 <code>EUC-KR</code>. 这些编码规则都是 <code>EUC</code> 类的编码规则.</p>
<p>是不是头都大了? 😂 只要知道不同的 <code>ANSI 字符集</code> 会采用一些不同的编码规则即可. </p>
<p>总结一下, <code>ANSI</code> 是一类字符集的统称, 不同的国家有其自己的 ANSI 字符集, 不同的字符集也会对应不同的编码规则, 同样编码规则也都有各自的名称.</p>
<p>有人可能会问, 后面不是会出现 Unicode 这种全球统一的字符集吗, 那为什么还要继续使用和发展 ASNI 这种国家之间无法兼容的字符集呢? 这个问题呢我后面会解答.</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>ASNI 出现之后, 各个国家的字符需求基本都解决了, 但是因为每个国家制定了他们各自的字符集和对应的编码方案, 所以各个国家之间的字符集不通用, 于是制定一套全球统一编码的呼声越加强烈! 最后 <code>ISO</code> 即 <code>国际标准化组织</code> 实在看不下去了, 为了解决不同国家 ANSI 的冲突问题, ISO 就制定了一套全球统一编码, 即 <code>Unicode</code>. </p>
<p><code>Unicode</code> 时代的时候, 字符集和编码规则就已经很明确了, Unicode 仅仅只是一种字符集. 其中定义了全世界所有符号的唯一标识 ID, 并且一直在不断地修订. 2020 年 3 月的 <code>ISO/IEC 10646:2020</code> 标准中, 已经包含了 143924 个字符.</p>
<p>如果使用简单的 <code>字符集所定义的 ID 的二进制形式就直接是编码规则</code> 的方法来存储 Unicode 字符集, 将会造成极大的浪费, 于是为了解决 Unicode 这个庞大字符集的存储和网络传输问题, 对应 Unicode 字符集的编码规则就出现了. 其中最常用的就是 <code>UTF-8</code> 编码规则了. 其他的编码规则还有 <code>UTF-16 BE</code>, (Big-Endian 大端序) <code>UTF-16 LE</code> (Little-Endian 小端序), <code>UTF-32</code>, <code>UTF-7</code>, <code>Punycode</code>, <code>CESU-8</code>, <code>SCSU</code>, <code>GB18030</code> 等等.</p>
<p>对于之前说的为什么还要继续使用 ANSI 字符集的原因是, Unicode 下的各种编码规则, 对于常用汉字, 基本上都是占用 3 个字节, 生僻汉字可能占用到 6 个字节. 对于 <code>GB2312</code> 和 <code>GBK</code> 来讲, UTF-8 无疑造成了浪费, 所以, UTF-8 可以说是对英文友好, 但对中文不友好的一种编码方式. 所以在中文界,  GB2312 与 GBK 依旧有自己的市场. 但是按照目前的趋势来看, 硬盘都是白菜价, 电脑性能也已经足够无视这点性能的消耗了. 所以推荐所有的网页使用统一编码: UTF-8. </p>
<p>其中关于 UTF-8, GB18030 内部的具体编码规则就不展开说了 (其实我也不会, 哈哈), 有兴趣的可以自己搜索资料, 维基百科就是一个比较好的选择. </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>美国人为了表示日常用的字符, 制定了 ASCII.</li>
<li>欧洲人为了表示日常用的字符, 扩充了 ASCII.</li>
<li>中国人为了表示常用简体汉字, 制定了 GB2312.</li>
<li>中国人为了表示生僻汉字和繁体字, 扩充 GB2312 为 GBK.</li>
<li>ISO 为了统一全世界的字符, 制定了 Unicode.</li>
<li>国际上为了方便 Unicode 的传输和存储, 制定了 UTF-8.</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMDcvMTAvYXNjaWlfdW5pY29kZV9hbmRfdXRmLTguaHRtbA==">字符编码笔记: ASCII, Unicode 和 UTF-8<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cDovL3d3dy5xaWFueGluZ3poZW0uY29tL3Bvc3QtMTQ5OS5odG1s">网页编码就是那点事<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIzMzc0MDc4L2Fuc3dlci8yNDM4NTk2Mw==">Unicode 和 UTF-8 有什么区别<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIxODg3MjQ2L2Fuc3dlci8xOTYzMTIzNQ==">字符集和编码方式的区别<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTQ2NzIzMS9hcnRpY2xlL2RldGFpbHMvODY1NTA4NTQ=">ASCII 码和 ANSI 码的区别<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjA4OWM1YjUxODgyNTM4YzAyZjAzZWI=">从 ASCII 到 UTF-8 字符集到底是什么<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzU3NDYxNjE0L2Fuc3dlci8yNzQ2MzQ3MjA=">ASCII 码  和 Unicode 码是什么关系<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑使用技巧及常见问题</title>
    <url>/computer/computer_issues.html</url>
    <content><![CDATA[<h1 id="PowerShell-出现-quot-因为在此系统中禁止执行脚本-quot-的解决方法"><a href="#PowerShell-出现-quot-因为在此系统中禁止执行脚本-quot-的解决方法" class="headerlink" title="PowerShell 出现 &quot;因为在此系统中禁止执行脚本&quot; 的解决方法"></a>PowerShell 出现 &quot;因为在此系统中禁止执行脚本&quot; 的解决方法</h1><p>新装的系统在 Powershell 直接执行 hexo 命令的时候可能会出现这种情况: <code>****, 因为在此系统中禁止执行脚本. 有关详细信息, 请参阅 &quot;get-help about_signing&quot;</code>. 这是由于脚本的签名不符合 Windows PowerShell 的执行策略导致的, 我们要做的就是修改 Windows Power Shell 的脚本执行策略. Windows Power Shell 提供了六种执行策略: <code>Restricted</code>, <code>AllSigned</code>, <code>RemoteSigned</code>, <code>Unrestricted</code>, <code>Bypass</code>, <code>Undefined</code>. </p>
<ul>
<li>Restricted: 可以执行单个的命令, 但是不能执行脚本.</li>
<li>AllSigned: 只能运行具有数字签名的脚本. </li>
<li>RemoteSigned: 当执行从网络上下载的脚本时, 需要脚本具有数字签名, 否则不会运行这个脚本. 如果是在本地创建的脚本则可以直接执行, 不要求脚本具有数字签名. </li>
</ul>
<h2 id="如何查看当前-Windows-Power-Shell-的执行策略"><a href="#如何查看当前-Windows-Power-Shell-的执行策略" class="headerlink" title="如何查看当前 Windows Power Shell 的执行策略"></a>如何查看当前 Windows Power Shell 的执行策略</h2><p>在 Windows Power Shell 中执行 <code>Get-executionpolicy</code> 可以查看当前 Power Shell 的设置, 执行策略也分为了五个部分, 修改执行策略时可以使用 <code>-Scope</code> 参数指定具体要设置哪个 Scope.</p>
<table>
<thead>
<tr>
<th align="left">Scope</th>
<th align="left">ExecutionPolicy</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MachinePolicy</td>
<td align="left">Undefined</td>
</tr>
<tr>
<td align="left">UserPolicy</td>
<td align="left">Undefined</td>
</tr>
<tr>
<td align="left">Process</td>
<td align="left">Undefined</td>
</tr>
<tr>
<td align="left">CurrentUser</td>
<td align="left">Undefined</td>
</tr>
<tr>
<td align="left">LocalMachine</td>
<td align="left">Undefined</td>
</tr>
</tbody></table>
<h2 id="问题解决办法"><a href="#问题解决办法" class="headerlink" title="问题解决办法"></a>问题解决办法</h2><p>将 Windows Power Shell 的执行策略更改为 RemoteSigned, 使用管理员权限启动 Windows Power Shell, 执行 </p>
<p><code>Set-ExecutionPolicy &quot;RemoteSigned&quot; -Scope Process</code></p>
<p>它会询问是否要更改执行策略? 键入 <code>y</code> 确认即可. </p>
<p>更多详细信息请参考博客: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc3BhcmtkZXYvcC83NDYwNTE4Lmh0bWw=">sparkdev<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="「打开方式」中残留已卸载的应用程序"><a href="#「打开方式」中残留已卸载的应用程序" class="headerlink" title="「打开方式」中残留已卸载的应用程序"></a>「打开方式」中残留已卸载的应用程序</h1><p>注册表里面 HKEY_CLASSES_ROOT 文件中, 删除对应程序名称的文件夹即可. </p>
<h1 id="文件-程序的图标显示不正确或丢失"><a href="#文件-程序的图标显示不正确或丢失" class="headerlink" title="文件, 程序的图标显示不正确或丢失"></a>文件, 程序的图标显示不正确或丢失</h1><p>Win R 打开 「运行」, 然后输入 <code>%localappdata%</code>, 删掉里面的「IconCache.db」文件, 重启「资源管理器」. 「注意, IconCache.db 是隐藏文件哦~」</p>
<h1 id="资源管理器没有启动"><a href="#资源管理器没有启动" class="headerlink" title="资源管理器没有启动"></a>资源管理器没有启动</h1><p>资源管理器没有启动, 表现为没有桌面, 没有任务栏, 这样就无法通过鼠标操作电脑, 只能通过键盘操作. </p>
<p>解决办法有两种: </p>
<ol>
<li><p>Win R, 输入 <code>explorer</code>, 开启资源管理器, </p>
</li>
<li><p>打开任务管理器, 新建任务, 输入 <code>explorer</code>, 开启资源管理器. </p>
</li>
</ol>
<h1 id="chm-文件打开后无法显示内容"><a href="#chm-文件打开后无法显示内容" class="headerlink" title=".chm 文件打开后无法显示内容"></a>.chm 文件打开后无法显示内容</h1><p>从网上下载的离线技术文档很多都是.chm后缀, 打开后不显示内容是因为文件被锁定了. </p>
<p>右键-&gt;属性-&gt;在「解除锁定」前面打勾-&gt;应用-&gt;确定</p>
<h1 id="如何彻底卸载掉-QQ-搜狗-360-百度-等「安全」软件"><a href="#如何彻底卸载掉-QQ-搜狗-360-百度-等「安全」软件" class="headerlink" title="如何彻底卸载掉 QQ, 搜狗, 360, 百度 等「安全」软件"></a>如何彻底卸载掉 QQ, 搜狗, 360, 百度 等「安全」软件</h1><p>解决办法: 不安装这些软件. </p>
<h1 id="使用-DOS-命令合并多个-TS-流文件「-ts文件」"><a href="#使用-DOS-命令合并多个-TS-流文件「-ts文件」" class="headerlink" title="使用 DOS 命令合并多个 TS 流文件「.ts文件」"></a>使用 DOS 命令合并多个 TS 流文件「.ts文件」</h1><p><code>copy/b 待合并文件绝对目录 新文件的绝对目录</code> 「<strong>路径中不能存在空格</strong>」</p>
<ul>
<li><p>示例: <code>copy/b  E:\temps\*.ts  E:\temps\new.ts</code></p>
</li>
<li><p>执行该命令后, E:\temps 目录下的全部 TS 文件就被合并成一个 new.ts 文件了(原来的那堆 ts 文件仍然存在) . </p>
</li>
<li><p>使用 copy 命令的文件合并功能进行 ts 文件的合并, copy后面的 /b  参数表示把文件按二进制格式来合并, 如果不加这个参数, 则会把目标当成文本文件来合并, 并在文件内添加不必要的标记, 这会导致播放出错, 所以必须加 /b 参数. </p>
</li>
<li><p>该命令的合并顺序是按照文件的字母顺序来的, 比如文件名是disk1.ts, disk2.ts, disk3.ts, 那么该命令就会按照 disk1.ts + disk2.ts + disk3.ts 的顺序来合并这三个文件, 事实上, 绝大多数网上下载的高清文件, 都已经按字母序排列好了, 所以直接执行该命令即可. </p>
</li>
<li><p>如果用合成软件来合并, 请注意软件说明, 有些软件会在合并过程中进行重编码, 可能会导致视频文件的质量下降. </p>
</li>
</ul>
<h1 id="Windows-10-开启-CPU-虚拟化"><a href="#Windows-10-开启-CPU-虚拟化" class="headerlink" title="Windows 10 开启 CPU 虚拟化"></a>Windows 10 开启 CPU 虚拟化</h1><p>Win I -&gt; 更新和安全 -&gt; 恢复 -&gt; 高级启动 -&gt; 疑难解答 -&gt; UEFI 固件设置 -&gt; 开启 CPU 虚拟化</p>
<h1 id="U-盘在经过-Win-10-安装工具处理之后-容量变小了"><a href="#U-盘在经过-Win-10-安装工具处理之后-容量变小了" class="headerlink" title="U 盘在经过 Win 10 安装工具处理之后, 容量变小了"></a>U 盘在经过 Win 10 安装工具处理之后, 容量变小了</h1><ul>
<li>以管理员运行命令窗口 (cmd, powershell, Terminal), 输入 <code>diskpart</code>.</li>
<li>之后输入 <code>list disk</code> (可以看到磁盘 0, 磁盘 1等, 注意列出的 U 盘的编号).</li>
<li>输入命令: <code>sel disk #</code> (将 # 替换为上一步所看到的 U 盘的编号).</li>
<li>输入命令: <code>clean</code>  (完全清除该磁盘).</li>
<li>此时 U 盘在 Windows 电脑磁盘管理中就是一个完整且没有建分区的磁盘, 新建分区即可完全恢复. </li>
</ul>
<h1 id="系统时不时自动打开浏览器-跳转到-MSN-页面"><a href="#系统时不时自动打开浏览器-跳转到-MSN-页面" class="headerlink" title="系统时不时自动打开浏览器, 跳转到 MSN 页面"></a>系统时不时自动打开浏览器, 跳转到 MSN 页面</h1><p>解决方法: 关闭 Windows 网络连接状态指示器的活动测试.  (重装系统后, 也没有关闭这个功能, 为啥现在就不弹出了呢? 🤣) </p>
<p>详见此页面: <span class="exturl" data-url="aHR0cHM6Ly9nZXRhZG14LmNvbS8/Q2F0ZWdvcnk9V2luZG93c18xMF8yMDE2JlBvbGljeT1NaWNyb3NvZnQuUG9saWNpZXMuSW50ZXJuZXRDb21tdW5pY2F0aW9uTWFuYWdlbWVudDo6Tm9BY3RpdmVQcm9iZSZMYW5ndWFnZT16aC1jbg==">关闭 Windows 网络连接状态指示器的活动测试<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="Windows-系统中-System-System64-和-Syswow64-文件夹的区别"><a href="#Windows-系统中-System-System64-和-Syswow64-文件夹的区别" class="headerlink" title="Windows 系统中 System, System64 和 Syswow64 文件夹的区别"></a>Windows 系统中 System, System64 和 Syswow64 文件夹的区别</h1><ul>
<li><p>*32 位的 Windows 操作系统可以同时运行 32 位和 16 位代码, 而 64 位 Windows 操作系统可以直接运行 64 位代码, 同时通过使用 WoW64 (Windows on Windows 64) 也能运行 32 位代码.</p>
</li>
<li><p>64 位系统 安装目录 分为两种.</p>
<p>  64 位: C:\Program Files, 放置 64 位程序.</p>
<p>  32 位: C:\Program Files (x86), 放置 32 位程序.</p>
</li>
<li><p>32 位系统 系统目录(DLL)  分为两种</p>
<p>  32 位: C:\Windows\System32, 运行 32 位程序.</p>
<p>  16 位: C:\Windows\System, 运行 16 位程序.</p>
</li>
<li><p>64 位系统 系统目录(DLL)  分为两种</p>
<p>  64 位: C:\Windows\System32, 运行 64 位程序.</p>
<p>  32 位: C:\Windows\SysWOW64, 运行 32 位程序.</p>
</li>
<li><p>64 位系统注册表分为两种</p>
<p>  64 位: [HKEY_LOCAL_MACHINE\SOFTWARE]</p>
<p>  32 位: [HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node]</p>
</li>
</ul>
<p><font color=red><strong>结论</strong></font>: </p>
<p>在 64 位系统中运行 32 位的DLL:</p>
<ul>
<li><p>应将 DLL 放在 <code>C:\Windows\SysWOW64</code> 目录下, </p>
</li>
<li><p>写注册表应该是 <code>[HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node]</code> 下, </p>
</li>
<li><p>调用的程序应该在 <code>C:\Program Files (x86)</code> 下, </p>
</li>
<li><p>注册表中的键值应该指向的是 <code>C:\Windows\SysWOW64</code> 下.</p>
</li>
</ul>
<h1 id="如何比较两个超大的-包含几万条数据的-Excel-文件"><a href="#如何比较两个超大的-包含几万条数据的-Excel-文件" class="headerlink" title="如何比较两个超大的, 包含几万条数据的 Excel 文件"></a>如何比较两个超大的, 包含几万条数据的 Excel 文件</h1><ol>
<li><p>打开 Excel 文件, 将文件另存为 <code>.CSV</code> 文件.</p>
</li>
<li><p>使用第三方的文本对比软件对比即可. 推荐使用 <code>Diffinity</code>, 官网: <span class="exturl" data-url="aHR0cHM6Ly93d3cudHJ1ZWh1bWFuZGVzaWduLnNlL3NfZGlmZmluaXR5LnBocA==">Diffinity<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ol>
<h1 id="Excel-中数字最后几位总是-0-无法修改"><a href="#Excel-中数字最后几位总是-0-无法修改" class="headerlink" title="Excel 中数字最后几位总是 0, 无法修改!"></a>Excel 中数字最后几位总是 0, 无法修改!</h1><ol>
<li><p>出现这个问题的原因是: Excepl 对数字只保留前 15 位为有效数字, 后面的数字就只保存为 0 了.</p>
</li>
<li><p>解决方案: 在数字最前面加一个单引号: <code>&#39;</code>. 如: <code>&#39;827389791635671528358</code>.</p>
</li>
<li><p>Excel 的单元格中, 如果第一个字符是单引号, Excel 并不会将其解释为单引号, 而是解释为特殊字符, 功能是将其后的文本强制使用字符串形式进行保存.</p>
</li>
</ol>
<h1 id="设置-Windows-访问不同-IP-时使用不同的网络"><a href="#设置-Windows-访问不同-IP-时使用不同的网络" class="headerlink" title="设置 Windows 访问不同 IP 时使用不同的网络"></a>设置 Windows 访问不同 IP 时使用不同的网络</h1><p>这个效果是通过设置 Windows 路由表实现的.</p>
<h2 id="路由表查看方法"><a href="#路由表查看方法" class="headerlink" title="路由表查看方法:"></a>路由表查看方法:</h2><p>在 <code>Power Shell</code> 中使用 <code>route print</code> 命令可以查看路由表信息.</p>
<h3 id="路由表信息"><a href="#路由表信息" class="headerlink" title="路由表信息:"></a>路由表信息:</h3><table>
<thead>
<tr>
<th>名称</th>
<th>网络目标</th>
<th>网络掩码</th>
<th>网关</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>内网</td>
<td>0.0.0.0</td>
<td>0.0.0.0</td>
<td>192.168.10.254</td>
<td>192.168.11.95</td>
</tr>
<tr>
<td>外网</td>
<td>0.0.0.0</td>
<td>0.0.0.0</td>
<td>192.168.42.129</td>
<td>192.168.42.140</td>
</tr>
</tbody></table>
<h2 id="路由表的预备知识"><a href="#路由表的预备知识" class="headerlink" title="路由表的预备知识"></a>路由表的预备知识</h2><p>默认路由规则: 0.0.0.0</p>
<p>普通路由规则: 有且至少有一个具体数字</p>
<h2 id="路由表的操作命令-实现本效果的步骤"><a href="#路由表的操作命令-实现本效果的步骤" class="headerlink" title="路由表的操作命令 (实现本效果的步骤) :"></a>路由表的操作命令 (实现本效果的步骤) :</h2><ol>
<li><p>Power Shell 输入命令: <code>route delete 0.0.0.0</code></p>
<p>作用: 将<strong>默认</strong>路由规则清空</p>
</li>
<li><p>Power Shell 输入命令: <code>route add -p 0.0.0.0 mask 0.0.0.0 192.168.42.129</code></p>
<p>作用: 添加<strong>默认</strong>路由规则, 并使用 <code>-p</code> 参数设置为永久路由, 指向外网网关. 用于访问外网.</p>
</li>
<li><p>Power Shell 输入命令: <code>route add -p 192.168.0.0 mask 255.255.0.0 192.168.10.254</code></p>
<p>作用: 添加<strong>普通</strong>路由规则, 并使用 <code>-p</code> 参数设置为永久路由, 指向内网网关. 用于访问内网.</p>
</li>
</ol>
<h1 id="桌面上的文件不能拖动"><a href="#桌面上的文件不能拖动" class="headerlink" title="桌面上的文件不能拖动"></a>桌面上的文件不能拖动</h1><p>有时候桌面上的文件会变得无法拖动, 当然绝对不是设置了 &quot;自动排列&quot; 这种低级失误, 这时候按 2 下 <kbd>ESC</kbd> 键, 有奇效哦! (如果不行, 别打我, 反正我电脑可以!)</p>
<h1 id="常用-Win-组合快捷键-Windows-10"><a href="#常用-Win-组合快捷键-Windows-10" class="headerlink" title="常用 Win 组合快捷键 ( Windows 10)"></a>常用 Win 组合快捷键 ( Windows 10)</h1><p>Win 键可以说就是 Windows 的系统按键, 所以 Win 的组合快捷键都是和 Windows 操作相关的. </p>
<ul>
<li><code>Win Q</code> : 打开 搜索. </li>
<li><code>Win W</code> : 打开 工作区. </li>
<li><code>Win E</code> : <font color=red>打开 资源管理器. </font></li>
<li><code>Win R</code> : 打开 运行. </li>
<li><code>Win T</code> : 选中 任务栏上的图标, 可循环切换. </li>
<li><code>Win U</code> : 打开 设置中的轻松使用设置. </li>
<li><code>Win I</code> : 打开 设置. </li>
<li><code>Win P</code> : 更改 投影模式. </li>
<li><code>Win A</code> : 打开 桌面右下角的消息通知. </li>
<li><code>Win S</code> : 打开 搜索. </li>
<li><code>Win D</code> : <font color=red>显示 Windows 桌面, 再次按下 <code>Win D</code> 返回之前的页面. </font></li>
<li><code>Win F</code> : 打开 反馈中心. </li>
<li><code>Win H</code> : 进行 Windows 语音听写, 前提是当前焦点在一个文本编辑器上, 如记事本.  ( 这个功能 &quot;超棒&quot;, 只是语音识别不准确而已, 只是支持的应用特别少而已, 只是使用语音输入后必须关闭文件重新打开之后才能正常使用键盘输入而已...嗯...就这样...) </li>
<li><code>Win K</code> : 打开 连接, 检测外部显示设备. </li>
<li><code>Win L</code> : 实现 快速锁屏. </li>
<li><code>Win ;</code> : 打开 Windows 表情输入. </li>
<li><code>Win .</code> : <font color=red>打开 Windows 表情输入. </font></li>
<li><code>Win X</code> : 打开 开始菜单图标的右键菜单. </li>
<li><code>Win C</code> : 打开 小娜 Cortana.  ( 在设置中开启此快捷键) </li>
<li><code>Win V</code> : <font color=red> 打开 剪切板历史. 这个是真的好用. </font></li>
<li><code>Win B</code> : 选中 托盘栏中的第一个图标, 不能循环切换, 只能选择第一个. </li>
<li><code>Win M</code> : 最小化当前桌面中的所有窗口. 没有最小化功能的窗口无法最小化. </li>
<li><code>Win Table</code> : <font color=red>打开 Windows 10 时间线. </font></li>
</ul>
<h1 id="常用-Ctrl-组合快捷键"><a href="#常用-Ctrl-组合快捷键" class="headerlink" title="常用 Ctrl 组合快捷键"></a>常用 Ctrl 组合快捷键</h1><p>Ctrl 可能是 Control 的简写吧, 所以 Ctrl 快捷键和命令相关. </p>
<p>不同的应用程序会有不同的 Ctrl 组合快捷键, 而且大多数都可以进行自定义, 所以只列举常见的<strong>通用默认快捷键</strong>. <strong>下面所有的快捷键在不同的程序中稍有区别</strong>. </p>
<ul>
<li><code>Ctrl W</code> : <font color=red> 关闭当前页面.  </font></li>
<li><code>Ctrl A</code> : 全选. </li>
<li><code>Ctrl B</code> : 给字体加粗. Word 支持此快捷键. </li>
<li><code>Ctrl C</code> : 复制. </li>
<li><code>Ctrl S</code> : 保存. </li>
<li><code>Ctrl F</code> : 查找. </li>
<li><code>Ctrl Z</code> : 撤销一次操作. </li>
<li><code>Ctrl X</code> : 剪切. </li>
<li><code>Ctrl V</code> : 粘贴. </li>
<li><code>Ctrl Y</code> : <font color=red>恢复一次撤销. </font></li>
<li><code>Ctrl O</code> : 程序内部的 &quot;打开&quot; 功能. </li>
<li><code>Ctrl N</code> : 程序内部的 &quot;新建&quot; 功能. </li>
<li><code>Ctrl Enter</code> : 通讯软件输入消息时换行, 不发送. </li>
</ul>
<h1 id="常用-Alt-组合快捷键"><a href="#常用-Alt-组合快捷键" class="headerlink" title="常用 Alt 组合快捷键"></a>常用 Alt 组合快捷键</h1><p>Alt 主要和软件的菜单相关. </p>
<ul>
<li><code>Alt 左键双击</code> : <font color=red>快速查看文件, 文件夹的属性.</font></li>
<li><code>Alt Table</code> : 切换应用程序. </li>
</ul>
<h1 id="定制化"><a href="#定制化" class="headerlink" title="定制化"></a>定制化</h1><ul>
<li>按下 Win R, 输入 <code>shell:sendto</code>, 在之后的页面中就可以修改右键菜单中的「发送到」了. </li>
</ul>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>电脑技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统-Googosoft</title>
    <url>/computer/recovery_googosoft_computer.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="启用-Administrator-账号"><a href="#启用-Administrator-账号" class="headerlink" title="启用 Administrator 账号"></a>启用 Administrator 账号</h1><h1 id="修改-IP"><a href="#修改-IP" class="headerlink" title="修改 IP"></a>修改 IP</h1><blockquote>
<p><code>192.168.11.95</code></p>
</blockquote>
<blockquote>
<p><code>255.255.254.0</code></p>
</blockquote>
<blockquote>
<p><code>192.168.10.254</code></p>
</blockquote>
<p>修改完 IP 之后尝试连接:</p>
<blockquote>
<p><code>\\192.168.10.237</code></p>
</blockquote>
<blockquote>
<p><code>账号: administrator</code></p>
</blockquote>
<blockquote>
<p><code>密码: googosoft@123</code></p>
</blockquote>
<h1 id="安装-PLSQL"><a href="#安装-PLSQL" class="headerlink" title="安装 PLSQL"></a>安装 PLSQL</h1><p>安装 PLSQL, 打开, 进行汉化以及破解. </p>
<h1 id="安装-Oracle"><a href="#安装-Oracle" class="headerlink" title="安装 Oracle"></a>安装 Oracle</h1><blockquote>
<p>安装 <code>Oracle Database</code>, <strong>不要修改子路径</strong>, 不要安装 <code>Oracle Client</code>.</p>
</blockquote>
<blockquote>
<p>之后使用 SQL PLUS 尝试连接: </p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">scott</span><br><span class="line">scott123</span><br><span class="line">192.168.10.237/sdzc0216</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之后使用 PLSQL 尝试连接:</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">scott</span><br><span class="line">scott123</span><br><span class="line">192.168.10.237/sdzc0216</span><br></pre></td></tr></table></figure>

<h1 id="设置-Windows-功能"><a href="#设置-Windows-功能" class="headerlink" title="设置 Windows 功能"></a>设置 Windows 功能</h1><blockquote>
<p>打开 Windows 功能. 开启所有的 Internet 功能, 之后重启. </p>
</blockquote>
<blockquote>
<p>打开 .Net Framework 3.5, 包含 2.0, 3.0</p>
</blockquote>
<h1 id="安装-VS-2005"><a href="#安装-VS-2005" class="headerlink" title="安装 VS 2005"></a>安装 VS 2005</h1><blockquote>
<p>VS 2005, 自定义安装. <font color='red'>切记安装路径中不能带有小括号. 因为 Oracle 数据库不识别小括号. </font></p>
</blockquote>
<blockquote>
<p><strong>只安装 Web, C#, 水晶报表</strong>.</p>
</blockquote>
<blockquote>
<p>使用 <code>VS 2005</code>, 尝试连接: </p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">scott</span><br><span class="line">scott123</span><br><span class="line">192.168.10.237/sdzc0216</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果安装 VS 时使用了自定义路径, 那么 VS 中模板会消失.</p>
</blockquote>
<blockquote>
<p>解决办法: <code>工具</code> -&gt; <code>选项</code> -&gt; <code>项目和解决方案</code> -&gt; <code>用户项目模板位置</code> 及 <code>用户项模板位置</code>, 修改为自己所安装的路径. </p>
</blockquote>
<blockquote>
<p>用户项目模板位置: <code>Microsoft Visual Studio 8/Common7/IDE/ProjectTemplates</code></p>
</blockquote>
<blockquote>
<p>用户项模板位置: <code>Microsoft Visual Studio 8/Common7/IDE/ItemTemplates </code></p>
</blockquote>
<h1 id="安装-VSS-2005"><a href="#安装-VSS-2005" class="headerlink" title="安装 VSS 2005"></a>安装 VSS 2005</h1><p>VSS 2005, 项目源码管理器. </p>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>Recovery</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统-Personal</title>
    <url>/computer/recovery_personal_computer.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="账户名称设置"><a href="#账户名称设置" class="headerlink" title="账户名称设置"></a>账户名称设置</h1><p>重装系统时, <font color='red'> <strong>不要用微软账户登录, 而是使用本地账户登陆</strong> </font>, 此时系统盘中账户文件夹的名称就是本地账户的名称, 之后再用微软账户登陆, 用户文件夹的名字就不会采用微软账户邮箱的前四个字母了. </p>
<h1 id="修正盘符"><a href="#修正盘符" class="headerlink" title="修正盘符"></a>修正盘符</h1><blockquote>
<p>右键 &quot;此电脑&quot; -&gt; &quot;管理&quot; -&gt; &quot;磁盘管理&quot;, 修正磁盘盘符. </p>
</blockquote>
<h1 id="Windows-10-基础设置"><a href="#Windows-10-基础设置" class="headerlink" title="Windows 10 基础设置"></a>Windows 10 基础设置</h1><blockquote>
<p>进入设置, 对 Windows 10 进行基础设置, 更改桌面图标, 更改鼠标样式.</p>
</blockquote>
<h1 id="将-quot-回收站-quot-添加进-quot-快速访问-quot"><a href="#将-quot-回收站-quot-添加进-quot-快速访问-quot" class="headerlink" title="将 &quot;回收站&quot; 添加进 &quot;快速访问&quot;"></a>将 &quot;回收站&quot; 添加进 &quot;快速访问&quot;</h1><blockquote>
<p>向快速访问中添加 &quot;回收站&quot;. </p>
</blockquote>
<h1 id="设置-quot-文件夹选项-quot"><a href="#设置-quot-文件夹选项-quot" class="headerlink" title="设置 &quot;文件夹选项&quot;"></a>设置 &quot;文件夹选项&quot;</h1><p>设置&quot;文件夹选项&quot;. 包括: </p>
<ul>
<li>设置 Win+E 打开 &quot;此电脑&quot;. </li>
<li>清除文件资源管理器的历史纪录. </li>
<li>设置 &quot;快速访问&quot; 不显示最近使用的文件, 文件夹. </li>
<li>显示文件后缀名, 始终显示隐藏文件. </li>
<li>用彩色显示加密或压缩的 NTFS 文件. </li>
<li>在标题栏中显示完整路径. </li>
</ul>
<h1 id="更改-quot-高级系统设置-quot"><a href="#更改-quot-高级系统设置-quot" class="headerlink" title="更改 &quot;高级系统设置&quot;"></a>更改 &quot;高级系统设置&quot;</h1><ul>
<li>计算机名称</li>
<li>将虚拟内存放置到固态硬盘, 空间大小 20G. </li>
<li>在系统保护中, 开启系统盘系统保护, 空间大小最大 8G. </li>
</ul>
<h1 id="禁用-Windows-Defender"><a href="#禁用-Windows-Defender" class="headerlink" title="禁用 Windows Defender"></a>禁用 Windows Defender</h1><p>组策略: gpedit.msc</p>
<h1 id="安装基础软件"><a href="#安装基础软件" class="headerlink" title="安装基础软件"></a>安装基础软件</h1><p>Bandzip, HoneyView, Chrome</p>
<h1 id="安装字体库"><a href="#安装字体库" class="headerlink" title="安装字体库"></a>安装字体库</h1><h1 id="安装必装软件"><a href="#安装必装软件" class="headerlink" title="安装必装软件"></a>安装必装软件</h1><h2 id="解压即用"><a href="#解压即用" class="headerlink" title="解压即用"></a>解压即用</h2><ul>
<li>Bandicam Portable  </li>
<li>EBWin</li>
<li>Snipaste</li>
<li>Uninstall Tool</li>
<li>GoldWave</li>
<li>Clash for Windows</li>
<li>Mp3tag</li>
<li>Wise Registry Cleaner</li>
</ul>
<h2 id="重要软件"><a href="#重要软件" class="headerlink" title="重要软件"></a>重要软件</h2><ul>
<li>Steam</li>
<li>Microsoft Office</li>
<li>Photoshop</li>
<li>Microsoft Visual Studio</li>
<li>Unity</li>
<li>ToDesk</li>
</ul>
<p>[<strong>注</strong>]</p>
<ol>
<li>Microsoft Visual Studio 安装背景图片插件.</li>
</ol>
]]></content>
      <categories>
        <category>Computer</category>
      </categories>
      <tags>
        <tag>Recovery</tag>
      </tags>
  </entry>
  <entry>
    <title>csharp 中一些琐碎的知识</title>
    <url>/csharp/csharp_others.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在写一些自定义类的时候, 想让其他类比较方便地访问自定义类中的数据或者方法, 就想到了索引器, 还有一些其他的可以提高自定义类实用性或者提高程序易读性的 csharp 语法, 现在已经用了一段时间了, 写一篇博客, 回忆一下, 总结一下.</p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><ol>
<li><p>string 是引用类型.</p>
</li>
<li><p>string 具有不变性, 一旦 string 被创建, 其中的任何字符都不允许改变.</p>
</li>
<li><p>string 重新赋值时, 会建立一个新的 string 对象, 并使指针指向这个新的 string 对象.</p>
</li>
<li><p>如果需要多次修改 string 的值, 应该使用 StringBuilder.</p>
</li>
</ol>
<h1 id="const-和-readonly-的区别"><a href="#const-和-readonly-的区别" class="headerlink" title="const 和 readonly 的区别"></a>const 和 readonly 的区别</h1><p>const 和 readonly 两者在使用上有些相似, 但其本质却又完全不同.</p>
<ol>
<li><p>const 通常叫做: <font color='red'><strong>静态常量</strong></font> 或者 <font color='red'><strong>编译时常量</strong></font>, readonly 通常叫做: <font color='red'><strong>动态常量</strong></font> 或者 <font color='red'><strong>运行时常量</strong></font>.</p>
</li>
<li><p>const 只能修饰 <font color='red'><strong>基元类型, 字符串, 枚举</strong></font> , 不允许修饰结构体.</p>
<p> [<strong>注</strong>] const 的值必须在编译阶段被唯一确定, 如果 const 修饰的是引用类型 (string 除外), 则只能被初始化为 null. 又因为 const 的值不可被修改, 所以 null 便没有任何意义, 即 const 修饰引用类型虽然编译器不会报错, 但是没有任何实际意义.</p>
</li>
<li><p>const 使用表达式进行初始化时, 表达式中的所有值都必须能够在编译阶段被唯一确定.</p>
</li>
<li><p>const 修饰的值会隐式使用 static 修饰, 因此只能通过类名访问, 同时 const 不可以显式使用 static 修饰.</p>
</li>
<li><p>const 比 readonly 更高效, 但灵活性差. const 常用于定义永不改变且完全唯一的变量, 如圆周率 π, 真空中光速 с, 普朗克常数 h, 基本电荷 e, 电子静止质量和阿伏伽德罗常数等.</p>
</li>
<li><p>readonly 通常和 static 搭配使用, 即 <code>static readonly</code>, 以代替灵活性不足的 const.</p>
</li>
<li><p>readonly 只能修饰类变量, 不能修饰方法内的局部变量. const 没有此限制.</p>
</li>
<li><p>const 必须在定义时进行初始化, 且之后不可再次赋值. 而 readonly 在定义时可以进行初始化, 同时在构造函数中也可以进行赋值, 因此当使用不同的构造函数来创建实例时, readonly 的值可能不同, 但除此以外不可再次赋值.</p>
</li>
<li><p>readonly 修饰的引用类型, 只是引用本身不可被修改, 其内部的成员变量依旧可以被修改!</p>
</li>
</ol>
<h1 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h1><p>索引器语法可以让自定义类像数组一样, 可以使用索引来直接访问其中的数据, 这样外部类在取用我们内部数据的时候就很方便了.</p>
<h2 id="如何在自定义类中实现索引器"><a href="#如何在自定义类中实现索引器" class="headerlink" title="如何在自定义类中实现索引器"></a>如何在自定义类中实现索引器</h2><ol>
<li><p>csharp 中需要使用 <code>getter</code> 和 <code>setter</code> 来实现索引器.</p>
</li>
<li><p>索引器的名称是固定的, 只能是 <code>this</code>.</p>
</li>
<li><p>建立索引器时, 访问限制通常都设置为 <code>public</code>, 虽然语法上并没有任何限制, 但是除非是仅内部使用, 否则这个索引器没有任何意义~</p>
</li>
<li><p>索引器也具有返回值和参数值, 返回值和方法的写法是完全一致的, 但是索引器的参数是使用方括号 <font color='red'><strong>[]</strong></font> 包起来的, 这一点要注意!</p>
</li>
<li><p>索引器的返回值和参数值并没有特殊要求, 不仅仅可以是 <code>int</code> 类型, 其他类型也可以.</p>
</li>
<li><p>索引器也可以重载, 在一个类中编写多个不同参数的索引器, 方便外部调用.</p>
</li>
</ol>
<h2 id="索引器实例"><a href="#索引器实例" class="headerlink" title="索引器实例"></a>索引器实例</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">IndexerTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> Vector2</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Vector2</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> EM_Direction</span><br><span class="line">    &#123;</span><br><span class="line">        Up, Down, Left, Right</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            IndexerDirection indexer = <span class="keyword">new</span> IndexerDirection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 需要依次操作四个方向时, 可以直接使用 for 循环, 索引为 int 类型</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(indexer[i].x + <span class="string">&quot;, &quot;</span> + indexer[i].y);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 单独操作特定方向时, 可以使用 枚举 作为索引</span></span><br><span class="line">            Console.WriteLine(indexer[EM_Direction.Up].x + <span class="string">&quot;, &quot;</span> + indexer[EM_Direction.Up].y);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 方向索引器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IndexerDirection</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Vector2 up = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> Vector2 down = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">private</span> Vector2 left = <span class="keyword">new</span> Vector2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">private</span> Vector2 right = <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Vector2 <span class="keyword">this</span>[EM_Direction index]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (index)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> EM_Direction.Up:</span><br><span class="line">                        <span class="keyword">return</span> up;</span><br><span class="line">                    <span class="keyword">case</span> EM_Direction.Down:</span><br><span class="line">                        <span class="keyword">return</span> down;</span><br><span class="line">                    <span class="keyword">case</span> EM_Direction.Left:</span><br><span class="line">                        <span class="keyword">return</span> left;</span><br><span class="line">                    <span class="keyword">case</span> EM_Direction.Right:</span><br><span class="line">                        <span class="keyword">return</span> right;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> up;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (index)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> EM_Direction.Up:</span><br><span class="line">                        up = <span class="keyword">value</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EM_Direction.Down:</span><br><span class="line">                        down = <span class="keyword">value</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EM_Direction.Left:</span><br><span class="line">                        left = <span class="keyword">value</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EM_Direction.Right:</span><br><span class="line">                        right = <span class="keyword">value</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        up = <span class="keyword">value</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Vector2 <span class="keyword">this</span>[<span class="keyword">int</span> index]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (index)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> up;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> down;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        <span class="keyword">return</span> left;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        <span class="keyword">return</span> right;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;下标越界!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (index)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        up = <span class="keyword">value</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        down = <span class="keyword">value</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        left = <span class="keyword">value</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        right = <span class="keyword">value</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;下标越界!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h1><p>这个语法我在另一篇博客 <a href="https://kuroha.vip/csharp/delegate_01.html">委托(一) 委托的基本用法</a> 的代码块中用过, 没想到长时间不用, 便忘得一干二净了...🙄</p>
<h2 id="别名的语法规则"><a href="#别名的语法规则" class="headerlink" title="别名的语法规则"></a>别名的语法规则</h2><ol>
<li><p>起别名的格式为: &quot; using 新名称 = 类型; &quot;.</p>
</li>
<li><p>在命名空间外进行重命名时, 必须写被重命名类型的完整路径.</p>
</li>
<li><p>在命名空间内进行重命名时, 可以使用 using 引用简化路径.</p>
</li>
<li><p>&quot;重命名操作&quot; 只能在命名空间外部或者命名空间内部的最上方书写, 不能写在类, 方法等内部.</p>
</li>
</ol>
<h2 id="别名实例"><a href="#别名实例" class="headerlink" title="别名实例"></a>别名实例</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> NumberDic = System.Collections.Generic.Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;; <span class="comment">// 将 int int 类型的字典重命名为 NumberDic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RenameTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> StringDic = Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;; <span class="comment">// 将 string string 类型的字典重命名为 StringDic</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//using CharDic = Dictionary&lt;char, char&gt;; // 写在这里将编译错误</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// 定义一个 NumberDic 实例</span></span><br><span class="line">            NumberDic numberDic = <span class="keyword">new</span> NumberDic</span><br><span class="line">            &#123;</span><br><span class="line">                &#123; <span class="number">1</span>, <span class="number">10000</span> &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义一个 StringDic 实例</span></span><br><span class="line">            StringDic stringDic = <span class="keyword">new</span> StringDic</span><br><span class="line">            &#123;</span><br><span class="line">                &#123; <span class="string">&quot;1&quot;</span>, <span class="string">&quot;10000&quot;</span> &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(numberDic[<span class="number">1</span>]);</span><br><span class="line">            Console.WriteLine(stringDic[<span class="string">&quot;1&quot;</span>]);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>在自定义类中实现常用运算符的重载后, 外部进行变量间运算时就很方便了. 最常见的重载运算符就是相等运算符 == 了.</p>
<h2 id="运算符重载的语法规则"><a href="#运算符重载的语法规则" class="headerlink" title="运算符重载的语法规则"></a>运算符重载的语法规则</h2><ol>
<li><p>&quot;重载&quot; 一词便决定了只能重写已有的运算符, 不能自创运算符.</p>
</li>
<li><p>并不是所有的运算符都可以重载, 如赋值运算符不能被重载.</p>
</li>
<li><p>必须使用 <code>public static 返回值类型 operator 运算符 () &#123; &#125; </code> 的格式来重载运算符.</p>
</li>
<li><p>参数的数量必须和运算符原本的参数数量一致.</p>
</li>
<li><p>某些运算符必须成对重载. 像大于 &#39;&gt;&#39; 和小于 &#39;&lt;&#39;.</p>
</li>
</ol>
<h2 id="运算符重载实例"><a href="#运算符重载实例" class="headerlink" title="运算符重载实例"></a>运算符重载实例</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">OperatorTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Player a = <span class="keyword">new</span> Player()</span><br><span class="line">            &#123;</span><br><span class="line">                id = <span class="string">&quot;001&quot;</span>,</span><br><span class="line">                name = <span class="string">&quot;Kirito&quot;</span>,</span><br><span class="line">                email = <span class="string">&quot;Kirito@Kirito.com&quot;</span>,</span><br><span class="line">                level = <span class="number">78</span>,</span><br><span class="line">                hp = <span class="number">170000</span>,</span><br><span class="line">                mp = <span class="number">8000</span></span><br><span class="line">            &#125;;</span><br><span class="line">            Player b = <span class="keyword">new</span> Player()</span><br><span class="line">            &#123;</span><br><span class="line">                id = <span class="string">&quot;002&quot;</span>,</span><br><span class="line">                name = <span class="string">&quot;Asuna&quot;</span>,</span><br><span class="line">                email = <span class="string">&quot;Asuna@Asuna.com&quot;</span>,</span><br><span class="line">                level = <span class="number">76</span>,</span><br><span class="line">                hp = <span class="number">150000</span>,</span><br><span class="line">                mp = <span class="number">170000</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Player c = a + b;</span><br><span class="line">            Console.WriteLine(c.id);</span><br><span class="line">            Console.WriteLine(c.name);</span><br><span class="line">            Console.WriteLine(c.email);</span><br><span class="line">            Console.WriteLine(c.level);</span><br><span class="line">            Console.WriteLine(c.hp);</span><br><span class="line">            Console.WriteLine(c.mp);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> Player</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> id;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> email;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> level;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> hp;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> mp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载运算符 +</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Player <span class="keyword">operator</span> + (Player a, Player b)</span><br><span class="line">        &#123;</span><br><span class="line">            Player player = <span class="keyword">new</span> Player</span><br><span class="line">            &#123;</span><br><span class="line">                id = a.id,</span><br><span class="line">                name = a.name,</span><br><span class="line">                email = a.email,</span><br><span class="line">                level = a.level + b.level,</span><br><span class="line">                hp = a.hp + b.hp,</span><br><span class="line">                mp = a.mp + b.mp</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> player;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载运算符 -</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Player <span class="keyword">operator</span> - (Player a, Player b)</span><br><span class="line">        &#123;</span><br><span class="line">            Player player = <span class="keyword">new</span> Player</span><br><span class="line">            &#123;</span><br><span class="line">                id = a.id,</span><br><span class="line">                name = a.name,</span><br><span class="line">                email = a.email,</span><br><span class="line">                level = a.level - b.level,</span><br><span class="line">                hp = a.hp - b.hp,</span><br><span class="line">                mp = a.mp - b.mp</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> player;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="和"><a href="#和" class="headerlink" title="? 和 ??"></a>? 和 ??</h1><h2 id="可空-Nullable-类型"><a href="#可空-Nullable-类型" class="headerlink" title="? 可空 (Nullable) 类型"></a>? 可空 (Nullable) 类型</h2><p>如果编程时有一种特殊的需求, 比如接收一个返回值, 这个返回值在运算有效时返回 int 类型, 但是在运算无效时返回 null 类型, 此时就可以使用 csharp 中的 Nullable 类型来接收. 单问号就是做这个的.</p>
<p>在 int, double, bool 等无法直接赋值为 null 的数据类型后面加一个 ? 所定义出来的变量便可以赋值为 null.</p>
<h2 id="Nullable-类型变量的定义"><a href="#Nullable-类型变量的定义" class="headerlink" title="Nullable 类型变量的定义"></a>Nullable 类型变量的定义</h2><p><font color='red'><strong>?</strong> 可以紧跟在类型后面, 也可以不紧跟.</font></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ? intNullable = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">bool</span> ? boolNullable = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">float</span>? floatNullable = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">double</span>? doubleNullable = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="为空判断"><a href="#为空判断" class="headerlink" title="?? 为空判断"></a>?? 为空判断</h2><p>csharp 提供了一个双问号运算符来判断表达式是否为空, 如果为空则返回 ?? 后面的值, 如果不为空, 则返回自身.</p>
<h2 id="的使用"><a href="#的使用" class="headerlink" title="?? 的使用"></a>?? 的使用</h2><p>下方代码段中, 如果 intNullable 为 null, 则打印数字 0, 不是 null, 则打印 intNullable 自身.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>? intNullable = <span class="literal">null</span>;</span><br><span class="line">Console.WriteLine(intNullable ?? <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h1><p>预处理指令编写的逻辑是, 让编译器在正式编译代码之前, 对代码进行处理.</p>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><ol>
<li><p>预处理指令必须以 <font color='red'><strong>#</strong></font> 开头.</p>
</li>
<li><p>预处理指令必须位于行首.</p>
</li>
<li><p>预处理执行不是语句, 不以分号 &#39;;&#39; 结尾.</p>
</li>
</ol>
<h2 id="常用预处理指令"><a href="#常用预处理指令" class="headerlink" title="常用预处理指令"></a>常用预处理指令</h2><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><table>
<thead>
<tr>
<th align="left">预处理指令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#define</td>
<td align="left">定义符号</td>
</tr>
<tr>
<td align="left">#undef</td>
<td align="left">取消定义符号</td>
</tr>
</tbody></table>
<h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><table>
<thead>
<tr>
<th align="left">预处理指令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#if</td>
<td align="left">条件指令的开始符号, 判断特定符号是否被定义</td>
</tr>
<tr>
<td align="left">#elif</td>
<td align="left">创建复合条件指令</td>
</tr>
<tr>
<td align="left">#else</td>
<td align="left">创建复合条件指令</td>
</tr>
<tr>
<td align="left">#endif</td>
<td align="left">条件指令的结束符号</td>
</tr>
</tbody></table>
<h3 id="信息输出"><a href="#信息输出" class="headerlink" title="信息输出"></a>信息输出</h3><table>
<thead>
<tr>
<th align="left">预处理指令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#warning</td>
<td align="left">从代码的指定位置生成一个警告</td>
</tr>
<tr>
<td align="left">#error</td>
<td align="left">从代码的指定位置生成一个错误</td>
</tr>
</tbody></table>
<h3 id="大纲管理"><a href="#大纲管理" class="headerlink" title="大纲管理"></a>大纲管理</h3><table>
<thead>
<tr>
<th align="left">预处理指令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#region</td>
<td align="left">指定一个可折叠的代码块</td>
</tr>
<tr>
<td align="left">#endregion</td>
<td align="left">标识 #region 结束</td>
</tr>
</tbody></table>
<h3 id="信息控制"><a href="#信息控制" class="headerlink" title="信息控制"></a>信息控制</h3><table>
<thead>
<tr>
<th align="left">预处理指令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#line</td>
<td align="left">修改编译器输出<font color='red'><strong>错误和警告</strong></font>的行数, 文件名</td>
</tr>
<tr>
<td align="left">#pragma</td>
<td align="left">抑制或还原指定的编译<font color='red'><strong>警告</strong></font></td>
</tr>
</tbody></table>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Exercise</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">line</span> 200 &quot;boss.cs&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span> 这里其实是 Program.cs 文件的第 6 行!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">line</span> default</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> 这里其实是 Program.cs 文件的第 8 行!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上面的代码段在编译时产生的警告和错误信息是:</p>
<p><img data-src="/images/csharp/others/preprocessor_line.png" alt="line 命令"></p>
<p>可以看到警告信息的文件名被修改为了 boss.cs, 行号变成了 200; 而错误信息的文件名和行号都是正确的.</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9jc2hhcnAvY3NoYXJwLW9wZXJhdG9yLW92ZXJsb2FkaW5nLmh0bWw=">C# 运算符重载<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9jc2hhcnAvY3NoYXJwLXByZXByb2Nlc3Nvci1kaXJlY3RpdmVzLmh0bWw=">C# 预处理指令<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaW5lSG9vL2FydGljbGUvZGV0YWlscy81MjU2Nzgx">const与readonly的区别<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>委托(一) 委托的基本用法</title>
    <url>/csharp/delegate_01.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="本文重点"><a href="#本文重点" class="headerlink" title="本文重点"></a>本文重点</h1><ol>
<li><p>delegate 和 Delegate 的区别</p>
</li>
<li><p>定义委托</p>
</li>
<li><p>实例化委托</p>
</li>
<li><p>Action 和 Func</p>
</li>
<li><p>委托的基本用法</p>
</li>
</ol>
<h1 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a>delegate</h1><p><code>delegate</code> 是一个类型关键字, 和它类似的还有: <code>class</code>, <code>interface</code>, <code>enum</code> 等等. 这类关键字都是用来定义的, 而不是实例化的. 枚举类型使用 <code>enum</code> 进行定义, 委托类型使用 <code>delegate</code> 进行定义. 因此 <font color='red'><strong>delegate 不是类! 它只是一个类型关键字! 用来定义类型的.</strong></font></p>
<h1 id="System-String-string-和-System-Delegate-delegate"><a href="#System-String-string-和-System-Delegate-delegate" class="headerlink" title="System.String - string 和 System.Delegate - delegate"></a>System.String - string 和 System.Delegate - delegate</h1><p>System.String 是 .Net 框架中的一个类, .Net 框架中包含多种编程语言, 其中 C# 语言中给 System.String 起了一个别名 string, 因此 <code>string str</code> 和 <code>System.String str</code> 是没有区别的, <code>string</code> 就是一个类, <code>string str</code> 这一个代码不是在定义类型, 而是在实例化对象. 但是 <code>delegate</code> 和 <code>System.Delegate</code> 的关系就不是这样了. <code>System.Delegate</code> 是一个类, 而 <code>delegate</code> 则是一个 <code>类型关键字</code>, 它是用来定义委托的, 就像 <code>class</code> 定义类, <code>struct</code> 定义结构体, <code>enum</code> 定义枚举一样, 这些关键字是同一个级次的, 但他们都不是类. </p>
<p>如下图, String, string, Delegate 都可以调用类中的静态方法, 这是因为他们都是类, 但是 delegate 则不可以, 因为它仅仅只是一个类型关键字.</p>
<p><img data-src="/images/csharp/delegate/delegate_01.png" alt="delegate"></p>
<h1 id="🦄如何定义一个委托类型"><a href="#🦄如何定义一个委托类型" class="headerlink" title="🦄如何定义一个委托类型"></a>🦄如何定义一个委托类型</h1><ol>
<li>使用 delegate 关键字</li>
<li>指明待委托方法的两个特征: <code>1. 返回值 2. 参数</code></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义委托类型, 返回值为: int, 参数为: (int, int)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">MyDelegate</span> (<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>[<strong>注</strong>] 其实 csharp 中已经有定义好的通用委托类型了, 基本无需自己定义委托类型.</p>
<h1 id="🐬如何实例化出一个委托实例"><a href="#🐬如何实例化出一个委托实例" class="headerlink" title="🐬如何实例化出一个委托实例"></a>🐬如何实例化出一个委托实例</h1><p>实例化委托就是使用之前定义好的委托类型实例化出一个委托对象, 也叫做委托实例. 委托的实例化语法和类的实例化语法相同.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化一个 MyDelegate 类型的委托对象, 此时还没有初始化</span></span><br><span class="line">MyDelegate myDelegate;</span><br></pre></td></tr></table></figure>

<p>[<strong>注</strong>] 实例化委托时通常不再使用自己定义的委托类型, 而是使用 csharp 中已经定义好的通用委托类型 Action&lt;&gt; 和 Func&lt;&gt;.</p>
<h1 id="🌴如何初始化一个委托实例"><a href="#🌴如何初始化一个委托实例" class="headerlink" title="🌴如何初始化一个委托实例"></a>🌴如何初始化一个委托实例</h1><ul>
<li><p>方法 1: 使用 new 关键字初始化. 待委托方法作为参数传入.</p>
</li>
<li><p>方法 2: 直接使用符合特征的方法赋值.</p>
</li>
</ul>
<p>[<strong>注</strong>] 待委托方法如果不是静态方法, 则必须是实例方法. 不能将未实例化的方法作为参数传入委托或对委托赋值.</p>
<h1 id="如何调用委托"><a href="#如何调用委托" class="headerlink" title="如何调用委托"></a>如何调用委托</h1><ul>
<li>方式 1: 调用委托和调用方法在代码写法上一致.</li>
<li>方式 2: 调用 Invoke() 方法.</li>
</ul>
<h1 id="委托基本用法示例-非静态"><a href="#委托基本用法示例-非静态" class="headerlink" title="委托基本用法示例 (非静态)"></a>委托基本用法示例 (非静态)</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CSharp 起别名的语法规则, 在 namespace 外部书写时必须写全部路径</span></span><br><span class="line"><span class="comment">// using Package = System.Collections.Generic.Dictionary&lt;string, int&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyDelegateTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// CSharp 起别名的语法规则, 在 namespace 内部书写的时候可以嵌套引用 namespace 外的 using</span></span><br><span class="line">    <span class="keyword">using</span> Package = Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个委托类, 指明待委托方法的特征: 1. 返回值 (string) 2. 参数 (string, int, Package)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">string</span> <span class="title">DelegateBuy</span>(<span class="params"><span class="keyword">string</span> itemName, <span class="keyword">int</span> num, Package package</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// 实例化 玩家包裹</span></span><br><span class="line">            Package package = <span class="keyword">new</span> Package();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实例化 委托</span></span><br><span class="line">            <span class="comment">// 委托初始化时可以直接赋值, 也可以使用 new 关键字</span></span><br><span class="line">            <span class="comment">// 当 &quot;待委托方法&quot; 是非静态方法时, 只能传递待委托方法的实例作为参数, 因此这里必须实例化 Program, 并写 &quot;program.Buy&quot;, 不能只写 &quot;Buy&quot;.</span></span><br><span class="line">            Program program = <span class="keyword">new</span> Program();</span><br><span class="line">            DelegateBuy delegateBuy = program.Buy;</span><br><span class="line">            DelegateBuy delegateBuy2 = <span class="keyword">new</span> DelegateBuy(program.Buy);            </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用委托的写法和调用方法的写法一致</span></span><br><span class="line">            Console.WriteLine(delegateBuy(<span class="string">&quot;体力药水&quot;</span>, <span class="number">10</span>, package));</span><br><span class="line">            Console.WriteLine(delegateBuy(<span class="string">&quot;体力药水&quot;</span>, <span class="number">25</span>, package));</span><br><span class="line">            Console.WriteLine(delegateBuy2(<span class="string">&quot;魔力药水&quot;</span>, <span class="number">10</span>, package));</span><br><span class="line">            Console.WriteLine(delegateBuy2(<span class="string">&quot;魔力药水&quot;</span>, <span class="number">5</span>, package));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 待委托的方法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;itemName&quot;&gt;</span>物品名称<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;num&quot;&gt;</span>物品数量<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;package&quot;&gt;</span>玩家包裹<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Buy</span>(<span class="params"><span class="keyword">string</span> itemName, <span class="keyword">int</span> num, Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; package</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> str;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (package.ContainsKey(itemName))</span><br><span class="line">            &#123;</span><br><span class="line">                package[itemName] += num;</span><br><span class="line">                str = <span class="keyword">string</span>.Format(<span class="string">&quot;您又购买了&#123;0&#125;个&#123;1&#125;!&quot;</span>, num, itemName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                package.Add(itemName, num);</span><br><span class="line">                str = <span class="keyword">string</span>.Format(<span class="string">&quot;您购买了&#123;0&#125;个&#123;1&#125;!&quot;</span>, num, itemName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="委托基本用法示例-静态"><a href="#委托基本用法示例-静态" class="headerlink" title="委托基本用法示例 (静态)"></a>委托基本用法示例 (静态)</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CSharp 起别名的语法规则, 在 namespace 外部书写时必须写全部路径</span></span><br><span class="line"><span class="comment">// using Package = System.Collections.Generic.Dictionary&lt;string, int&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyDelegateTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// CSharp 起别名的语法规则, 在 namespace 内部书写的时候可以嵌套引用 namespace 外的 using</span></span><br><span class="line">    <span class="keyword">using</span> Package = Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个委托类, 指明待委托方法的特征: 1. 返回值 (string) 2. 参数 (string, int, Package)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">string</span> <span class="title">DelegateBuy</span>(<span class="params"><span class="keyword">string</span> itemName, <span class="keyword">int</span> num, Package package</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// 实例化 玩家包裹</span></span><br><span class="line">            Package package = <span class="keyword">new</span> Package();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实例化 委托</span></span><br><span class="line">            <span class="comment">// 当 &quot;待委托方法&quot; 是静态方法时, 可以直接将静态方法作为参数传递.</span></span><br><span class="line">            DelegateBuy delegateBuy = Program.Buy;</span><br><span class="line">            DelegateBuy delegateBuy2 = <span class="keyword">new</span> DelegateBuy(Program.Buy);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用委托的写法和调用方法的写法一致</span></span><br><span class="line">            Console.WriteLine(delegateBuy(<span class="string">&quot;体力药水&quot;</span>, <span class="number">10</span>, package));</span><br><span class="line">            Console.WriteLine(delegateBuy(<span class="string">&quot;体力药水&quot;</span>, <span class="number">25</span>, package));</span><br><span class="line">            Console.WriteLine(delegateBuy2(<span class="string">&quot;魔力药水&quot;</span>, <span class="number">10</span>, package));</span><br><span class="line">            Console.WriteLine(delegateBuy2(<span class="string">&quot;魔力药水&quot;</span>, <span class="number">5</span>, package));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 暂停</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 待委托的方法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;itemName&quot;&gt;</span>物品名称<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;num&quot;&gt;</span>物品数量<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;package&quot;&gt;</span>玩家包裹<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">Buy</span>(<span class="params"><span class="keyword">string</span> itemName, <span class="keyword">int</span> num, Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; package</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> str;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (package.ContainsKey(itemName))</span><br><span class="line">            &#123;</span><br><span class="line">                package[itemName] += num;</span><br><span class="line">                str = <span class="keyword">string</span>.Format(<span class="string">&quot;您又购买了&#123;0&#125;个&#123;1&#125;!&quot;</span>, num, itemName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                package.Add(itemName, num);</span><br><span class="line">                str = <span class="keyword">string</span>.Format(<span class="string">&quot;您购买了&#123;0&#125;个&#123;1&#125;!&quot;</span>, num, itemName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Action-和-Func"><a href="#Action-和-Func" class="headerlink" title="Action 和 Func"></a>Action 和 Func</h1><p>在实例化委托的时候, 不仅仅可以使用自己定义的委托, 还可以使用 csharp 中已经定义好的两个泛型委托: <strong><code>Action&lt;&gt;</code></strong> 和 <strong><code>Func&lt;&gt;</code></strong> 来实例化 (强烈建议使用).</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p><strong>Action&lt;&gt;</strong> 待委托的方法都是没有返回值的方法, 参数使用泛型进行指定.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Action a; <span class="comment">// 实例化出一个待委托方法特征为没有返回值, 没有参数的委托实例 a</span></span><br><span class="line">Action&lt;<span class="keyword">string</span>&gt; b; <span class="comment">// 实例化出一个待委托方法特征为没有返回值, 有一个 string 类型参数的委托实例 b</span></span><br><span class="line">Action&lt;<span class="keyword">string</span>, <span class="keyword">int</span>[]&gt; c; <span class="comment">// 实例化出一个待委托方法特征为没有返回值, 具有一个 string, 一个 int 数组参数的委托实例 c</span></span><br></pre></td></tr></table></figure>

<h2 id="Func"><a href="#Func" class="headerlink" title="Func"></a>Func</h2><p><strong>Func&lt;&gt;</strong> 待委托的方法都是具有返回值的方法. 使用泛型来指定参数和返回值. 其中泛型中的最后一个类型为返回值的类型.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="keyword">string</span>&gt; a; <span class="comment">// 实例化出一个待委托方法特征为没有参数, 返回值类型为 string 的委托实例 a</span></span><br><span class="line">Func&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; b; <span class="comment">// 实例化出一个待委托方法特征为有一个 string 类型的参数, 返回值为 int 类型的委托实例 b</span></span><br><span class="line">Func&lt;<span class="keyword">int</span>, <span class="keyword">string</span>, <span class="keyword">int</span>[]&gt; c; <span class="comment">// 实例化出一个待委托方法特征为有两个 类型分别为 int 和 string 类型的参数, 返回值为 int 数组类型的委托实例 c</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>delegate 和 Delegate 的区别: </p>
<p> Delegate 是类, delegate 是关键字.</p>
</li>
<li><p>定义委托</p>
<p> 不再自定义委托, 使用 Action&lt;&gt; 和 Func&lt;&gt;.</p>
</li>
<li><p>实例化委托</p>
<p> 使用泛型指明待委托方法的特征.</p>
</li>
<li><p>Action 和 Func</p>
<p> Action&lt;&gt; 指明无返回值, Func&lt;&gt; 最后一个泛型类型指明返回值.</p>
</li>
<li><p>委托的基本用法</p>
<p> 可以通过委托来调用方法.</p>
</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMzMxNTkw">理解委托类型<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>委托(二) 委托与 &quot;回调和回调函数&quot;</title>
    <url>/csharp/delegate_02.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="回调与回调函数"><a href="#回调与回调函数" class="headerlink" title="回调与回调函数"></a>回调与回调函数</h1><p>我也不太清楚为什么会出来一个 &quot;<font color='red'>回调函数</font>&quot; 的概念, 回调函数不就是一个参数吗? </p>
<blockquote>
<p>将方法 A 作为 方法 B 的一个参数传入到方法 B 中, 那么方法 A 就是方法 B 的回调函数.</p>
</blockquote>
<p>可以这样理解:</p>
<ol>
<li><p>&quot;回调&quot; 是一种技术: <font color='red'>将方法作为参数传入另一个方法!</font> 在各大编程语言, 脚本语言中都有实现这门技术! </p>
</li>
<li><p>&quot;回调函数&quot; 就是作为参数的方法!</p>
</li>
</ol>
<p>强调: <strong>回调是一项技术! 回调函数是一个参数!</strong></p>
<h1 id="quot-回调-quot-的用途"><a href="#quot-回调-quot-的用途" class="headerlink" title="&quot;回调&quot; 的用途"></a>&quot;回调&quot; 的用途</h1><ol>
<li><p>因为 A 是作为参数传入 B 的, 那么在 B 中就可以编写很多的判断逻辑来准确控制 A 的执行时机, 当然用 retuan 返回执行标志, 通过执行标志来控制 A 的执行也是可以的, 但是这样不是还得对执行标志进行一次判断吗? 当然这个没什么影响, 但是万一这个执行标志无法返回呢, 对吧?</p>
</li>
<li><p>如果 B 中需要处理很复杂的数据, 而且这个数据很难使用 return 返回, 甚至可能根本无法使用 return, 但是 A 又必须要用到这个数据, 此时就可以利用 &quot;回调&quot; 这项技术了, 将 A 传入 B, 在 B 的内部执行 A, 这样 A 就可以获取到需要的数据了.</p>
</li>
<li><p>假设方法 B 可以随机获得一种食材, 食材有多种多样烹饪方法, 可以红烧, 可以清蒸, 可以煎炸, 此时就可以给 B 添加一个 &quot;回调函数&quot; 参数, 这个参数就是烹饪方法 A, 那么在执行方法 B 获取食材的同时就可以将烹饪方法 A 一并传入, 这样一道菜就直接做好了! 而且只要传入不同的 A 就可以做出不同的菜, 甚至在 B 里面还可以写判断方法, 控制某些食材只能用某些特定的烹饪方法!</p>
</li>
</ol>
<p>总结: &quot;回调&quot; 可以做菜~! </p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>csharp 中由于方法无法作为参数进行传递, 所以想要在 csharp 中实现 &quot;回调&quot; 需要使用委托来实现, 下面是一个简单的示例.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">namespace_CallBackTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">CallBackTest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 随机器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">readonly</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CallBackTest callBackTest = <span class="keyword">new</span> CallBackTest();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取食材的同时将烹饪方法作为参数传入, 实现内部调用 -- 这就是 &quot;回调&quot; !</span></span><br><span class="line">            <span class="comment">// 含义为: 先获取食材, 之后使用参数内的烹饪方式对食材进行处理, 得到烹饪后的食物.</span></span><br><span class="line">            callBackTest.GetIngredients(callBackTest.Cook1);<span class="comment">//烧烤</span></span><br><span class="line">            callBackTest.GetIngredients(callBackTest.Cook1);<span class="comment">//烧烤</span></span><br><span class="line">            callBackTest.GetIngredients(callBackTest.Cook2);<span class="comment">//清蒸</span></span><br><span class="line">            callBackTest.GetIngredients(callBackTest.Cook1);<span class="comment">//烧烤</span></span><br><span class="line">            callBackTest.GetIngredients(callBackTest.Cook3);<span class="comment">//煎炸</span></span><br><span class="line">            callBackTest.GetIngredients(callBackTest.Cook1);<span class="comment">//烧烤</span></span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取食材</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cook&quot;&gt;</span>烹饪方法<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetIngredients</span>(<span class="params">Action&lt;<span class="keyword">string</span>&gt; cook</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> str_ingredient = <span class="keyword">string</span>.Empty;</span><br><span class="line">            <span class="keyword">int</span> int_ingredient = random.Next(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (int_ingredient &gt; <span class="number">75</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                str_ingredient = <span class="string">&quot;大棒肉(&quot;</span> + int_ingredient + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(int_ingredient &gt; <span class="number">25</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                str_ingredient = <span class="string">&quot;鲈鱼(&quot;</span> + int_ingredient + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (int_ingredient == <span class="number">25</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                str_ingredient = <span class="string">&quot;杂烩兔肉块(&quot;</span> + int_ingredient + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(str_ingredient))</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;白忙了一天, 没有获得任何食材(&quot;</span> + int_ingredient + <span class="string">&quot;) !&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cook(str_ingredient);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 烧烤</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;ingredient&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cook1</span>(<span class="params"><span class="keyword">string</span> ingredient</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;获得了 &lt;烧烤&quot;</span> + ingredient + <span class="string">&quot;&gt; !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 清蒸</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;ingredient&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cook2</span>(<span class="params"><span class="keyword">string</span> ingredient</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;获得了 &lt;清蒸&quot;</span> + ingredient + <span class="string">&quot;&gt; !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 煎炸</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;ingredient&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Cook3</span>(<span class="params"><span class="keyword">string</span> ingredient</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;获得了 &lt;炸&quot;</span> + ingredient + <span class="string">&quot;&gt; !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzE5ODAxMTMx">回调函数（callback）是什么？<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAwNDE0OTEzMQ==">js的回调函数一般都用来做什么<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>委托(三) 委托的初始化</title>
    <url>/csharp/delegate_03.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="初始化委托对象"><a href="#初始化委托对象" class="headerlink" title="初始化委托对象"></a>初始化委托对象</h1><p>先定义一个委托类型, 然后使用定义的委托类型实例化一个委托对象.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个委托类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">string</span> <span class="title">MyDelegate</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个 MyDelegate 类型的委托对象, 此时还没有初始化</span></span><br><span class="line">MyDelegate myDelegate;</span><br></pre></td></tr></table></figure>

<p><code>MyDelegate myDelegate</code> 只是实例化出了一个空的委托对象, 没有内容, 必须对其初始化. 委托的初始化方式经历了几种变化:</p>
<blockquote>
<p>C# 1.0 中, 使用 &quot;在代码中其他位置定义函数&quot; 的方法, <strong>显式</strong>初始化委托. </p>
<p>C# 2.0 引入了 <strong>匿名方法</strong> 的概念, 以一种可在委托调用中执行的 &quot;未命名内联语句块&quot; 的方式来初始化委托.</p>
<p>C# 3.0 引入了 <strong>Lambda 表达式</strong> 或者 <strong>Lambda 语句块</strong>, 这是另一种匿名方法的书写形式, 但更具表现力并且更简练. </p>
<p>通常, 面向 .NET Framework 3.5 或更高版本的应用程序应使用 Lambda (λ) 表达式或 Lambda 语句块来初始化委托.</p>
</blockquote>
<ol>
<li>第一种: [C# 1.0] 写法上和初始化类一样, 使用 New 关键字.</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 myDelegate 委托</span></span><br><span class="line">myDelegate = <span class="keyword">new</span> MyDelegate(program.Add);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>第二种: [C# 1.0] 写法上和初始化值类型一样, 直接赋值.</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 myDelegate (直接赋值)</span></span><br><span class="line">myDelegate = program.Add;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>第三种: [C# 2.0] 使用匿名方法的原始写法进行初始化</li>
</ol>
<p>匿名方法同样是使用 delegate 关键字定义 (强烈建议不再使用匿名方法, 了解即可, 转而使用 Lambda 表达式或 Lambda 语句块), 返回值无需特别指明, 只需使用 return 来指明返回值及其类型即可, 匿名方法参数的指明方式和普通方法的指明方式一致, 但是必须和委托定义时声明的方法签名吻合.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">myDelegate = <span class="keyword">delegate</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b).ToString();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>第四种: [C# 3.0] 使用匿名方法的简化写法--Lambda 表达式或 Lambda 语句块进行初始化 (强烈建议使用!)</li>
</ol>
<p>Lambda 表达式和 Lambda 语句块也是委托初始化的一种手段, 它比匿名方法更为简洁, 而且不会混淆 (谁让委托类型的定义和匿名方法的定义使用同样的关键字的, 唉... 乱套了吧... 我瞎说的~~), 总之正如微软文档说的一样, 学习使用 lambda 表达式吧, 为什么呢? 因为如果你不会的话, 连别人的程序都看不懂啊😥</p>
<h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><ol>
<li><p>Lambda 的特征符号是: <code>=&gt;</code>. =&gt; 符号的左边是参数, 使用小括号 ( ) 括起来, 右侧是语句或表达式, 当右侧是语句时, 必须使用大括号 { } 括起来, 当右侧是表达式时, 则不能带有大括号, 且表达式只能有一句.</p>
</li>
<li><p>Lambda 中右侧是语句时, 使用 return 语句来指明返回值及其类型, 返回值的类型必须符合委托的要求.</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; funA = (<span class="keyword">int</span> x, <span class="keyword">int</span> y) =&gt; &#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Lambda 中参数的类型可以注明, 如上面的例子, 也可以省略, 如下面的例子.</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; funB = (x, y) =&gt; &#123; <span class="keyword">return</span> x * y; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Lambda 中的参数, 当且仅当只有一个时, 小括号可以省略.</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; funC = x =&gt; &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;; <span class="comment">// 当且仅当只有一个时, 小括号可以省略.</span></span><br><span class="line"></span><br><span class="line">Func&lt;<span class="keyword">float</span>&gt; funD = () =&gt; &#123; <span class="keyword">return</span> <span class="number">3.1415926f</span>; &#125;; <span class="comment">// 零个参数时, 小括号不可以省略.</span></span><br><span class="line"></span><br><span class="line">Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; funE = (x, y, z) =&gt; &#123; <span class="keyword">return</span> x * <span class="number">2</span> + y * <span class="number">3</span> + z * <span class="number">4</span>; &#125;; <span class="comment">// 两个及以上参数时, 小括号不可以省略.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Lambda 中右侧是表达式时, 大括号必须去掉, 并且此时 <font color='red'><strong>return 也必须省略</strong></font>, 因为 return 是语句, 不是表达式.</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; funF = (x, y) =&gt; x * y; <span class="comment">// 大括号和 return 必须同时存在, 或同时去掉.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>大括号存在时, 大括号中只能写 <font color='red'><strong>语句</strong></font>. 此时称为: <strong>Lambda 语句块</strong>. 或者说当书写语句时, 必须用 <font color='red'><strong>语句块符号 { }</strong></font> 括起来.</p>
</li>
<li><p>大括号不存在时, 则只能写 <font color='red'><strong>表达式</strong></font>, 并且 <font color='red'><strong>表达式只能写一句</strong></font> . 此时称为: <strong>Lambda 表达式</strong>.</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">myDelegate = (a, b) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b).ToString();</span><br><span class="line">&#125;; <span class="comment">// Lambda 语句块</span></span><br><span class="line"></span><br><span class="line">Action action = () =&gt; Console.WriteLine(<span class="string">&quot;action&quot;</span>); <span class="comment">// Lambda 表达式</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h1><p>前面讲了委托的四种初始化方式全部都是使用了 <strong><code>=</code></strong> 运算符, 其实委托还可以通过 <strong><code>+= -=</code></strong> 运算符进行注册和取消注册, 而且可以实现多播委托.</p>
<ul>
<li><p>多播委托: <font color='red'><strong>一个委托实例一次性委托多个实例方法, 调用委托时会依次调用所有被委托的方法</strong></font>.</p>
</li>
<li><p><font color='red'><strong>委托不仅仅可以 (取消) 注册方法, 也可以 (取消) 注册委托</strong></font>!</p>
</li>
</ul>
<p>下表是 <strong><code>+</code></strong> 和 <strong><code>-</code></strong> 的运算规则:</p>
<table>
<thead>
<tr>
<th align="left">Expression</th>
<th align="left">Result</th>
</tr>
</thead>
<tbody><tr>
<td align="left">null + d1</td>
<td align="left">d1</td>
</tr>
<tr>
<td align="left">d1 + null</td>
<td align="left">d1</td>
</tr>
<tr>
<td align="left">d1 + d2</td>
<td align="left">[d1, d2]</td>
</tr>
<tr>
<td align="left">d1 + [d2, d3]</td>
<td align="left">[d1, d2, d3]</td>
</tr>
<tr>
<td align="left">[d1, d2] + [d2, d3]</td>
<td align="left">[d1, d2, d2, d3]</td>
</tr>
<tr>
<td align="left">[d1, d2] - d1</td>
<td align="left">d2</td>
</tr>
<tr>
<td align="left">[d1, d2] - d2</td>
<td align="left">d1</td>
</tr>
<tr>
<td align="left">[d1, d2, d1] - d1</td>
<td align="left">[d1, d2]</td>
</tr>
<tr>
<td align="left">[d1, d2, d3] - [d1, d2]</td>
<td align="left">d3</td>
</tr>
<tr>
<td align="left">[d1, d2, d3] - [d2, d1]</td>
<td align="left">[d1, d2, d3]</td>
</tr>
<tr>
<td align="left">[d1, d2, d3, d1, d2] - [d1, d2]</td>
<td align="left">[d1, d2, d3]</td>
</tr>
<tr>
<td align="left">[d1, d2] - [d1, d2]</td>
<td align="left">null</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>委托(四) &quot;委托与事件的区别&quot; 以及 &quot;观察者模式&quot;</title>
    <url>/csharp/delegate_04.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="🌴前言"><a href="#🌴前言" class="headerlink" title="🌴前言"></a>🌴前言</h1><p>最开始知道委托和事件是在 SiKi 的 C# 课程上(很抱歉, 大学就只上了 C 语言课, Java 课听了一节...😅), 由于之前没有接触过类似的语法, 又或是学习单片机的时候 C 语言语法在脑海中根深蒂固了 , 听课时就像是在听天书, 再加上之后也没有使用过这方面的语法, 基本全忘记了. 之前一段时间简单的了解了一下委托和事件, 然后网上都是用 &quot;观察者模式&quot; 去讲的...然而文章中连观察者都没有仔细去讲...所以这样更晕了好嘛...😑 于是自己抽时间多看了几篇文章, 做一下总结. 先说一下观察者模式吧, 毕竟委托和事件的区别用观察者去讲真的十分合适!</p>
<h1 id="🍁声明"><a href="#🍁声明" class="headerlink" title="🍁声明"></a>🍁声明</h1><p>阅读下文需要对 &quot;委托&quot; 有基本了解, 如果未达到此基本要求, 请先打怪升级, 达到要求后再来挑战本副本! 推荐练级副本: </p>
<ol>
<li><p><a href="https://kuroha.vip/csharp/delegate_01.html">委托(一) 委托的基本用法</a></p>
</li>
<li><p><a href="https://kuroha.vip/csharp/delegate_02.html">委托(二) 委托与回调和回调函数</a></p>
</li>
<li><p><a href="https://kuroha.vip/csharp/delegate_03.html">委托(三) 委托的初始化</a></p>
</li>
</ol>
<h1 id="👀观察者模式"><a href="#👀观察者模式" class="headerlink" title="👀观察者模式"></a>👀观察者模式</h1><h2 id="quot-模式-quot-是什么"><a href="#quot-模式-quot-是什么" class="headerlink" title="&quot;模式&quot; 是什么?"></a>&quot;模式&quot; 是什么?</h2><ul>
<li>&quot;模式&quot; 这个东西和之前所学的大部分东西都不是一回事, &quot;模式&quot; 是一种套路, 对, 你没有听错, 套路, 或者说模板! 它是走在我们前面的那些码神们常年编写代码所总结出来的一种在特定场合下特别好用的代码模板. 就像是英语作文模板指导我们以怎样的结构去写英语作文一样, &quot;模式&quot; 是指导我们以一种怎样的结构去编写代码, 以达到减小编程时工作量以及减小日后维护成本的效果.</li>
</ul>
<h2 id="观察者模式的内容是什么"><a href="#观察者模式的内容是什么" class="headerlink" title="观察者模式的内容是什么?"></a>观察者模式的内容是什么?</h2><ol>
<li><p>需要描述的是一种 &quot;一对多&quot; 的依赖关系!</p>
</li>
<li><p>当 &quot;一&quot; 的一方状态发生改变时, &quot;多&quot; 的一方中的全部成员都能够收到通知!</p>
</li>
<li><p>&quot;多&quot; 的一方收到通知后, 全部的成员都会自动进行更新操作, 而非被动!</p>
</li>
</ol>
<p>这就是 &quot;观察者模式&quot; 了, &quot;一&quot; 的一方叫做 &quot;被观察者&quot;, &quot;多&quot; 的一方叫做 &quot;观察者&quot;, 也叫做: &quot;发布-订阅模型&quot;, 这时分别叫做 &quot;发布器&quot; 和 &quot;订阅器&quot;.</p>
<ul>
<li>Q: 为什么没有代码?</li>
<li>A: 因为模式只是一种套路, 一种模板, 一种思想, 自然是没有代码的! 只要代码是按照这个模板去编写的, 就可以说使用了 &quot;观察者模式&quot;.</li>
</ul>
<h2 id="观察者模式的代码实现"><a href="#观察者模式的代码实现" class="headerlink" title="观察者模式的代码实现"></a>观察者模式的代码实现</h2><p>接下来就是代码实现环节了, 一共写了 3 种 <strong><code>链表, 委托, 事件</code></strong> 代码实现, 都是使用的 csharp 语言.</p>
<p>Q: 需要记忆的代码是哪个呢?</p>
<p>A: 没有! 对, 就是没有! 真正要记忆的是前面 <strong>观察者模式的内容是什么</strong> 中所提到的 3 点. 看完代码后可不要本末倒置了哦!</p>
<p>下面代码实现的场景就是当被观察者使用 &quot;发令枪&quot; 开枪时, 观察者们全部开跑~</p>
<h3 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Exercise</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 被观察者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher_List</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 保存所有的观察者对象</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="title">List</span>&lt;<span class="title">Subscriber_List</span>&gt; subscriberList</span> = <span class="keyword">new</span> List&lt;Subscriber_List&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进入赛道</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnterGame</span>(<span class="params">Subscriber_List subscriber</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            subscriberList.Add(subscriber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发令枪</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartingGun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;预备~ . . . 砰! \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历所有的观察者 (这一步就是在通知每一个观察者)</span></span><br><span class="line">            <span class="keyword">foreach</span> (Subscriber_List t <span class="keyword">in</span> subscriberList)</span><br><span class="line">            &#123;</span><br><span class="line">                t.Run(); <span class="comment">// 自动更新</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 观察者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber_List</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 运动员姓名</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Subscriber_List</span>(<span class="params">Publisher_List publisher, <span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            publisher.EnterGame(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开跑</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(name + <span class="string">&quot; 开跑啦~ \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program_List</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Publisher_List publisherList = <span class="keyword">new</span> Publisher_List();</span><br><span class="line">            <span class="keyword">new</span> Subscriber_List(publisherList, <span class="string">&quot;艾莉&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> Subscriber_List(publisherList, <span class="string">&quot;克里斯&quot;</span>);</span><br><span class="line"></span><br><span class="line">            publisherList.StartingGun();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序输出:</span></span><br><span class="line">预备~ . . . 砰!</span><br><span class="line"></span><br><span class="line">艾莉 开跑啦~</span><br><span class="line"></span><br><span class="line">克里斯 开跑啦~</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面就是一个最简单的观察者模式, 使用链表实现.</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">实现方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1. 一对多</td>
<td align="left">被观察者只有一个实例, 使用链表保存所有的观察者实例</td>
</tr>
<tr>
<td align="left">2. 全部通知</td>
<td align="left">在方法中遍历所有的观察者, 每一个都进行特定的操作</td>
</tr>
<tr>
<td align="left">3. 自动更新</td>
<td align="left">在 &quot;被观察者&quot; 中调用 &quot;观察者&quot; 的方法, 对外界隐藏调用逻辑</td>
</tr>
</tbody></table>
<p>再来看一下 Main 方法:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Publisher_List publisherList = <span class="keyword">new</span> Publisher_List();</span><br><span class="line">    <span class="keyword">new</span> Subscriber_List(publisherList, <span class="string">&quot;艾莉&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Subscriber_List(publisherList, <span class="string">&quot;克里斯&quot;</span>);</span><br><span class="line"></span><br><span class="line">    publisherList.StartingGun();</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时对外界的 Main 方法而言, 我仅仅开了一下 &quot;发令枪&quot;, 艾莉和克里斯中的 Run 方法就 <font color='red'><strong>自动</strong></font> 被调用了. 如果不这么写, Main 方法就必须先调用发令枪方法, 然后再调用艾莉和克里斯的 Run 方法.</p>
<h3 id="委托实现"><a href="#委托实现" class="headerlink" title="委托实现"></a>委托实现</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Exercise</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Publisher publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line">            <span class="keyword">new</span> Subscriber(publisher, <span class="string">&quot;艾莉&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> Subscriber(publisher, <span class="string">&quot;克里斯&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发令枪</span></span><br><span class="line">            publisher.StartingGun();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 被观察者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 委托, 保存所有的观察者</span></span><br><span class="line">        <span class="keyword">public</span> Action PublisherDelegate;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发令枪</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartingGun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;预备~ . . . 砰! \n&quot;</span>);</span><br><span class="line">            PublisherDelegate?.Invoke(); <span class="comment">// 判断 PublisherDelegate 是否是空, 如果不是空, 则调用里面的 Invoke 方法.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 观察者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 运动员姓名</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> name;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 构造器</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;publisher&quot;&gt;</span>发布器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>订阅器名称<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Subscriber</span>(<span class="params">Publisher publisher, <span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            publisher.PublisherDelegate += Run; <span class="comment">// 自动注册</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开跑</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(name + <span class="string">&quot; 开跑啦~ \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序输出:</span></span><br><span class="line">预备~ . . . 砰!</span><br><span class="line"></span><br><span class="line">艾莉 开跑啦~</span><br><span class="line"></span><br><span class="line">克里斯 开跑啦~</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用委托实现观察者模式与使用链表时的不同"><a href="#使用委托实现观察者模式与使用链表时的不同" class="headerlink" title="使用委托实现观察者模式与使用链表时的不同"></a>使用委托实现观察者模式与使用链表时的不同</h4><ol>
<li><p>不再使用链表保存所有的观察者, 而是使用委托的多播特性进行保存.</p>
</li>
<li><p>通知所有观察者的步骤不再使用遍历, 而是使用委托的多播特性进行逐个通知.</p>
</li>
<li><p>注册观察者时不再使用链表的 Add() 方法, 而是使用委托的 <strong>+=</strong> 和 <strong>-=</strong>.</p>
</li>
</ol>
<p>直接使用委托实现观察者模式有几个不安要素:</p>
<ol>
<li><p>如果被观察者 Publisher 中的委托是 public 修饰, 那么外部便可以直接访问, 此时如果外部代码中使用了 <strong>=</strong> 进行委托的注册, 那么委托中已有的注册将被全部清空, 这种隐患是十分恐怖的.</p>
</li>
<li><p>如果被观察者 Publisher 中的委托是 public 修饰, 那么外部便可以直接调用此委托, 此时观察者们便无法收到任何通知, 这个隐患同样是致命的.</p>
</li>
</ol>
<p>使用事件实现观察者模式便解决了上面两个致命隐患.</p>
<h3 id="事件实现"><a href="#事件实现" class="headerlink" title="事件实现"></a>事件实现</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Exercise</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Publisher publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line">            Subscriber subscriberA = <span class="keyword">new</span> Subscriber(publisher, <span class="string">&quot;艾莉&quot;</span>);</span><br><span class="line">            Subscriber subscriberB = <span class="keyword">new</span> Subscriber(publisher, <span class="string">&quot;克里斯&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发令枪</span></span><br><span class="line">            publisher.StartingGun();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对事件直接赋值 (不允许)</span></span><br><span class="line">            publisher.PublisherEvent = subscriberA.Run;</span><br><span class="line">            <span class="comment">// 对委托直接赋值 (允许)</span></span><br><span class="line">            publisher.PublisherDelegate = subscriberA.Run;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 外部直接调用事件 (不允许)</span></span><br><span class="line">            publisher.PublisherEvent();</span><br><span class="line">            <span class="comment">// 外部直接调用委托 (允许)</span></span><br><span class="line">            publisher.PublisherDelegate();</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 被观察者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 事件, 保存所有的观察者</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> Action PublisherEvent;</span><br><span class="line">        <span class="keyword">public</span> Action PublisherDelegate;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发令枪</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartingGun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;预备~ . . . 砰! \n&quot;</span>);</span><br><span class="line">            PublisherEvent?.Invoke(); <span class="comment">// 判断 PublisherEvent 是否是空, 如果不是空, 则调用里面的 Invoke 方法.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 观察者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 运动员姓名</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> name;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 构造器</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;publisher&quot;&gt;</span>发布器<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>订阅器名称<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Subscriber</span>(<span class="params">Publisher publisher, <span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            publisher.PublisherEvent += Run; <span class="comment">// 自动注册</span></span><br><span class="line">            publisher.PublisherEvent = Run;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开跑</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(name + <span class="string">&quot; 开跑啦~ \n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码直接粘贴到 VS 中其实是报错的, 其中第 18 行, 第 23 行以及第 65 行会报错! 报错信息是一样的:</p>
<p><code>CS0070  事件 &quot;Publisher.PublisherEvent&quot; 只能出现在 += 或 -= 的左边(从类型 &quot;Publisher&quot; 中使用时除外)</code></p>
<p>从这里也就可以得出结论, 委托和事件的不同.</p>
<h1 id="🍀委托和事件的异同"><a href="#🍀委托和事件的异同" class="headerlink" title="🍀委托和事件的异同"></a>🍀委托和事件的异同</h1><ol>
<li><p>一个使用 public 修饰的委托实例, 在声明类的外部可以直接调用. 而事件即使修饰为 public, 也仅能在声明类内部调用, 外部调用时编译器会直接报错, 发现隐患.</p>
</li>
<li><p>委托可以使用 = 进行赋值, 但是事件不可以, 无论任何时候, 事件都仅能使用 += 和 -= 进行注册, 使用 = 时编译器会直接报错, 发现隐患.</p>
</li>
<li><p>除此以外, 委托和事件一致.</p>
</li>
</ol>
<h1 id="🌈参考链接"><a href="#🌈参考链接" class="headerlink" title="🌈参考链接"></a>🌈参考链接</h1><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9kZXNpZ24tcGF0dGVybi9vYnNlcnZlci1wYXR0ZXJuLmh0bWw=">菜鸟教程 - 观察者模式<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9kZXNpZ24tcGF0dGVybnMucmVhZHRoZWRvY3MuaW8vemhfQ04vbGF0ZXN0L2JlaGF2aW9yYWxfcGF0dGVybnMvb2JzZXJ2ZXIuaHRtbA==">Graphic Design Patterns - 观察者模式<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20va2tsbGRvZy9hcmNoaXZlLzIwMTIvMDEvMTcvMjMyNDIyOC5odG1s">C# 委托与事件区别简单总结<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>存储类型和传递方式</title>
    <url>/csharp/parameter.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="变量的存储类型"><a href="#变量的存储类型" class="headerlink" title="变量的存储类型"></a>变量的存储类型</h1><p>csharp 中的存储类型有两种, &quot;值存储&quot; 和 &quot;引用存储&quot;.</p>
<ol>
<li><p>引用存储类型是指在堆中存储变量的实际内容, 在栈中存储指向堆中实际内容的指针. 引用储存类型由这两部分组成.</p>
</li>
<li><p>值存储类型则是直接存储变量的实际内容, 不保存指向其的指针, 具体存储位置根据值类型的创建位置而定: 如果值类型是在一个方法中创建的, 那么它将跟随方法被压入栈内存中, 如果值类型是在一个引用类型内部创建的, 那么它将跟随这个引用类型存储在堆内存中.</p>
</li>
</ol>
<h1 id="参数的传递方式"><a href="#参数的传递方式" class="headerlink" title="参数的传递方式"></a>参数的传递方式</h1><p>csharp 中的传递方式有两种, &quot;值传递&quot; 和 &quot;引用传递&quot;.</p>
<ol>
<li><p>引用传递就是指将变量本身直接作为参数传递到方法内部. 比如你买了一支冰激凌, 朋友是只馋猫, 于是你直接把冰激凌送给了她, 她吃完后, 你也就没有冰激凌了...</p>
</li>
<li><p>值传递就是指将变量复制一份, 然后将复制出来的副本传递到方法内部. 就像朋友也想吃的时候, 你去便利店又买了一支一模一样的冰激凌送给了她, 她吃完后, 你的冰激凌还是在自己手中的...自己的是自己的, 她的是她的.</p>
</li>
</ol>
<p><strong>在默认情况下, CLR方法中传递参数的方式都是<font color='red'>值传递</font>! 即使变量采用的是引用存储.</strong></p>
<h1 id="四种-quot-存储-传递-quot"><a href="#四种-quot-存储-传递-quot" class="headerlink" title="四种 &quot;存储--传递&quot;"></a>四种 &quot;存储--传递&quot;</h1><p>2 种存储类型在 2 种传递方式下就会诞生 4 种情况:</p>
<h2 id="值存储-值传递"><a href="#值存储-值传递" class="headerlink" title="值存储--值传递"></a>值存储--值传递</h2><p>将一个值存储变量按照默认的传递方式传递就构成了 &quot;值存储--值传递&quot; 的情况.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> param1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> param2 = <span class="number">2</span>;</span><br><span class="line">        program.Edit(param1, param2);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;param1=&#123;0&#125;, param2=&#123;1&#125;&quot;</span>, param1, param2);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Edit</span>(<span class="params"><span class="keyword">int</span> param1, <span class="keyword">int</span> param2</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        param1 = <span class="number">3</span>;</span><br><span class="line">        param2 = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中, 最终输出的还是:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">param1=<span class="number">1</span>, param2=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="引用存储-值传递"><a href="#引用存储-值传递" class="headerlink" title="引用存储--值传递"></a>引用存储--值传递</h2><p>将一个引用存储的变量使用默认的传递方式传递就构成了 &quot;引用存储--值传递&quot; 的情况.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> str = <span class="string">&quot;我是测试字符串!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        program.Edit(str);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;str=&#123;0&#125;&quot;</span>, str);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Edit</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        str = <span class="string">&quot;我被修改了!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中, 最终输出的还是:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">str=我是测试字符串!</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line"></span><br><span class="line">        Car car = <span class="keyword">new</span> Car(<span class="number">1000</span>, <span class="string">&quot;价值一千元的车&quot;</span>);</span><br><span class="line"></span><br><span class="line">        program.Edit(car);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;price=&#123;0&#125;, name=&#123;1&#125;&quot;</span>, car.price, car.name);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Edit</span>(<span class="params">Car param</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        param = <span class="keyword">new</span> Car(<span class="number">10000</span>, <span class="string">&quot;价值一万元的车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="keyword">int</span> param1, <span class="keyword">string</span> param2</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        price = param1;</span><br><span class="line">        name = param2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中, 最终输出的还是:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">price=<span class="number">1000</span>, name=价值一千元的车</span><br></pre></td></tr></table></figure>

<p>第一个例子中 param1 的值是 1, param2 的值是 2, 即使使用了 Edit() 方法进行修改, 这两个变量的值依旧没有变化; 第二个例子中, str 的值也没有发生改变; 第三个例子中, car 指向的是 &quot;价值为一千元的车&quot;, 之后使用了 Edit() 方法进行了修改, 但是 car 指向的还是那辆 &quot;价值为一千元的车&quot;, 对一万元的车视而不见! 由此可见, 值传递之后, 方法中修改的只是变量的副本, 并不会对原变量的值造成任何影响. </p>
<p>[<strong>注</strong>] 第二个例子中的 <strong>car 变量的值</strong>和 car 所指向的 <strong>price 变量的值, name 变量的值</strong>完全是两码事!</p>
<h2 id="值存储-引用传递"><a href="#值存储-引用传递" class="headerlink" title="值存储--引用传递"></a>值存储--引用传递</h2><p>之前提到过, <strong>在默认情况下, CLR方法中传递参数的方式都是<font color='red'>值传递</font>! 即使变量采用的是引用存储!</strong> csharp 既然提供了引用传递方式, 自然有其实现方式. <code>ref, in, out</code> 这三个修饰符就是用于修饰参数的, 3 个修饰符的差异先放一边, 只要知道被它们修饰后的参数将使用 &quot;引用传递&quot; 的方式进行传递就可以了.</p>
<p>当值存储的变量作为参数传递时, 被 <code>ref, out, in</code> 修饰符修饰, 会使用引用传递方式进行传递, 就构成了 &quot;值存储--引用传递&quot; 的情况.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> param1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> param2 = <span class="number">2</span>;</span><br><span class="line">        program.Edit(<span class="keyword">ref</span> param1, <span class="keyword">ref</span> param2);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;param1=&#123;0&#125;, param2=&#123;1&#125;&quot;</span>, param1, param2);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Edit</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">int</span> param1, <span class="keyword">ref</span> <span class="keyword">int</span> param2</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        param1 = <span class="number">3</span>;</span><br><span class="line">        param2 = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中, 最终输出的值就变成了:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">param1=<span class="number">3</span>, param2=<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="引用存储-引用传递"><a href="#引用存储-引用传递" class="headerlink" title="引用存储--引用传递"></a>引用存储--引用传递</h2><p>当引用存储的变量作为参数传递时, 被 <code>ref, out, in</code> 修饰符修饰, 也会使用引用传递方式进行传递, 就构成了 &quot;引用存储--引用传递&quot; 的情况.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> str = <span class="string">&quot;我是测试字符串!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        program.Edit(<span class="keyword">ref</span> str);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;str=&#123;0&#125;&quot;</span>, str);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Edit</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        str = <span class="string">&quot;我被修改了!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中, 最终输出的值就变成了:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">str=我被修改了!</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line"></span><br><span class="line">        Car car = <span class="keyword">new</span> Car(<span class="number">1000</span>, <span class="string">&quot;价值一千元的车&quot;</span>);</span><br><span class="line"></span><br><span class="line">        program.Edit(<span class="keyword">ref</span> car);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;price=&#123;0&#125;, name=&#123;1&#125;&quot;</span>, car.price, car.name);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Edit</span>(<span class="params"><span class="keyword">ref</span> Car param</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        param = <span class="keyword">new</span> Car(<span class="number">10000</span>, <span class="string">&quot;价值一万元的车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="keyword">int</span> param1, <span class="keyword">string</span> param2</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        price = param1;</span><br><span class="line">        name = param2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中, 最终输出的值就变成了:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">price=<span class="number">10000</span>, name=价值一万元的车</span><br></pre></td></tr></table></figure>

<p>第一个例子中 param1 的值是 1, param2 的值是 2, 使用了 Edit() 方法修改后, 这两个变量的值就变成了 3 和 4; 第二个例子中, str 的值也被修改为了 &quot;我被修改了!&quot;; 第三个例子中, car 原本指向的是 &quot;价值为一千元的车&quot;, 之后使用了 Edit() 方法进行了修改, car 便指向了 &quot;价值为一万元的车&quot; ! 由此可见, 引用传递之后, 方法中修改的就是原变量的值. </p>
<h1 id="ref-out-in"><a href="#ref-out-in" class="headerlink" title="ref, out, in"></a>ref, out, in</h1><p>这三个关键字都可以实现引用传递, 并且引用传递时, ref 和 out 还要求不仅需要在方法签名中声明参数为哪种引用传递, 在调用方法的时候也<strong>必须添加对应的修饰符</strong>, 从上面引用传递的举例中也可以看出, 在调用方法时, 参数中也必须注明 ref 和 out, 但是这三者有什么区别呢?</p>
<h2 id="什么时候用-ref"><a href="#什么时候用-ref" class="headerlink" title="什么时候用 ref ?"></a>什么时候用 ref ?</h2><p>当你的目的是使用方法处理变量的值的时候, 就可以使用 ref 修饰符了. 因此 ref 有一个这样的语法规则:</p>
<ul>
<li>ref 修饰的参数在传递前必须已经初始化了.</li>
</ul>
<p>很明显, 这条规则进一步强调了 ref 的运用场景是: 我已经有一吨苹果了, 我现在需要将苹果送入造酒工厂, 让造酒工厂帮我处理这么多苹果! 所以前提是我们必须得先有苹果啊! 😅</p>
<h2 id="什么时候用-out"><a href="#什么时候用-out" class="headerlink" title="什么时候用 out ?"></a>什么时候用 out ?</h2><p>当你的目的是使用方法造出一个东西的时候, 就可以使用 out 修饰符了. 因此 out 修饰符就没有必须先初始化的限制. 这也是其使用场景决定的: 比如现在造酒工厂已经把苹果酒制作好了, 那么我只需要将酒带回家就可以了, 并不需要提前准备什么.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line"></span><br><span class="line">        program.Cook(<span class="keyword">out</span> <span class="keyword">string</span> food);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;food=&#123;0&#125;&quot;</span>, food);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Cook</span>(<span class="params"><span class="keyword">out</span> <span class="keyword">string</span> food</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        food = <span class="string">&quot;早餐&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上面的例子, Cook() 方法中的 food 变量并没有初始化, 依旧可以正常输出:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">food=早餐</span><br></pre></td></tr></table></figure>

<h2 id="in-修饰符又有什么用呢"><a href="#in-修饰符又有什么用呢" class="headerlink" title="in 修饰符又有什么用呢?"></a>in 修饰符又有什么用呢?</h2><p>由上面可以就看出, ref 和 out 已经可以涵盖所有的情况了, 为什么还有一个 in 呢? in 自然也是有它的应用场景的.</p>
<p>某一天你买了一幅名画, 十分贵重, 几乎花光了你至今为止所有的积蓄, 但是你的好朋友也想要看一下, 提出想要拿到自己家中好好观摩两天. 此时你心想, 使用 &quot;值传递&quot; 的方式吧, 就得复制一副相同的画, 虽然朋友也说了就算是复制品也可以, 但是请人再去临摹一份一模一样的, 这个开销太大了(对应程序中传递一个体积很大很大的值存储变量, 比如结构体变量, 复制一份的话, 内存占用就很高), 于是你还是决定直接将原画借给朋友看, 也就是 &quot;ref 引用传递&quot;, 但是心里始终是不放心啊, 万一朋友不小心把画作弄脏了, 弄丢了, 那自己这一辈子岂不凉凉了~</p>
<p>于是在这个场景下就可以使用修饰符 <em>in</em> 了, 使用 in 修饰的引用传递, 在方法中只能使用参数值, 无法修改参数值. 这样就不用担心画作的安全问题了.</p>
<p><img data-src="/images/csharp/parameter/parameter_01.png" alt="in 的作用"></p>
<p>[<strong>注</strong>] ref 和 out 参数在方法调用时必须显式注明 ref 和 out, 否则编译器直接报错! 但是从上图中可以看出, 我在调用 Friend 方法的时候并没有显式注明 in, 也就是说 in 并没有这个要求, 但是还是建议养成注明引用传递的习惯!</p>
<p>由此可见, 在程序中, in 关键字主要用于程序优化, 节省内存. 当然这里说的 in 只是参数修饰符 in, 自然不包括在 foreach 中的 in 啦~</p>
<h1 id="params"><a href="#params" class="headerlink" title="params"></a>params</h1><p>使用 params 关键字可以指定采用数目可变的参数的方法参数, 因此当方法需要的参数个数无法确定的时候, 就可以使用 params 关键字. </p>
<p>params 使用时具有诸多语法限制:</p>
<ol>
<li><p>params 修饰的参数类型必须是<font color='red'><strong>一维数组</strong></font>. 如果 params 修饰的不是一维数组, 直接发生编译错误;</p>
</li>
<li><p>在方法声明中 params 关键字修饰的参数之后不允许有任何其他参数;</p>
</li>
<li><p>在方法声明中只允许有一个 params 关键字.</p>
</li>
</ol>
<p>调用具有 params 修饰参数的方法时，可以传入:</p>
<ol>
<li><p>一维数组元素类型的逗号分隔列表;</p>
</li>
<li><p>指定类型的一维数组;</p>
</li>
<li><p>无参数. 如果未发送任何参数, 则 params 列表长度为零.</p>
</li>
</ol>
<p>[<strong>注</strong>] </p>
<ol>
<li><p>params 修饰的参数类型必须是一维数组, 但是这里的 &quot;一维数组&quot; 指代的并不仅仅是这种简单的一维数组 <code>int[]</code>, 任何类型的一维数组都可以, 包括交错数组: <code>int[][]</code>.</p>
</li>
<li><p>在方法声明中的 params 关键字之后不允许有任何其他参数, 就意味着 params 修饰的参数必须放在参数列表的最后一个, 同时也意味着只允许有一个 params 修饰的参数.</p>
</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">string</span>&gt; appleList = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">        appleList.Add(<span class="string">&quot;富士苹果&quot;</span>);</span><br><span class="line">        appleList.Add(<span class="string">&quot;红龙苹果&quot;</span>);</span><br><span class="line">        appleList.Add(<span class="string">&quot;香蕉苹果&quot;</span>);</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        appleList.Add(<span class="string">&quot;蜜脆苹果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span>[] apples = appleList.ToArray();</span><br><span class="line"></span><br><span class="line">        program.Factory();</span><br><span class="line">        program.Factory(<span class="string">&quot;富士苹果&quot;</span>, <span class="string">&quot;红龙苹果&quot;</span>);</span><br><span class="line">        program.Factory(<span class="string">&quot;富士苹果&quot;</span>, <span class="string">&quot;红龙苹果&quot;</span>, <span class="string">&quot;香蕉苹果&quot;</span>, <span class="string">&quot;蜜脆苹果&quot;</span>);</span><br><span class="line">        program.Factory(apples);</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Factory</span>(<span class="params"><span class="keyword">params</span> <span class="keyword">string</span>[] apples</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> str_log = <span class="keyword">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (apples.Length &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">string</span> apple <span class="keyword">in</span> apples)</span><br><span class="line">            &#123;</span><br><span class="line">                str_log += apple + <span class="string">&quot;酒! &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            str_log = <span class="string">&quot;请提供原材料!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(str_log);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子输出的结果就是:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">请提供原材料!</span><br><span class="line">富士苹果酒! 红龙苹果酒!</span><br><span class="line">富士苹果酒! 红龙苹果酒! 香蕉苹果酒! 蜜脆苹果酒!</span><br><span class="line">富士苹果酒! 红龙苹果酒! 香蕉苹果酒! 蜜脆苹果酒!</span><br></pre></td></tr></table></figure>

<p>可以看出调用方法时, 传递不定个数的参数以及一维数组都是可以的! </p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vemgtY24vZG90bmV0L2NzaGFycC9sYW5ndWFnZS1yZWZlcmVuY2Uva2V5d29yZHMvcmVmI3Bhc3NpbmctYW4tYXJndW1lbnQtYnktcmVmZXJlbmNl">Microsoft Docs ref<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vemgtY24vZG90bmV0L2NzaGFycC9sYW5ndWFnZS1yZWZlcmVuY2Uva2V5d29yZHMvcGFyYW1z">Microsoft Docs params<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>日记系列--2020年01月</title>
    <url>/diary/2020_01.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我发现我有极强的分享欲(话说回来, &quot;分享欲&quot; は何ですが❓🤣), 一旦遇到了自己感觉有趣的事情, 感动自己的事情, 让自己心烦意乱的事情, 甚至是可能很无聊的事情, 都一定要分享给自己身边的朋友们! 因此朋友们饱受任性的我的折磨, 我自己也发现了, 于是我也赶紧改变方式, 用写日记的方式分享心中所想, 分享给网络世界的自己(Kuroha)! 既满足了我的分享欲, 又可以不给任何人带去烦恼, 哈哈, 我真 TM 是个天才!👍</p>
<h1 id="2020年01月13日"><a href="#2020年01月13日" class="headerlink" title="2020年01月13日"></a>2020年01月13日</h1><p>今天是 2020 年的第 3 周周一, 一年 52 个周, 这么快就是第三个周了, 自己工作期间认识的第一位朋友去河北石家庄出差去了, 自己一个人好无聊, 公司里面没有一个能说得上话的人...😅 没错, 就是这么惨!(其实主要是我困呐, 眼皮好几吨重, 头也跟坐船上似的, 头晕头痛, 整个人跟死了似的) 这还不是最惨的, 由于之前说我也要一起去出差, 但是后来不知怎得, 一直没让我走, 于是今天我就闲了一天, 到了晚上 19 点(我真称职, 摸鱼都坚持摸到 19 点!), 跟负责人说: &quot;没什么事的话, 我就先回去了...(心想, 赶紧溜...)&quot;, 然后负责人就问我: &quot;你什么时候出差啊?&quot;, 我心想虽说一开始就说了让我去出差, 但是我 TM 是真心不想去出差啊, 不能回到自己心爱的小窝, 还要白交一个月的水电费和住宿费(出差一个月), 我 TM..... !!! 啊... !!! 关键是还要去干我最最最讨厌的服务工作, 靠!! 我为什么要选择开发岗位啊, TM 不就是为了不用和人类打交道吗, 现在让我去干这破活, TM 还不如让我去...还没等我回话, 负责人就说, 我帮你问一下, 你什么时候走, 然后我就看见他在 QQ 上给服务部的人打字问: &quot;***, 什么时候走啊?&quot; 卧槽! 你是巴不得我走是吗??? 你就不能问 &quot;那孩子出差的事怎么样了? &quot; 吗? 心中一万只草泥马奔腾而过, 唉, 算了, 一个陌生人怎么会清楚自己心中所想呢? 回家看番去吧, 今天迷上一部番剧, 虽说比较恐怖, 但还是不错的, 名字叫做 &lt;&lt;约定的梦幻岛&gt;&gt;, 说实话, 太梦幻了, 梦幻的我差点得心脏病...</p>
<p>今天的日语:</p>
<table>
<thead>
<tr>
<th align="left">假名</th>
<th align="left">微软日语键盘输入</th>
</tr>
</thead>
<tbody><tr>
<td align="left">あいうえお</td>
<td align="left">a i u e o</td>
</tr>
<tr>
<td align="left">かきくけこ</td>
<td align="left">ka ki ku ke ko</td>
</tr>
<tr>
<td align="left">さしすせそ</td>
<td align="left">sa si/shi su se so</td>
</tr>
<tr>
<td align="left">たちつてと</td>
<td align="left">ta ti/chi tu/tsu te to</td>
</tr>
<tr>
<td align="left">なにぬねの</td>
<td align="left">na ni nu ne no</td>
</tr>
<tr>
<td align="left">はひふへほ</td>
<td align="left">ha hi hu/fu he ho</td>
</tr>
<tr>
<td align="left">まみむめも</td>
<td align="left">ma ni mu me mo</td>
</tr>
<tr>
<td align="left">やゆよ</td>
<td align="left">ya yu yo</td>
</tr>
<tr>
<td align="left">らりるれろ</td>
<td align="left">ra ri ru re ro</td>
</tr>
<tr>
<td align="left">わを</td>
<td align="left">wa wo</td>
</tr>
<tr>
<td align="left">ん</td>
<td align="left">nn</td>
</tr>
</tbody></table>
<h1 id="2020年01月14日"><a href="#2020年01月14日" class="headerlink" title="2020年01月14日"></a>2020年01月14日</h1><p>2020 年 01 月 14 号周二, 今天确定了年前我不用去石家庄出差了(窃喜, 免掉了很多麻烦, 而且又可以在自己的小窝里多呆几天了, 虽说年后肯定会走, 😔...). 昨天闲了一天, 今天负责人一来就直接发给我一个文档, 意思就是说, 改吧, 改不完别想走 ! 毕竟和他同事了这么久了, 他那点小心思谁不知道? ┑(￣Д ￣)┍ 不过还好, 对我来说并不是很难, 但是今天让我感到恶心的是他的态度, 文档写着要实现置顶功能, 但是 TM 就这一句话啊, 什么细节都没说, 你说这不该拖出去打死吗??? 他想实现的这个置顶功能是打算用选择框加一个单独的置顶按钮控制呢, 还是在每个通知后面加一个 &quot;图钉📌&quot; 这样的按钮来置顶呢? 因为前一种方案还需要一个取消置顶的按钮, 后面的方案就不需要再加一个取消置顶的按钮, 但是那个图钉按钮就得兼顾取消置顶的功能, 还有就是他想实现的置顶是只置顶一条呢, 还是可以置顶多条呢? 置顶多条的时候, 这些被置顶的通知是按照什么排序呢? 用户的置顶顺序? 还是通知的发布时间? 又或者是名称拼音的首字母? TMD 他倒是说明白啊!!! 就这么一句话, 是让我去猜吗?? 平时就总是和我说, 要按照文档写的来, 不要自己乱写, 不要自己乱猜, 文档没让写的不要写, 没让改的不要改, 只改文档中让你改的就行...我 TM...去找他询问到底怎么处理这些问题: &quot;我这边有点疑惑, 想问一下.&quot;, &quot;什么问题?&quot;, &quot;是这样, 文档上写要实现一个置顶的功能&quot;, 然后 TM 他去翻手机通讯录了, &quot;但是这个置顶功能具体的细&quot;, &quot;喂, 是谁谁谁吗? 那个...&quot;, 我 TM ... 故意整我是吗? 我说话的时候你接电话就罢了, 我能忍, 但是你 TM 居然主动向外打电话, 我还在和你说话呢, 你 TM 脑子是进水了吗?? 关键是这个系统是他负责的, 不然我早去问其他人了. 弄得我现在像一只舔狗似的. 还有就是文档中写的模块名和系统中的模块名根本对应不起来, 每次改一个模块我要找半天, 有时还找出好几个类似的出来, 却一个能对应上的都没有, TMD 我改哪个?? 每次在公司干活我都一脸黑人问号.jpg 还有就是他没给我录任务, TMD 不给我录任务, 就让我白干活? 我再等明天最后一天, 如果他还不给我录任务, 我就直接质问他, 让他给我录任务. 不然没绩效, TM 我不就白干了吗? </p>
<p>这又让我想起了之前的年会, 虽说不是今天的事, 不过还是写一下吧. 今年公司的年会那是相当不错, 在一个顶级酒店的超大房间里面, 摆好了好多好多桌子, 桌子上摆满了数不清的食物, 饮品, 大家随便吃喝, 所有的同事之间没有任何的级别差别, 所有人随意畅谈, 上级们来看看自己感兴趣的下级, 来聊聊生活, 聊聊人生, 聊聊理想, 下级们也找到自己憧憬的上级, 聊聊最近的项目, 聊聊身边的帅哥妹子, 聊聊共同的兴趣, 大家其乐融融, 度过了快乐美好幸福的一晚...</p>
<p><img data-src="/images/diary/2020_01/AnnualMeeting.jpg" alt="公司年会"></p>
<p>你觉得可能吗?? 就我们那个破公司?? 那天的年会, 早上 7:40 就必须集合完毕, 再加上年会的前一天下了一场超大的雪, 我那天早上 5:30 起床, 6:00 就出发, 步行去公司, 因为雪太厚, 共享单车上全是雪, 很厚很厚, 路面上也都已经结冰, 骑车是不可能的, 无论单车还是电动车, 摩托车, 只能步行, 走了整整 64 分钟(话说为啥那天我走得那么快啊, 平时都要走 90 分钟的), 7:04 到了公司, 然后签到, 唯一让我欣慰的就是, 凌晨的济南, 景色还是不错的, 一路上听着自己喜欢的歌, 看着太阳慢慢升起, 天空由全黑慢慢变成全亮, 也挺有一番韵味的, 现在想想, 这个集合时间简直有病!! 公司租了几辆大巴车, 每辆车上都塞得满满的人, 浩浩荡荡的去了酒店, 没错, 我们去了酒店耶 ( •̀ ω •́ )y, 哈哈, 然后开了一上午会...... 没错, 你没听错, 我们去酒店开会, 而且还开了整整一上午, 然后就解散回公司了...就是这样, 我几乎全程在听歌, 因为那些所谓的演讲实在是过于恶心, 引起我极度不适, 因此那天上午我只能靠无限刺激的摇滚乐和无尽感伤的悲情乐来覆盖掉我满腔的怒火! 那天早上我也在不停的和自己说着: &quot;本当の強さは一个人的心境不会因为别人的情绪以及周围环境而改变です&quot; 所以说, 年会是什么?? 好吃吗?? ┑(￣Д ￣)┍</p>
<p>今天的日语:</p>
<table>
<thead>
<tr>
<th align="left">日语</th>
<th align="left">假名</th>
<th align="left">微软日语键盘输入</th>
</tr>
</thead>
<tbody><tr>
<td align="left">本当の</td>
<td align="left">ほんおうの</td>
<td align="left">ho nn to u no</td>
</tr>
<tr>
<td align="left">強さ</td>
<td align="left">つよさ</td>
<td align="left">tsu yo sa</td>
</tr>
</tbody></table>
<h1 id="2020年01月15日"><a href="#2020年01月15日" class="headerlink" title="2020年01月15日"></a>2020年01月15日</h1><p>2020 年 01 月 15 日, 周三, 今天他还是没有给我录任务, 哈哈, 服了...🤣 唉, 罢了, 今天从知乎上看到一句话, 已经释然了😀: 社会本就是不公平的, 人们愤愤不平只是因为他们不是利益获得者, 当他们变成利益获得者时, 就不会愤愤不平了, 还会极力打击迫害那些愤愤不平的利益受害者们, 这就是社会! 即使工作的时候我还是一如既往的边抱怨边工作, 最后只会让自己心情变得压抑, 说到底还是自己期望太高, 自己想着 17:30 准时下班, 但是部门经理, 负责人他们让吗? 肯定不让啊! 所以就不要那么玻璃心啦, 什么时候下班无所谓啦, ┑(￣Д ￣)┍ </p>
<p>今天一整天没啥活, 就最后大概 18:00 的时候, 负责人才给了我一个像样点的活, 先不说这个, 说一个之前的一个事, 还没来这家公司之前, 我大学舍友就在这家公司, 然后有一天让我写一个软件, 因为公司说电脑上必须要安装 360 安全卫士和 360 杀毒, 这俩软件在程序员的共识中在就被列入黑名单了, 怎么可能在电脑上装这两个软件, 即使是公司电脑, 于是就让我写一个可以在 Windows 右下角托盘栏的地方显示 360 安全卫士图标以及 360 杀毒图标的工具, 当时我还不会 WinForm 以及 WPF, 于是我就想到了使用 Unity 制作, 制作成功之后有一个很大的缺陷, 占用 RAM 太大, 我找了半天也没找出原因, 只好去学习了 WinForm, 加上不断地 Google, 最终制作出了这个工具, 长下面这样:</p>
<p><img data-src="/images/diary/2020_01/TrayCheatVersion1.gif" alt="WinForm 初始版本 Tray Cheat 工具"></p>
<p>但是后来整理文件的时候, 我把源码给删了!!!! 只留下了程序...(我当时为什么要给 &quot;程序文件夹&quot; 和 &quot;工程文件夹&quot; 起相同的名字呢!!!) 于是今天就继续写之前的工具, 由于已经写过一遍了, 加上也不是从今天才开始写的, 大概已经断断续续写了一周了, 今天是最终将其完成的日子, 并且我使用了 Git 来作为版本控制工具! (Git 最高!) 现在的效果是这样的:</p>
<p><img data-src="/images/diary/2020_01/TrayCheatVersion2.gif" alt="WinForm 重写版本 Tray Cheat 工具"></p>
<p>再说回工作的事, 最后让我找为什么 Page Office 出错, 先安装 Page office, 然后发现他对 Windows 10 的兼容性是真的差, 我还得在 Visual Studio 中手动引用安装文件夹中的库文件, 可是同事的 Windows 7 电脑安装上就可以直接用了...郁闷😔...之后安装 SQL server, 因为公司之前的项目全都是用的 Oracle, 突然一个项目要用 SQL server, 我电脑上还没装呢... 然后等待了一个多小时... 期间用公司网络下载了两个安卓游戏: 「去月球」和「王国保卫战」, 哈哈, 有空玩游戏去! 安装期间也没发生特别大的事情, 顶多有几个组件安装失败罢了, 无伤大雅, 最后经过一段时间跟踪调试, 终于找到了问题所在, 就是单纯的一个 SQL 语句写错了而已...(谁负责的这个项目, 我 TM... 冷静冷静, 生气也没用不是吗?), 一看表, 21:13 了, 下班吧, 不然都没时间洗澡了, 溜了溜了...</p>
<p>今天的日语:</p>
<table>
<thead>
<tr>
<th align="left">日语</th>
<th align="left">假名</th>
<th align="left">微软日语键盘输入</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">最高</td>
<td align="left">さいこう</td>
<td align="left">sa i ko u</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">女子高生</td>
<td align="left">じょしこうせい</td>
<td align="left">jo shi ko u se i</td>
<td align="left">女子高中生简称: JK, 第一次看见是在动漫「女子高中生的无所事事」的 OP 上</td>
</tr>
</tbody></table>
<h1 id="2020年01月16日"><a href="#2020年01月16日" class="headerlink" title="2020年01月16日"></a>2020年01月16日</h1><p>2020 年 01 月 16 日, 周四, 忙了一整天, 基本没闲下来, 对了, 中午玩了一会「王国保卫战」, 真的是名不虚传, 确实好玩, 然后我就一中午没睡觉, 下午看着电脑屏幕差点睡着...😄 最后就是迷上了谷歌助手, 哈哈, 真的能帮助我学日语, 晚上睡觉前发现的, 然后和谷歌助手聊了半天日语....笑死!😂</p>
<p>今天的日语:</p>
<table>
<thead>
<tr>
<th align="left">日语</th>
<th align="left">假名</th>
<th align="left">微软日语键盘输入</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">おかえり</td>
<td align="left">おかえり</td>
<td align="left">o ka e ri</td>
<td align="left">欢迎回来</td>
</tr>
<tr>
<td align="left">おかえりなさい</td>
<td align="left">おかえりなさい</td>
<td align="left">o ka e ri na sa i</td>
<td align="left">欢迎回来</td>
</tr>
<tr>
<td align="left">ただいま</td>
<td align="left">ただいま</td>
<td align="left">ta da i ma</td>
<td align="left">我回来了</td>
</tr>
<tr>
<td align="left">ただいま帰りました</td>
<td align="left">ただいま帰りました</td>
<td align="left">ta da i ma ka e ri ma si ta</td>
<td align="left">我回来了</td>
</tr>
</tbody></table>
<h1 id="2020年01月17日"><a href="#2020年01月17日" class="headerlink" title="2020年01月17日"></a>2020年01月17日</h1><p>2020 年 01 月 17 日, 周五, 今天可能心情不错??? 拍了两张我上下班的风景🤣</p>
<p>早上的朝阳:</p>
<p><img data-src="/images/diary/2020_01/RisingSun.jpg" alt="济南的朝阳"></p>
<p>晚上回家时发现小区门口开始装饰过年的装扮了, 看着还挺漂亮的, 中间的是 3 只小羊(石头雕刻品).</p>
<p><img data-src="/images/diary/2020_01/NightScene.jpg" alt="小区的春节装饰"></p>
<p>今天的日语:</p>
<table>
<thead>
<tr>
<th align="left">汉语</th>
<th align="left">假名</th>
<th align="left">微软日语键盘输入</th>
</tr>
</thead>
<tbody><tr>
<td align="left">零</td>
<td align="left">ぜろ 或 れい</td>
<td align="left">ze ro 或 re i</td>
</tr>
<tr>
<td align="left">一</td>
<td align="left">いち</td>
<td align="left">i chi</td>
</tr>
<tr>
<td align="left">二</td>
<td align="left">に</td>
<td align="left">ni</td>
</tr>
<tr>
<td align="left">三</td>
<td align="left">さん</td>
<td align="left">sa nn</td>
</tr>
<tr>
<td align="left">四</td>
<td align="left">よん 或 し</td>
<td align="left">yo nn 或 shi</td>
</tr>
<tr>
<td align="left">五</td>
<td align="left">ご</td>
<td align="left">go</td>
</tr>
<tr>
<td align="left">六</td>
<td align="left">ろく</td>
<td align="left">ro ku</td>
</tr>
<tr>
<td align="left">七</td>
<td align="left">なな 或 しち</td>
<td align="left">na na 或 shi chi</td>
</tr>
<tr>
<td align="left">八</td>
<td align="left">はち</td>
<td align="left">ha chi</td>
</tr>
<tr>
<td align="left">九</td>
<td align="left">きゅう 或 く</td>
<td align="left">kyu u</td>
</tr>
<tr>
<td align="left">十</td>
<td align="left">じゅう</td>
<td align="left">ju u</td>
</tr>
</tbody></table>
<h1 id="2020年01月18日"><a href="#2020年01月18日" class="headerlink" title="2020年01月18日"></a>2020年01月18日</h1><p>2020 年 01 月 18 日, 周六, 今天要改一个柱状图(之前没接触过), 后来看见源码知道用的是一个叫做 &quot;ECharts&quot; 的插件, 有空的时候单独写一篇 &quot;ECharts&quot; 的文章吧, 这里就不写了. 但是那个 SB 服务我就必须说一下了, 事件的背景是我改完柱状图, 并将代码升级之后, 服务部的人就给我发消息了, 我截取了其中最 SB 的部分(其中 Kirito Asuna 头像的是我):</p>
<p><img data-src="/images/diary/2020_01/ECharts_SB.jpg" alt="ECharts 傻逼事件"></p>
<p>这个 SB, 当数据为零的时候, 居然还问我为什么柱状图没显示出来......你 TM 是在逗我??? 公司里难道没个正常人吗? 又想起个事来, 还是之前说要去出差的事, 当时不是说年前不去了嘛, 于是这件事的 &quot;负责人&quot; 就说: 剩下这几天咱们培训一下, 大家多看看群里的问题, 多准备准备. 我一听还不错嘛, 看来剩下几天没什么活了, 哈哈...然后...然后...我 TM 就疯了!!! 接下来几天, 我开发岗负责人不停催我干活: 今天必须干完, 干不完别想走! 那个服务部的混蛋(可能是服务部, 就是让我出差那个人), 就来说我赶紧看问题啊, 你干嘛呢??? 我当时真想给他们俩两巴掌, 你们俩个是商量好的吗??? 啊??!! 最后我直接把河北的群屏蔽了, 会也没去开(话说我事后才知道有会议, 哈哈...🤣), 无事一身轻, 到时问我为什么不会我就直说没时间看, 过年那段时间太忙了, 没看我连开会的时间都没有嘛!!(事实确实是连开会的时间都没有, 当时是真的忙). 这是一个事, 两个 SB. 之后还有, 就是今天的事了, 今下午 14:30 要考试, 然后上午快下班的时候, 服务部那个 SB 就说: 今下午咱们再开个会, 下午两点半(这个傻逼居然说两点半...), 6楼. 然后另一个小伙伴就说了: 下午两点半不是要考试吗? 意外的是那个 SB 秒回: 那就三点半. (我 TM... 你是说话不动脑子吗?? 开会时间随便就随口一说, 不行再随口一改!! 真是...狗还知道进食之前先闻闻呢... 可能是脑子进水了吧, 那就不怪他了...)</p>
<p>这让我想起了当年 SB 的我, 我从小学当班干部一直当到高二, 有一次开班会, 我也是随口安排活动时间, 导致最后很多人抱怨, 没有考虑大家的意见, 不过最后我意识到了自己是犯了多么愚蠢的错误, 就果断引咎辞职了, 要是别人肯定会吸取教训, 改正错误, 迎难而上, 可惜我不是那种遇强则强的人, 于是就干脆逃避了, 再也不参与管理层, 也间接造成了现在我独善其身的性格 (说实话, 我并不推崇这种性格哈, 甚至还有点反感, 独善其身的人一般都过于理性). 看着比自己年长的人却在犯着自己小时候的错误, 唉, 心累啊...我想起了之前自己说的一句段子: &quot;为啥中华民族到现在了都还没有崛起, 还不是因为像 XXX 这样的 SB 太多了!!!&quot;. (哈哈, 就是个段子而已, 笑笑就行了)</p>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title>日记系列--2020年03月</title>
    <url>/diary/2020_03.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="2020-年-03-月-03-号"><a href="#2020-年-03-月-03-号" class="headerlink" title="2020 年 03 月 03 号"></a>2020 年 03 月 03 号</h1><h2 id="对求生创造型沙盒网游-Rogalia-的思考"><a href="#对求生创造型沙盒网游-Rogalia-的思考" class="headerlink" title="对求生创造型沙盒网游 Rogalia 的思考"></a>对求生创造型沙盒网游 Rogalia 的思考</h2><p>Rugolia 的设计十分巧妙, 实现了慢速升级, 将 &quot;等级系统&quot; 和 &quot;熟练度系统&quot; 隐形结合在了一起, 看似是等级系统, 实则等级是在营养系统的牵制之下的, 摄入营养并吸收可以提升人物等级上限, 一开始人物的等级上限是很低的, 大概只有 10 级, 摄入营养之后可以提升这个上限, 然后这时候再去训练技能, 技能的等级才能真正提升, 那么只要不断地提升营养不就可以快速快速提升等级上限并且快速升级了吗? 但是巧妙的是营养是必须在饥饿的时候才能摄入的, 而且饥饿度是需要时间去降低的, 而这个时间就是真正的现实世界时间, 于是升级速度就这样被强制拉慢了. 就是说在这个世界中氪金是无法变强的, 这个世界的强度只和现实世界中的时间付出有关. </p>
<p>Rohulia 中的家园系统也设计得十分有意思, 它将所有玩家的家园放到一张地图中, 这样就具有了竞争元素, 只有快速发展的人才能赚取更多的土地, 发展慢的玩家得到的土地自然就少, 而且土地总数就是那些, 所以前线玩家和其他玩家的差距就会慢慢地越拉越大. 所以说这在玩家少的时候算是一个不错的选择, 但是一旦玩家数量上升, 玩家之间地竞争力度也会不可避免地快速上升, 一旦玩家之间出现摩擦将是很难处理的. 因此对于 Rugalia 的家园系统如果让我来做, 基本形式一样, 只是我会选择将共有一张地图改为每人一张地图. 就像是之前玩过的 &quot;QQ三国&quot; 那样, 每个人的地图都是一样的, 资源也是一样的, 这样也算是公平, 就是尽量将玩家与玩家之间的竞争改为玩家与怪物之间的竞争.将玩家之间的竞争改为合作, 尽量去减少玩家之间会发生的摩擦. </p>
<p>但是有一个地方我觉得这个游戏设计的不好, 就是职业系统. 说白了这个游戏的职业系统完全就是摆设, 职业唯一的区别就是初始技能的等级不同. 剑士的 &quot;剑士&quot; 技能初始就是 10 级, 其他技能是 5 级. 同样的道理, 厨师的 &quot;烹饪&quot; 技能初始就是 10 级, 其他技能 5 级. 但是既然所有的技能都可以升级, 升级速度也都是一致的, 自然玩家都会追求全面发展, 而且游戏的嵌套机制导致玩家不升级其他的技能也根本不可能升级他的主技能, 所有的技能都是紧紧联系在一起的. 这样就导致玩家之间的 &quot;合作&quot; 也成为了摆设. 这样 &quot;竞争&quot; 就会凸显, 游戏世界的矛盾也会变得尖锐. 那么如何减少竞争, 凸显合作呢? </p>
<h3 id="1-设立单职业的绝对限制"><a href="#1-设立单职业的绝对限制" class="headerlink" title="1 设立单职业的绝对限制"></a>1 设立单职业的绝对限制</h3><p>比如: 你是一个剑士, 那么你的战斗技能升级比例可能是 1.2, 但是你的铁匠技能升级比例可能只有 0.8, 烹饪技能比例甚至可能只有 0.4, 同样, 作为一个铁匠, 可能升级的比例就是: 战斗 0.6, 铁匠 1.2, 烹饪 0.6, 那么厨师就可能是: 战斗 0.4, 铁匠 0.4, 烹饪 1.6 ! 这样单靠一人之力, 是绝对不可能快速变强的, 而只能靠团队. 每个职业都是必须的. 甚至在一个奇幻世界里, 厨师比剑士还要有价值. </p>
<h3 id="2-杜绝游戏工作室"><a href="#2-杜绝游戏工作室" class="headerlink" title="2 杜绝游戏工作室"></a>2 杜绝游戏工作室</h3><p>上面说到, 游戏要鼓励玩家们的合作, 来共同对抗AI, 但是有些人(没错, 就是说的你, 游戏工作室!)他们就很聪明, 他们通过使用脚本外挂的形式, 一个人操控大量的账号, 这些账号一天便可以产出大量的初级材料, 导致游戏运营一段时间之后, 内部材料就会数量过剩, 通货膨胀, 以平民玩家的那点产出根本不够看的, 所以非战斗职业的玩家很快就会离开游戏, 游戏的经济体系会完全崩溃, 游戏内容也会变得机械化. 这样的话, 我们前面说的 &quot;单职业限制&quot; 就完全成为摆设了. 那些产出类的职业都成了工作室, 只剩下了战斗类职业是玩家, 这时候这个游戏就基本凉凉了. &quot;游戏工作室&quot; 这个东西简直是 MMORPG 杀手! 不把游戏工作室排除, MMORPG 永无出头之日.那么如何排除游戏工作室这个毒瘤呢? </p>
<h4 id="2-1-取消充值渠道"><a href="#2-1-取消充值渠道" class="headerlink" title="2.1 取消充值渠道"></a>2.1 取消充值渠道</h4><p>一个方法是游戏中不再照顾 &quot;氪金&quot; 玩家的情绪, 也就是说关闭所有的充值渠道, 也就是关闭 &quot;现实世界&quot; 和 &quot;游戏世界&quot; 的连接. 让玩家体会到无论你在现实世界遭受了多么不公平的待遇, 在游戏世界中都是平等的, 只要付出时间, 都可以成为强者. 现实世界中每个人从出生开始就是不公平的, 但是游戏世界不一样, 虽然有职业之间的区别, 但是所有人都是这样的. 职业和职业之间是完全一致的. 这样就能吸引大量的平民玩家. </p>
<h4 id="2-2-账号人身绑定"><a href="#2-2-账号人身绑定" class="headerlink" title="2.2 账号人身绑定"></a>2.2 账号人身绑定</h4><p>另一个方法就是每人只能有一个账号. 现在大部分游戏使用 &quot;身份证号&quot; 来杜绝工作室, 但是其实还是有很多方法获取身份证号的, 再加上其他国家的人呢? 所以我这里想到的是 &quot;人脸识别&quot; 加 &quot;指纹检测&quot;. 借助人脸识别来杜绝账号的重复. 我就不信工作室的人还能为了获取大量账号去整容? ! 因为随着 &quot;人脸识别&quot; 技术的进步, 现在使用照片一类的方法已经糊弄不过去了. 即使他们想到各种办法突破 &quot;人脸识别&quot;, 还有 &quot;指纹识别&quot;, 这样制作账号的成本就太高了, 谁也不会去做赔本的买卖. 再加上充值渠道已经取消了, 就算开工作室, 也赚不到钱. </p>
<h1 id="2020-年-03-月-04-号"><a href="#2020-年-03-月-04-号" class="headerlink" title="2020 年 03 月 04 号"></a>2020 年 03 月 04 号</h1><h2 id="最近游戏的截图-非酋"><a href="#最近游戏的截图-非酋" class="headerlink" title="最近游戏的截图, 非酋"></a>最近游戏的截图, 非酋</h2><p>之前不是玩了一段时间的 &quot;游戏王&quot; 嘛, 当时稍微截取了几张图. </p>
<p>最开始迷上的是 &quot;蛇神姐姐&quot;, 这无视一切卡片效果的无敌抗性, 什么三幻神! 渣渣! </p>
<p>幻想台词: &quot;毒蛇王被破坏的瞬间, 发动陷阱卡, &quot;蛇神降临&quot;! 当毒蛇王在场上被效果破坏时, 可以从手牌或者卡组中将一只毒蛇神特殊召唤! 统御一切的神啊, 向世人展现您那高贵的身姿吧! 降临吧! 毒蛇神 <strong>·</strong> 维诺米纳迦! &quot;. </p>
<p>太帅了! 太强了! 4500 的面板攻击力! 哈哈, NPC 们, 你们再用 &quot;光之护封剑&quot; 啊! 你们再用 &quot;强夺&quot; 啊! 你们再用 &quot;收缩&quot; 啊! 哈哈, 没用了吧, 无敌的感觉真爽! (游戏中的 NPC 是不会使用 &quot;技能抽取&quot; 等可以对抗蛇神姐姐的卡的. 😂)</p>
<blockquote>
<p>看对面即使场上有 &quot;光之护封剑&quot; 又怎样? </p>
<p>蛇姐: &quot;光之护封剑&quot; 是什么卡? 我咋没听说过呢?</p>
<p><img data-src="/images/diary/2020_03/UnLucky_1.jpg" alt="降临吧! 毒蛇神 · 维诺米纳迦"></p>
</blockquote>
<blockquote>
<p>这是蛇神姐姐的效果介绍:</p>
<p><img data-src="/images/diary/2020_03/UnLucky_2.jpg" alt="毒蛇神介绍"></p>
<p>当时玩的是 游戏王卡片力量2, 卡池很小, 没在小黑屋的特殊胜利卡确实不多.</p>
</blockquote>
<p>后面我又迷上了 &quot;艾克佐迪亚&quot;, 那种 &quot;不战而胜&quot; 的感觉也是爽啊! </p>
<blockquote>
<p>第一局上来就遇到了 &quot;区域破坏&quot; 卡组, 我的四个怪兽区域都无法使用了, 但是我又不召唤怪兽, 你又能把我怎么样呢 ? ? (略略略~)</p>
<p><img data-src="/images/diary/2020_03/UnLucky_3.jpg" alt="艾克佐迪亚"></p>
</blockquote>
<p>不过依然是无法逃脱 &quot;非酋&quot; 的命运! </p>
<blockquote>
<p>卡组中就剩两张卡了, 但是我就是没有集齐五张卡... 我的天...😣</p>
<p><img data-src="/images/diary/2020_03/UnLucky_4.jpg" alt="艾克佐迪亚"></p>
</blockquote>
<p>这次脸更黑 ! !</p>
<blockquote>
<p>卡组还剩 6 张卡, 然后我才上手一张 ! ! 这还玩啥啊 ...</p>
<p><img data-src="/images/diary/2020_03/UnLucky_5.jpg" alt="艾克佐迪亚"></p>
<p>我还就不信了! ! </p>
<p><strong>俺のターン, ドロー ! !</strong></p>
<p><img data-src="/images/diary/2020_03/UnLucky_6.jpg" alt="艾克佐迪亚"></p>
<p>我 TM ... 我的脸真的是黑到极限了 ! !</p>
<p>嘛, 还好最后还是赢了... 放一张 &quot;黑暗大法师 - 艾克佐迪亚&quot; 吧. (可惜蛇神姐姐没有 3D 建模...蛇神王倒是有建模...)</p>
<p><img data-src="/images/diary/2020_03/UnLucky_7.jpg" alt="艾克佐迪亚"></p>
</blockquote>
<h1 id="2020-年-03-月-05-号"><a href="#2020-年-03-月-05-号" class="headerlink" title="2020 年 03 月 05 号"></a>2020 年 03 月 05 号</h1><p>计划已经连续执行了好几天了, 晚上的活动安排已经进入了正轨: (洗漱, 洗脚, 健身, 制作游戏), 早晨的日语学习也已经找到了合适的学习材料, 也步入了正轨. </p>
<p>中午的时间, 之前是用来午睡的, 现在也用来刷 LeetCode 了, 总之呢, 自己的业余生活算是回归正轨了. </p>
<p>不过呢, 今晚上发生了一件不可思议的事情, 不知道会对我接下来的生活产生什么影响. 那就是 &quot;欢欢&quot; 居然找我了, 虽然只是询问我一道数学题该怎么做, 但是我压抑不住啊, 太开心啦, 哇哦! 她是我初恋啊! 我的天! 我不是做梦吧! 😂</p>
<h1 id="2020-年-03-月-06-号"><a href="#2020-年-03-月-06-号" class="headerlink" title="2020 年 03 月 06 号"></a>2020 年 03 月 06 号</h1><p>第十周周五了, 😅 时间过得也太快了吧!! 一年的五分之一已经过去了...</p>
<h1 id="2020-年-03-月-07-号"><a href="#2020-年-03-月-07-号" class="headerlink" title="2020 年 03 月 07 号"></a>2020 年 03 月 07 号</h1><h2 id="对自己-quot-喜欢女生留长发-quot-这个自私想法的思考"><a href="#对自己-quot-喜欢女生留长发-quot-这个自私想法的思考" class="headerlink" title="对自己 &quot;喜欢女生留长发&quot; 这个自私想法的思考"></a>对自己 &quot;喜欢女生留长发&quot; 这个自私想法的思考</h2><p>提问: 未来的我哟, 你最爱的人是谁? </p>
<p>你还能秒答 &quot;Asuna&quot; 吗? 恐怕现在的你已经有真正喜欢的人了吧, 我这里说的 Asuna 不是真正的 Asuna 哦, 而是那位大学同学, 记得当时自己说过: 你留长发多好! 我喜欢长发女生. 现在回想起来, 我还真是个相当恶劣的变态呢, 而且还相当的自私, 原来女生留长发有那么多不便利的地方, 原谅我想得太单纯了😂</p>
<h2 id="对自己曾经盲目相信中国不好言论的检讨"><a href="#对自己曾经盲目相信中国不好言论的检讨" class="headerlink" title="对自己曾经盲目相信中国不好言论的检讨"></a>对自己曾经盲目相信中国不好言论的检讨</h2><p>基于这次流感, 我也认识到了之前的我把中国的缺点无限放大了, 导致自己心中生出了很多对中国的厌恶之情. 厌恶空气差, 厌恶人素质差, 厌恶教育制度差, 但是其实我根本不知道日本的空气, 日本的素质, 日本的教育等等, 全部都是自己臆想出来的罢了. 做人一定要实事求是啊!</p>
<h1 id="游戏构思"><a href="#游戏构思" class="headerlink" title="游戏构思"></a>游戏构思</h1><ul>
<li>玩家是一个学校顶尖学生.</li>
<li>来到了一个新世界, 但是这个世界中的人们的文明程度较低, 处于奴隶制社会.</li>
<li>最开始是一个农场游戏, 玩家制作食物器材武器等换取报酬, 但是全部会被压榨干净, 如果不想办法逃离这里, 只会死亡.</li>
<li>之后玩家觉醒, 要改变这个世界, 对应游戏标题: 改变世界.</li>
<li>之后变为 RPG 剧情向游戏, 增加伙伴, 宠物, 妖精, 得到武器, 铠甲, 攻下属于自己的两三个城市.</li>
<li>之后变为三国志类型的战略游戏, 攻城略地, 拼头脑战.</li>
</ul>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title>日记系列--2020年04月</title>
    <url>/diary/2020_04.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="2020-年-04-月-07-号"><a href="#2020-年-04-月-07-号" class="headerlink" title="2020 年 04 月 07 号"></a>2020 年 04 月 07 号</h1><h2 id="低血糖"><a href="#低血糖" class="headerlink" title="低血糖? !"></a>低血糖? !</h2><p>今早上起床的时候, 先是在床上玩了会游戏, 一看时间该去上班了, 就赶紧收拾去上班. 但是不知道是站起来的时候用力太猛还是其他的什么原因, 突然感觉胸口, 或者说心脏堵得慌, 感觉心脏的跳动频率都慢下来了, 正纳闷呢, 突然大脑就开始急速运转, 我能明显感觉到当时大脑就是在飞速地思考, 当然思考的都是些乱七八糟的东西, 之后大脑以及整个头部, 包括脸, 脖子都渐渐地变得麻木, 知觉越来越轻, 最后知觉完全消失, 我就倒在桌子上了, 刚倒那一瞬间, 我能感觉到我的手臂以及躯干都在试图维持住身体的平衡, 试图支撑住身体, 但是身体就是不争气, 在不停地往下倒, 手臂再怎么用力也无济于事, 大概就短短 2 秒左右吧, 我感觉我的手臂真的是尽了最大努力了, 最后身体倒在了桌子上, 头重重地砸在了桌面上, 桌子也因为整个身体的重量被推到了一边, 还好即时醒过来了, 也可能是疼的吧, 毕竟手臂磕在桌沿上了嘛. 之后我赶紧坐在了床边, 努力回想刚刚的经过. (怎么回事? 我刚刚是怎么了? 难道刚刚我是晕倒了? 我身体不会是出事了吧?) 不一会, 耳朵就开始耳鸣, 嗡 ~ ~ 嗡 ~ ~ 持续了大概 2 分钟吧, 这样晕倒的事情就告一段落了, 后面就正常生活工作. 现在下班回到家, 也没感觉到身体有什么不适, 总之, 后面多注意一下身体吧. </p>
<h1 id="2020-年-04-月-10-号"><a href="#2020-年-04-月-10-号" class="headerlink" title="2020 年 04 月 10 号"></a>2020 年 04 月 10 号</h1><p>之前清明节的时候送给 Sakura (小樱) 的项链她戴上了, 她戴上了啊! 是不是对我有感觉了呢? 还是为了不让我心凉, 戴上让我看看呢? 唉, 不得而知啊...总之她还发了照片给我, 好开心😊</p>
<p><img data-src="/images/diary/2020_04/Sakura_001.jpg" alt="Sakura"></p>
<h1 id="2020-年-04-月-11-号"><a href="#2020-年-04-月-11-号" class="headerlink" title="2020 年 04 月 11 号"></a>2020 年 04 月 11 号</h1><h2 id="人生的意义"><a href="#人生的意义" class="headerlink" title="人生的意义? !"></a>人生的意义? !</h2><p>事件起源自王健的一次提问, 他问我驱动我前进的动力是什么? 驱动着我继续活下去的意念是什么? 我当时的回答的原文是: </p>
<blockquote>
<p>如果是其他人问我的话, 我应该会回复: 梦想吧!</p>
<p>但是是你的话, 我应该会说: 虚荣心吧!</p>
</blockquote>
<p>因为王健是我真正能说出心声的人, 我不怕在他面前丢人, 我愿意把自己随性, 懒惰的一面吐露出来, 于是就有了上面的回答. 但是王健否认了我的回答, 说这不是一个好的回答, 我细想一下, 是啊, 把自己懒惰的一面吐露出来是什么鬼? 既然知道这是懒惰, 这是负面的情感, 那为什么不去改正呢? 于是我回复: 给我一段时间, 我去找一下.</p>
<p>最近 7 号的一次晕倒, 加上今天看了一些知乎上的问答, 又去了朋友家一趟, 最后还看了两部电影, 《Hello World》 和 《新世界》, 我得出了我的答案, 我活着的意义就是为了追寻心中那个完美的自己. </p>
<p>来分析一下哈, 常见的追求大概可以分为四类: &quot;名利权情&quot;. 名就是名声, 利就是金钱, 权就是权力, 情就是感情. 这四种都有一种共性, 那就是一个人是无法实现的. 名利权是建立在全社会人类的基础上的, 情则是建立在另一个人的基础上的, 它们都需要其他人来和自己互动才能实现. 名声就意味着必须社会大部分人都对你持有认同感, 都认同你, 或者说你周围的人都认同你, 那么你就有了名声. 金钱也是, 你有十亿元, 但是其他人平均都有一百亿元, 那你还是没钱, 但是即使你只有一元钱, 但是周围所有人都只有一分钱, 那你就是世界首富! 剩下的权力自然也是这样, 大部分人都服从你, 你的权力才是有效的. 最重要的是, 这三者都是身外之物, 它们根本就不能给自己带来真正的快乐, 有人说有钱就快乐啊, 我就可以去买吃的, 去买穿的, 去旅游, 去玩耍, 但是前提是你得会玩耍, 你真的会玩耍吗? 那些低级乐趣真的能让你快乐吗? 看完色情片你真的快乐吗? 去买买买, 吃吃吃, 真的快乐吗? 去这旅游, 那旅游, 去这看看, 去那看看, 到头来自己真正喜欢, 真正让自己发自内心去爱的城市却没有一座也没有, 喜欢玩这个游戏, 玩那个游戏, 但是最后呢, 没有真正的一款游戏能够给你带来真正的快乐. 那些全部都是空虚的刺激感. 这是我最开始便排除这三者的根本原因. </p>
<p>那为什么最后的 &quot;情&quot; 也被排除掉了呢? 难道是这里的情只代表色情, 所以排除掉了? 当然不是啦, 这里的情代表的是爱情, 亲情, 友情等需要与第二者互动才能产生的情感. 对于那些刚刚经历了爱情, 亲情, 友情波折的人, 只有当你意识到了这不是自己活着的意义的时候, 你才能真正的放下这段情感. 这并不是无情, 而是对自己负责. 有的人过度追求情感, 于是 &quot;舔狗&quot; 就诞生了. <code>舔狗: 在对方一而再再而三地明确表示拒绝的情况下还是一如既往地向对方示好的行为.</code> 很多人舔到最后一无所有, 就开始怀疑世界, 怀疑人生, 唉...我看着都心疼, 为啥就不能好好对待自己, 好好对自己负责呢? 其实都很简单, 只要当你意识到这不是自己活着的意义的时候, 你自然而然就明白了. (亲身经历过的人应该已经明白了吧, 说多了都是泪啊...) 再说友情, 前段时间, 我纠结于如何处理曾经的友情, 我有很多很多初中, 高中的好友, 曾经的竞争对手们, 真的怀念之前那份在一起无话不谈, 一起刷题准备中考, 中午一起点餐, 吃同一份烤鸡架的时光, 怀念那些曾经交心的朋友们, 我还试图寻找过他们的联系方式, 但是一切都显得那么无力, 那段时间我心力憔悴, 满脸愁容, 已经深深地陷入到回忆之中. 不过后来随着时间的推移, 这份悲伤之情也慢慢淡化, 我也慢慢找回了自己. 我现在已经想通了, 那不是我活着的意义, 那不是我要穷尽一生去追寻的东西, 那些东西过去了就是过去了, 无需再感到惋惜, 无需再去联系, 只需将其作为饭后茶点的谈资就行了. 当你能真正的心平气和地和别人谈论这些的时候, 就说明你真正地放下了. </p>
<p>最后是亲情, 亲情是这里面最特殊的一种, 通常情况下亲情无需我们去追求, 甚至我们都不需要刻意去维护它, 它就一直存在. 但是往往亲情离开的时候是最让人难以接受的. 如果亲情是你的活着的意义, 那么当亲情消失的时候怎么办呢? 当父母去世的时候怎么办呢? 当然不能殉情啊是吧, 我们还是要继续活下去的. 所以最终我还是将 &quot;情&quot; 排除掉了.</p>
<p>以上四点只能作为生活的点缀, 或者说生活的一部分, 或者说以上的都是生活本身的要素. 这些都不能作为活着的意义. </p>
<p>当我捡起高中的笔记的时候我想起来了, 我其实很早很早之前就描绘了一个完美的自己, 我爱那个自己, 我要去追求那个自己. 但是生活的琐事让我忘记了这份意义, 明明活着的意义就摆在那里, 我却一直没有去触碰它. 接下来要做的事情就简单了, 我要去提升自己, 我要穷尽一生去追寻那个完美的自己, 尽自己的最大努力去触碰那个完美的自己, 这样我死前也就不会有任何的遗憾了. </p>
<h1 id="2020-年-04-月-14-号"><a href="#2020-年-04-月-14-号" class="headerlink" title="2020 年 04 月 14 号"></a>2020 年 04 月 14 号</h1><h2 id="友人以及恋人的定义"><a href="#友人以及恋人的定义" class="headerlink" title="友人以及恋人的定义"></a>友人以及恋人的定义</h2><p>在我眼里, 能算作家人的人的定义, 或者是理想中的友人的定义</p>
<ol>
<li><p>在一起会有一种亲切感, 没有理由的那种. 就是单纯地会感到亲切, 感到温暖, 甚至嘴角能够不自觉上扬!</p>
</li>
<li><p>人与人之间界限分明, 这个是谁的, 那个是谁的, 都是非常清楚的. 自己在做什么, 别人在做什么基本不会有交集, 不会互相影响. (娱乐时间除外) 倒垃圾, 做饭, 打扫卫生等事今天谁做, 明天谁做, 也都是十分清楚的. </p>
</li>
<li><p>任何关系到多个人的事都是平均分, 没有谁多谁少. 大家都是伙伴, 无论缺谁都是不行的. </p>
</li>
<li><p>所有的帮助, 所有的礼物, 所有的分享 (知识, 资源, 技术), 所有的付出都是自愿的, 人与人之间没有任何的强求, 任何自愿行为都不需要任何回报. </p>
</li>
<li><p>极少的请求要求, 所有人都不会主动麻烦别人, 坚决杜绝给别人添麻烦, 除非情况大家有目共睹, 特殊情况. </p>
</li>
<li><p>同时坚决反对所有对他人的管理, 任何人无权过问, 管理他人事务. 除非此事已经不仅仅影响他自身, 还影响到了其他人 (外放音乐, 外放视频, 工作场合玩游戏, 工作场合谈论与工作无关事项, 长期无法执行自身计划, 已经影响到自身未来发展时等等情况), 或者由其自身提出帮助请求. </p>
</li>
<li><p>每个人都有自己的事可忙, 而不是无所事事. 闲时大家都有自己的兴趣爱好, 放松自己的同时, 又不会影响到他人. </p>
</li>
</ol>
<p><strong>这段时间和 Sakura 的相处 (不就是微信上聊天嘛, 还想处? 弄得跟真的似的!), 我好累啊, 虽然原因是自己太投入了, 忘记了自己的生活, 但是我还是好希望她能搭理一下我😂, Kuroha! Fight!</strong></p>
<p><img data-src="/images/diary/2020_04/666.png" alt="对面表示不想和你说话, 并向你扔了一张 666 !"></p>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title>日记系列--2020年06月</title>
    <url>/diary/2020_06.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="2020-年-06-月-15-号"><a href="#2020-年-06-月-15-号" class="headerlink" title="2020 年 06 月 15 号"></a>2020 年 06 月 15 号</h1><h2 id="生活开始走上正轨了"><a href="#生活开始走上正轨了" class="headerlink" title="生活开始走上正轨了"></a>生活开始走上正轨了</h2><p>真的是好久好久没有写日记了, 最近还是发生了很多大事的:</p>
<ol>
<li>五一放假时给姐姐转养老费, 然后被银行黑了 4000 RMB!</li>
<li>从五月十号开始直到六月十四号一直寄住在同事家里, 心里总不是滋味. </li>
<li>六月十三号答辩结束, 老师还说我做的不错, 可是谁都不知道我只花了一周的事件准备毕设, 包括开题报告, 论文, PPT, 作品 (一款沙盒游戏)...</li>
<li>六月十一号加班到凌晨两点, 真的服! 现在我都不知道当时咋坚持下来的, 哦, 对了, 是边听歌边敲代码坚持下来的...</li>
</ol>
<p>今天终于发工资了, 由于五月份请假太多, 导致工资只有 4174 元, 连这一个月的开销都不够: 1200 房租, 1000 花呗, 2000 爸爸的养老费... 不过还好, 下个月爸爸的养老费就是一月 1000 了, 由于不请假了, 工资也会上去, 总之生活在慢慢变好!</p>
<p>还发现了一张当时玩 2048 游戏的分数记录, 我居然玩到了最大的方块到了 16384 !</p>
<p><img data-src="/images/diary/2020_06/2048_MaxScore.jpg" alt="2048_MaxScore"></p>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title>日记系列--2020年07月</title>
    <url>/diary/2020_07.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="2020-年-07-月-31-号"><a href="#2020-年-07-月-31-号" class="headerlink" title="2020 年 07 月 31 号"></a>2020 年 07 月 31 号</h1><p>哈哈, 月底了写一下七月的总结吧. 要不顺便起个 90 年日漫式的标题?</p>
<h1 id="第一集-毕业危险了"><a href="#第一集-毕业危险了" class="headerlink" title="第一集 毕业危险了!"></a>第一集 毕业危险了!</h1><p>刚到七月我就收到了一个及其震撼人心的消息, 我毕不了业了! 是的, 你没听错, 不是我毕业了, 是我毕不了业了! 我学分差两分导致不能毕业, 只能拿到结业证... 当 16 级班长告诉我这个消息的时候, 我当时整个人处于懵逼的状态: 啥, 不能毕业? 谁啊? 我吗? 怎么可能, 你在开玩笑吧, 你是不是打错电话了? </p>
<p>过了 1 分钟: 我 TM 真的不能毕业了? 真的是我啊! 不可能啊, 我休学之前就只剩一个毕业设计了啊, 而我这次毕业设计又很顺利地通过了, 你告诉我不能毕业, 你是在逗我吗? 今天不是愚人节啊! </p>
<p>只听 16 级班长缓缓地说: 学长, 是这样的, 16 级培养方案和 15 级的不一样, 多了两门课, 分别叫做: <code>大学生就业与创业指导2-1</code> 和 <code>大学生就业与创业指导2-2</code>, 这两门课是在学长你 <font color='red'><strong>休学期间</strong></font> 开课的, 所以缺这两门课的学分...</p>
<p>我 ... 我 TM ... 我是真的忍不住了, 我在心里已经开始骂人了, 这 TM 是人干的事? 学校脑子是落家里了吧! 不过这是和 16 级班长也没关系, 谢谢人家通知我就只好挂电话了. </p>
<p>第一件事, 发呆... 第二件事, 继续发呆... 我当时已经懵了... 不久卢阳老师来电话了, 这是我大学辅导员, 对我特好, 特感谢她, 就和我聊起了这事, 说她正在积极地帮我处理此事, 让我也去联系一下教务处, 问问教务处的意见, 我当时啥法子没有, 老师既然有主意, 那自然得照办啊. </p>
<p>接下来就打电话给教科办的田老师 (很抱歉, 至今为止不知道这位老师的全名, 总之也很感谢田老师), 田老师一开始是严厉拒绝的, 按她后来的说辞是她不知道我家里的情况以及我休学的原因, 以为我是因为不想学习或者是其他一些消极的理由而休学的, 所以坚决不处理此事, 我 TM ... 这和我休学的理由有毛关系啊... 这 TM 不全是学校的责任吗? 这是和我有半毛钱关系吗? 后来的一次通话中和我说什么上次是因为她不清楚我的情况, 还说我怎么不早和她说我家里的情况, 我 TM ... 念在她也帮了我不少的份上就不计较了, 果然在这个世界卖惨还是有人买账的! 其实我并没有卖惨, 我家庭情况确实如此, 再加上这主意还是陆老师帮我想到的, 我在这些事情上脑子不咋灵光...</p>
<p>虽然经过了辅导员和田老师的努力, 但是依然没有任何的进展, 于是我直接找系主任张德学老师了, 果然系主任说话就是好使, 一下子副院长, 院长都知道这事了, 中间拖了大概有 3 周, 3 周啊, 21 天啊, 我都不知道这 21 天我是怎么过来的, 这也是后面患急性支气管炎的一个诱因. </p>
<p>中间打电话问卢阳老师, 卢老师都有一点想要放弃的想法了, 我也是一样, 渐渐地整个人没有了任何生机, 浑身乏力, 没想到生活中的琐事会对我的心境影响这么大, 整个人基本废了... 还好张德学老师一直告诉我肯定有办法的, 而且卢阳老师和田老师的观点都是这事情的责任在我, 我也不知道他们怎么想的, 但是我也不能直说呀对吧!</p>
<p>后来卢阳老师又想到计算一下如果用 15 级的培养方案, 看一下我是不是能够毕业, 但是戏剧性的一幕出现了, 我当时交毕业实习报告的时候是 3 月份, 然后我 4 月份休学了, 休学通知都下来了, 我就安心在医院照顾我爸爸了, 但是毕业实习的分数上传是在 5 月 25 号, 此时我已经不在学校的管理系统中了, 就是我已经录不了分数了... 我 TM ... 这咋整, 对了, 今年我也写实习报告了呀, 就算是疫情, 我也是在 2 月份就回济南上班了, 写个实习报告那还不是手到擒来嘛... 然后戏剧性的一幕又双出现了... 16 级的培养方案的确是多出来 2 分, 但是培养方案的总分和 15 级的是一样的, 原因是 16 级的 <code>毕业实习</code> 课程不再计算学分了, 因为疫情嘛, 很多人没法实习啊, 所以这门课无效了... 我 TM ... 学校, 我真 TM 谢谢你啊!!!</p>
<p>就这样, 在经历了无数次碰壁之后, 我已经彻底绝望了...</p>
<p>但是! 但是! 但是! 张德学老师不是这么认为的, 他认为这事我一点责任没有, 这事情完全是学校的锅, 学校一没通知我选课, 二没通知我上课, 三科还是在我休学期间开课, 就算让我选也选不了, 所以就让我放下心来, 这是学校肯定会处理好的. 实在不行, 就让我向前几年的一位学长学习一下, 从外界给教务处那么 &quot;一点点&quot; 压力, 有些时候吧, 你不给他点压力, 他就不认真干活啊! 对把, 具体, 你懂的!</p>
<p>我去 ... 这老师懂我呀! 为啥学校里这样的老师那么少呢! 于是在我和主任的多次积极的联系和要求下, 学校也慢慢地重视起来了, 这次是经过了大概一周的时间, 毕业证学位证到手了! </p>
<p>最后我想应该是学校里各位老师们都付出了很大努力把, 虽然我只知道卢老师, 田老师, 张主任等人, 但是真心感谢, 当卢老师告诉我学校批准我毕业的时候, 那真的是感动啊... 再次感谢各位老师的帮助.</p>
<h1 id="第二集-舒适圈"><a href="#第二集-舒适圈" class="headerlink" title="第二集 舒适圈?"></a>第二集 舒适圈?</h1><p>我发现自己正处在舒适圈中不想出去, 已经很久没有尝试自己不会的东西了, 基本一直在吃老本, 编写程序时也只用自己熟练的知识去实现, 没有尝试去使用自己了解但不是很熟练的新知识新技术, 总觉得这样不行, 而且自己明明都已经立誓要成为一名游戏开发者了, 却还是荒废了自己大量的时间去刷动漫, 做一些没有任何意义的事情...</p>
<p>不行, 我得开始规划自己的时间了, 对自己目标没有用的事情坚决不再做了, 刷什么魔塔, 刷什么动漫, 什么想这想那的, 都不如静下心来看本书, 钻研钻研技术.</p>
<p>最近有段时间迷上了魔塔, 虽然自己玩了好久, 但是始终得不到要领, 于是就开始看魔塔的一个基础理论, 叫做 &quot;蓝宝石转化理论&quot;, 先不说我理解了多少这个理论, 但是从这次经历我深刻的理解了看书真的是成长的捷径, 研究事物背后的理论才能成为学神, 所以我打算从现在开始利用闲余时间开始看书, 就看各种与游戏开发相关的书籍, 也开始尝试写技术类博客, 博客的内容是写下自己的想法, 而不是记笔记, 记笔记不应该使用博客, 而是使用大脑, 还有就是书籍不要怕脏, 有什么想法就直接写在书上, 书都买了, 为什么不用呢? 当初为什么没有选择借书, 不就是因为借的书不能随手记笔记嘛.</p>
<p>那么就先写到这吧, 希望未来的自己回过头来看自己这篇日记的时候能真正的成为一名学神.</p>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Github Pages 搭建个人博客</title>
    <url>/hexo/hexo_blog.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搭建个人博客的流程大概是: 先搭建博客环境, 就像你要玩电脑游戏, 首先得先买一台电脑一样. <del>这不废话吗</del> 之后在电脑上创建博客的本地文件, 最后再将创建好的本地文件上传到网上就可以了. 这里我使用的是 Hexo 和 Github Pages 来搭建个人博客. </p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><p>进入 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS8=">Git 官方网站<i class="fa fa-external-link-alt"></i></span> 下载安装即可. </p>
<p>验证方法: 在桌面右键, 只要出现 Git GUI Here 和 Git Bash Here 就表示安装成功了. </p>
<h2 id="安装-Nodejs"><a href="#安装-Nodejs" class="headerlink" title="安装 Nodejs"></a>安装 Nodejs</h2><p>进入 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">Nodejs 官方网站<i class="fa fa-external-link-alt"></i></span> 下载安装即可. </p>
<p>LTS 版本即可满足使用, 可以在 cmd 中使用 <code>node -v</code> 和 <code>npm -v</code> 进行验证, 出现版本号就说明成功了. </p>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>安装 Hexo 之前, 如果你想要更改 Hexo 的安装位置 (Hexo 默认会安装在 C 盘), 可以在 cmd 中输入下面的命令, 记得把路径改为自己的: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;H:\Programs Computer\NodeGobal&quot;</span><br><span class="line">npm config set cache &quot;H:\Programs Computer\NodeCache&quot;</span><br></pre></td></tr></table></figure>

<p>之后可以使用以下命令查看设置:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config get prefix</span><br><span class="line">npm config get cache</span><br></pre></td></tr></table></figure>

<p>先切换 npm 源: 打开 cmd, 输入下面的命令:</p>
<p><code>npm config set registry https://registry.npm.taobao.org</code></p>
<p>之后安装 Hexo: </p>
<p><code>npm install -g hexo</code></p>
<h1 id="创建本地博客"><a href="#创建本地博客" class="headerlink" title="创建本地博客"></a>创建本地博客</h1><ol>
<li>新建一个文件夹, 来放置本地博客, 名字以及路径自己决定. 我的是: F:\WorkSpace\HexoBlog</li>
<li>进入这个空的文件夹, 点击鼠标右键, 选择 Git Bash Here, 会弹出一个类似 cmd 的窗口, 这个窗口会一直使用, 不要关闭, 如果不小心关闭了, 再次回到这个文件夹中, 在空白处点击鼠标右键, 选择 Git Bash Here 即可再次打开. </li>
<li>初始化本地博客, 在 Git Bash Here 中输入: <code>hexo init</code> </li>
<li>安装默认依赖包, 在 Git Bash Here 中输入: <code>npm install</code></li>
<li>生成静态文件, 在 Git Bash Here 中输入: <code>hexo generate</code> 或者命令的缩写 <code>hexo g</code>, 此时网页就创建好了, 下面我们来预览一下博客的样子. </li>
<li>开启服务, 在 Git Bash Here 中输入 <code>hexo server</code> 或者命令的缩写 <code>hexo s</code>, 服务默认开启网址: <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAwLw==">http://localhost:4000<i class="fa fa-external-link-alt"></i></span> , 此时在浏览器中即可预览博客. </li>
</ol>
<p>【注】</p>
<ul>
<li>预览完毕后记得按 <code>Ctrl + C</code> 停止服务. </li>
<li>如果不小心按了<code>Ctrl + C</code> 停止了服务, 再次输入 <code>hexo s</code> 开启服务即可. </li>
<li>如果 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAwLw==">http://localhost:4000<i class="fa fa-external-link-alt"></i></span> 无法预览博客, 可能是 4000 端口被占用了, 我们先按 Ctrl + C 停止服务, 然后使用下面的语句切换端口:  <code>hexo server -p 端口号</code> , 这里的端口号从 4000 往上加即可, 如: 4001, 具体使用哪个不用太纠结, 可以预览博客即可. </li>
</ul>
<h1 id="关联-GitHub-和-Hexo"><a href="#关联-GitHub-和-Hexo" class="headerlink" title="关联 GitHub 和 Hexo"></a>关联 GitHub 和 Hexo</h1><p>经过前面两个步骤, 我们已经在本地创建好了博客, 也可以通过本地服务进行预览, 但是这样网页仅仅保存在本地, 网络上的人无法查看的, 此时我们就要将本地博客和 GitHub Pages 关联, 或者说上传到 GitHub 上, 这样所有人都可以查看了. </p>
<h2 id="开启-GitHub-Pages"><a href="#开启-GitHub-Pages" class="headerlink" title="开启 GitHub Pages"></a>开启 GitHub Pages</h2><p>GitHub Pages: 其本来用于介绍托管在 GitHub 上的项目, 由于它的空间免费稳定, 因此适合用来搭建个人博客, 但是有以下注意点: </p>
<ul>
<li>每个 GitHub 账号只能有一个仓库来存放个人主页, </li>
<li>仓库的名字必须是 <code>username.github.io</code>, </li>
<li>通过 <code>http://username.github.io</code> 来访问个人主页, </li>
<li>个人主页的网站内容是在 master 分支下. </li>
</ul>
<p>接下来我们创建个人主页仓库: 在 GitHub 首页右上角头像左侧的加号处, 点击: New repository, 仓库名字必须是: <code>你的 Github 用户名.github.io</code>, 下面选择 Public, 下面的选项是让你是否在仓库中初始化一个 README.md 文件, 自己随意. 最后点击创建仓库, 这样 GitHub Pages 就创建好了. </p>
<h2 id="获取-SSH-密钥"><a href="#获取-SSH-密钥" class="headerlink" title="获取 SSH 密钥"></a>获取 SSH 密钥</h2><p>至此, 我们的本地博客和 GitHub Pages 都准备好了, 下面就可以把网页部署 (上传) 到 GitHub Pages 上了. 在部署之前, 我们先设置一下 SSH 密钥. 因为如果不配置 SSH 密钥, 每次部署本地博客到 GitHub Pages 时, 都要输入 Github 账号密码, 非常繁琐. </p>
<p>获取 SSH 密钥: 如果你是第一次使用 Git, 要先配置 Git 的用户名和邮箱, 在 Git Bash Here 中输入: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;mail&quot;</span><br></pre></td></tr></table></figure>

<p>上面的 username 改成你 GitHub 的用户名, mail 改成你 GitHub 的邮箱. 之后再次输入: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;mail&quot;</span><br></pre></td></tr></table></figure>

<p>mail 要用你自己的 Github 邮箱. 回车后会依次出现三个选项, 直接全部回车即可. 这样 SSH 密钥就生成了, 接下来需要密钥填写到 GitHub 上. </p>
<p>在 C:\Users\用户名\.ssh目录中, 会出现这样两个文件: <code>id_rsa</code> 和 <code>id_rsa.pub</code></p>
<p>打开 <code>id_rsa.pub</code> 文件, 复制里面所有的内容. </p>
<p>之后打开浏览器, 登录 GitHub, 依次点击头像下的 Settings, 左面的 SSH and GPG keys, 右上角的 New SSH key, 填写标题时, 最好和你那个网页文件夹的名字一致, 方便记忆和日后查找.<br>点击 Add SSH key 并且验证 GitHub 密码, 即可完成密钥的添加. </p>
<h2 id="部署本地博客到-GitHub-Pages"><a href="#部署本地博客到-GitHub-Pages" class="headerlink" title="部署本地博客到 GitHub Pages"></a>部署本地博客到 GitHub Pages</h2><p>之前的步骤中 SSH 密钥已经设置好了, 接下来就可以部署本地博客到 Github Pages 了, 在这里不建议直接使用 Git 进行部署, 而是使用 Hexo 中的 Hexo deploy 插件进行一键式部署, 方便快捷. </p>
<p>首先要安装 Hexo deploy 插件, 还是在 Git Bash Here 中输入命令: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>之后打开网页根目录下的 _config.yml 文件, 文件的末尾是这样的: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure>

<p>修改成下面这样: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:KurohaKirito&#x2F;KurohaKirito.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>repo 就是你仓库的地址: 有 SSH 和 HTTPS 两种格式, 你选择哪种都可以. 我选择的是 SSH 格式. 在你仓库页面上点击绿色按钮 <code>Clone or download</code> 即可获得仓库地址. </p>
<p>配置完成之后, 执行部署命令, 还是在 Git Bash Here 中输入命令: <code>hexo deploy</code> 或者命令的缩写: <code>hexo d</code>, 输入 GitHub 用户名, 密码即可. </p>
<p>验证方法: 在浏览器中输入网址: <span class="exturl" data-url="aHR0cHM6Ly/nlKjmiLflkI0uZ2l0aHViLmlvLw==">https://用户名.github.io<i class="fa fa-external-link-alt"></i></span> , 用户名修改为你自己的 Github 用户名, 如果能看到之前博客的样子, 就说明部署成功了! </p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="常用-Hexo-命令"><a href="#常用-Hexo-命令" class="headerlink" title="常用 Hexo 命令"></a>常用 Hexo 命令</h2><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hexo help</td>
<td align="left">查看帮助</td>
</tr>
<tr>
<td align="left">hexo -v</td>
<td align="left">查看本地环境</td>
</tr>
<tr>
<td align="left">hexo init</td>
<td align="left">初始化 hexo 目录</td>
</tr>
<tr>
<td align="left">hexo new &quot;postName&quot;</td>
<td align="left">新建文章</td>
</tr>
<tr>
<td align="left">hexo new page &quot;pageName&quot;</td>
<td align="left">新建页面</td>
</tr>
<tr>
<td align="left">hexo gernerate</td>
<td align="left">生成网页</td>
</tr>
<tr>
<td align="left">hexo server</td>
<td align="left">本地预览</td>
</tr>
<tr>
<td align="left">hexo deploy / hexo d</td>
<td align="left">部署到远程服务器</td>
</tr>
<tr>
<td align="left">hexo clean</td>
<td align="left">清除缓存 建议每次执行命令前先清理缓存</td>
</tr>
<tr>
<td align="left">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</td>
<td align="left">一键生成部署</td>
</tr>
<tr>
<td align="left">hexo clean ; hexo g ; hexo s</td>
<td align="left">一键生成部署</td>
</tr>
</tbody></table>
<h2 id="hexo-主题"><a href="#hexo-主题" class="headerlink" title="hexo 主题"></a>hexo 主题</h2><p>下面是我搜集的一些主题及其项目开源地址: </p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1pFUk9LSVNFS0kvaGV4by10aGVtZS1nYWw=">Gal<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lzY29kZXIvaGV4by10aGVtZS1pbmRpZ28=">Indigo<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x1dW1hbi9oZXhvLXRoZW1lLXNwZms=">Spfk<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NtYWNrZ2cvaGV4by10aGVtZS1zbWFja2Rvd24=">Smackdown<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hb2NodW5ndWFuZy9ibGFjay1ibHVl">Black-blue<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NoYW5hTWFpZC9oZXhvLXRoZW1lLXNoYW5h">Shana<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdHRlbi9oZXhvLXRoZW1lLXlpbGlh">Yilia<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dpbnRlcmxhbmQxOTg5L2hleG8tdGhlbWUtd2ludGVybGFuZA==">Winterland<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlY2hsYWhvbWEvaGV4by10aGVtZS1va2Nqcw==">OKCjs<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpbmc1L2hleG8tdGhlbWUtYW5pbWFzdGFycw==">AnimaStars<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NvbmV5Y29kZS9jb25leQ==">Coney<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hzaWhvaHVhbmcva2lkZG9jaGFu">Kiddochan<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpYW5nbWluZy9sYW5kc2NhcGUtcGx1cw==">Landscapeplus<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0">NexT<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=">Hexo Themes Net<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="警告与错误的处理"><a href="#警告与错误的处理" class="headerlink" title="警告与错误的处理"></a>警告与错误的处理</h2><h3 id="Warning-LF-will-be-replaced-by-CRLF"><a href="#Warning-LF-will-be-replaced-by-CRLF" class="headerlink" title="Warning: LF will be replaced by CRLF"></a>Warning: LF will be replaced by CRLF</h3><p>问题原因: 不同操作系统所使用的换行符是不一样的: </p>
<ul>
<li><p>Unix / Linux 采用换行符 LF 表示下一行 (LF: LineFeed 换行)</p>
</li>
<li><p>Dos / Windows 采用 回车 + 换行 CRLF 表示下一行 (CRLF: CarriageReturn LineFeed 回车换行)</p>
</li>
<li><p>Mac OS 采用回车 CR 表示下一行 (CR: CarriageReturn 回车)</p>
</li>
</ul>
<p>在 Git 中, 可以通过以下命令来显示当前你的 Git 中采取哪种对待换行符的方式: </p>
<p><code>git config core.autocrlf</code></p>
<p>此命令会有三种输出: <code>true</code>, <code>false</code>, <code>input</code></p>
<ul>
<li><p>true: Git 会将你 add 的所有文件视为文本文件, 将结尾的 CRLF 转换为 LF, 而 checkout 时会再将文件的 LF 格式转为 CRLF 格式. </p>
</li>
<li><p>false: line endings 不做任何改变, 文本文件保持其原来的样子. </p>
</li>
<li><p>input: add 时 Git 会把 CRLF 转换为 LF, 而 check 时仍旧为 LF, 所以 Windows 操作系统不建议设置此值. </p>
</li>
</ul>
<p>解决办法: 将 core.autocrlf 设为 false 即可解决这个问题, 不过如果你跨平台工作的话, 还是需要考虑一下. </p>
<p>如果你想要将 core autocrlf 设置为 true , 有一个需要慎重的地方, 当你上传一个二进制文件, Git 可能会将二进制文件误以为是文本文件, 从而也会修改你的二进制文件, 从而产生隐患. </p>
<p>如果你不跨平台的话, 进行如下设置即可: <code>git config --global core.autocrlf false</code></p>
<h3 id="Error-validation-failed"><a href="#Error-validation-failed" class="headerlink" title="Error: validation failed"></a>Error: validation failed</h3><p>原因: issue 的 id 有长度限制! 最大长度限制是 50 个字符. </p>
<p>每个 issue 有两个标签, 一个是 gitment, 另一个是 id. 将 id 进行如下配置: <code>id: &#39;&lt;%= page.date %&gt;&#39;</code>, 因为日期是永远不会超出 50 个字符的. </p>
<h3 id="访问-GitHub-慢的解决方法"><a href="#访问-GitHub-慢的解决方法" class="headerlink" title="访问 GitHub 慢的解决方法"></a>访问 GitHub 慢的解决方法</h3><p>在国内 Github 网站是可以访问, 但是由于网络代理商的原因, 造成访问速度很慢. 可以通过修改本地 host 文件的办法, 可以提高访问速度: </p>
<p>打开 Windows 下 host 文件 (<code>C:\Windows\System32\drivers\etc\hosts</code>)</p>
<p>在最后面添加:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">151.101.13.194 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.113 github.com</span><br></pre></td></tr></table></figure>

<p>重启浏览器或者刷新 DNS 缓存, 告诉电脑 hosts 文件已经被修改. </p>
<p>刷新 DNS 缓存的方法: 在命令行中输入 <code>ipconfig /flushdns</code> 刷新 DNS 缓存. </p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何购买一款好的路由器</title>
    <url>/lifetips/how_to_buy_a_router.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="考虑因素一-频段与带宽"><a href="#考虑因素一-频段与带宽" class="headerlink" title="考虑因素一: 频段与带宽"></a>考虑因素一: 频段与带宽</h1><h2 id="单频-双频-三频"><a href="#单频-双频-三频" class="headerlink" title="单频, 双频, 三频"></a>单频, 双频, 三频</h2><p>早期的无线路由器只支持 2.4GHz 一个频段, 现在的主流无线路由器都支持 2.4GHz 和 5GHz 两个频段, 就是所谓的<strong>双频路由器</strong>. 也有部分高端路由器支持一个 2.4GHz 和两个 5GHz 频段, 就是<strong>三频路由器</strong>. </p>
<ul>
<li><strong>单频路由器</strong>: 只支持 2.4GHz 一个频段. </li>
<li><strong>双频路由器</strong>: 支持一个 2.4GHz 和一个 5Ghz 共两个频段. </li>
<li><strong>三频路由器</strong>: 支持一个 2.4GHz 和两个 5GHz 共三个频段. </li>
</ul>
<h2 id="2-4GHz-和-5GHz-两种频段各自的优缺点"><a href="#2-4GHz-和-5GHz-两种频段各自的优缺点" class="headerlink" title="2.4GHz 和 5GHz 两种频段各自的优缺点"></a>2.4GHz 和 5GHz 两种频段各自的优缺点</h2><h3 id="电磁波的物理特性是-quot-波长越长-传播过程中的衰减越少-quot"><a href="#电磁波的物理特性是-quot-波长越长-传播过程中的衰减越少-quot" class="headerlink" title="电磁波的物理特性是 &quot;波长越长, 传播过程中的衰减越少&quot;"></a>电磁波的物理特性是 &quot;波长越长, 传播过程中的衰减越少&quot;</h3><p>2.4GHz 的信号波长长, 所以<strong>衍射</strong>和<strong>反射</strong>能力很强, 在室内环境下比 5GHz 的信号覆盖的范围更广, 也就是常说的<strong>穿墙能力强</strong>. 缺点是目前工作在这个频段的设备太多, 相互干扰比较严重, 大家互相抢占带宽, 速度会比较慢. </p>
<p>5GHz 的信号波长短, 所以在与路由器相同距离的情况下, 5GHz 的信号强度比 2.4GHz 的信号强度弱.  但是, 由于 5GHz 支持新的通信协议并且目前工作在这个频段的设备较少, 所以速度要快很多. </p>
<p><img data-src="/images/how_to_buy_a_router/how_to_buy_a_router_1.png" alt="2.4GHz 和 5GHz"></p>
<p>由此可以得出结论:<br><font color='red'>**信号强速度就快是不对的! **</font></p>
<p>比如一个有 2 格信号的 5GHz WIFI 和一个有 4 格信号的 2.4GHz WIFI, 那么 4 格信号的 WIFI 速度就比 2 格信号的 WIFI 速度快. 这是不对的! 不对的! 不对的! </p>
<h2 id="带宽是-quot-信道的宽度-quot"><a href="#带宽是-quot-信道的宽度-quot" class="headerlink" title="带宽是 &quot;信道的宽度&quot;"></a>带宽是 &quot;信道的宽度&quot;</h2><p>因为有一些协议支持将相邻的信道绑在一起以增加带宽(信道宽度), 所以不同协议下的带宽(信道宽度)有所不同. 再加上高通公司还出了 QAM 技术, 也会增加带宽(信道宽度), 所以带宽(信道宽度)要具体情况具体分析. 
 </p>
<h1 id="考虑因素二-协议"><a href="#考虑因素二-协议" class="headerlink" title="考虑因素二: 协议"></a>考虑因素二: 协议</h1><h2 id="IEEE-802-11-协议簇是用于无线局域网通用的标准"><a href="#IEEE-802-11-协议簇是用于无线局域网通用的标准" class="headerlink" title="IEEE 802.11 协议簇是用于无线局域网通用的标准."></a>IEEE 802.11 协议簇是用于无线局域网通用的标准.</h2><p>常用的协议包括: </p>
<ul>
<li><strong>802.11a</strong>: 工作频率为 5GHz, 最大原始数据传输率为 54Mb/s. </li>
<li><strong>802.11b</strong>: 其载波的频率为 2.4GHz, 可提供 1, 2, 5.5 及 11Mbit/s 的多重传送速度. </li>
<li><strong>802.11g</strong>: 其载波的频率为 2.4GHz（跟802.11b相同）, 共14个频段, 原始传送速度为 54Mbit/s, 净传输速度约为 24.7Mbit/s（跟802.11a相同）. 802.11g 的设备向下与 802.11b 兼容. </li>
<li><strong>802.11n</strong>: 增加了对 MIMO (多用户输入多用户输出) 的支持, 允许 40MHz 的无线频宽, 最大传输速度理论值为 600Mbit/s. </li>
<li><strong>802.11ac</strong>: 通过 5GHz 频带进行无线局域网通信. 理论上: </li>
<li><ul>
<li>1: 进行多站式无线通信, 它能够提供最少每秒 1 Gbit/s 的带宽. </li>
</ul>
</li>
<li><ul>
<li>2: 进行单信道无线通信, 它能够提供最少每秒 500 Mbit/s 的带宽. </li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">协议</th>
<th align="right">常见速率(单信道)</th>
<th align="center">2.4GHZ</th>
<th align="center">5GHZ</th>
</tr>
</thead>
<tbody><tr>
<td align="left">802.11a</td>
<td align="right">54 Mbit/s</td>
<td align="center"></td>
<td align="center">支持</td>
</tr>
<tr>
<td align="left">802.11b</td>
<td align="right">11 Mbit/s</td>
<td align="center">支持</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">802.11g</td>
<td align="right">54 Mbit/s</td>
<td align="center">支持</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">802.11n</td>
<td align="right">72.2 Mbit/s</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="left">802.11ac</td>
<td align="right">433.3 Mbit/s</td>
<td align="center"></td>
<td align="center">支持</td>
</tr>
</tbody></table>
<h1 id="考虑因素三-SU-MIMO-和-MU-MIMO"><a href="#考虑因素三-SU-MIMO-和-MU-MIMO" class="headerlink" title="考虑因素三: SU-MIMO 和 MU-MIMO"></a>考虑因素三: SU-MIMO 和 MU-MIMO</h1><ul>
<li><p><strong>SU-MIMO</strong> 是 Single-User Multiple-Input Multiple-Output 的缩写, 即: <strong>单用户多输入多输出技术</strong>. 简称 MIMO, 即:  Multiple-Input Multiple-Output, 多输入多输出技术. 能利用发射端的多个天线各自独立发送信号, 同时在接收端用多个天线接收并恢复原信息. </p>
</li>
<li><p>MIMO 技术可以成倍地增加带宽. 假设发射端和接收端都有一组天线, 记做 1x1, 此时的带宽为 x. 那么如果发射端和接收端各有 2 组天线, 且都支持MIMO, 记做 2x2, 那么此时的带宽就变成了 2x. </p>
</li>
<li><p>MIMO 也包含旧的 SIMO（单输入多输出系统）和 MISO（多输入单输出系统）. SIMO 和 MISO 的好处是可以增加信号的灵敏度. </p>
</li>
<li><p><strong>MU-MIMO</strong> 是 Multi-User Multiple-Input Multiple-Output 的缩写, 即: <strong>多用户多输入多输出技术</strong>. 只有 802.11ac Wave 2 及以上协议才支持的一种技术, 可以让路由器同时和多个终端建立联系, 并且做到多个终端互不干扰, 最重要的是只需发射端支持即可. </p>
</li>
<li><p>【注】SU-MIMO 路由器每次只连接一个设备, 但它会在所有的连接设备中快速的切换, 给人一种好像同时连接了多个设备一样, 但其实同一时刻只连接一个设备. 而 MU-MIMO 路由器就可以真正地做到同时连接多个设备. </p>
</li>
</ul>
<h1 id="考虑因素四-调制方式"><a href="#考虑因素四-调制方式" class="headerlink" title="考虑因素四: 调制方式"></a>考虑因素四: 调制方式</h1><h2 id="正交幅度调制-QAM-即-Quadrature-Amplitude-Modulation"><a href="#正交幅度调制-QAM-即-Quadrature-Amplitude-Modulation" class="headerlink" title="正交幅度调制: QAM 即: Quadrature Amplitude Modulation"></a>正交幅度调制: QAM 即: Quadrature Amplitude Modulation</h2><p>正交幅度调制 (QAM) 即: Quadrature Amplitude Modulation, 它是一种在两个正交载波上进行幅度调制的调制方式. 这两个载波通常是相位差为 π/2 的正弦波, 因此被称作正交载波. </p>
<ul>
<li>802.11n 使用 64-QAM 在 40MHz 带宽下速率可以达到 150Mb/s. </li>
<li>802.11ac 使用 256-QAM 在 80MHz 带宽下速率可以达到 433.3Mb/s. </li>
</ul>
<p>高通推出了一种调制方案: </p>
<ul>
<li><p>对 802.11n 协议的信号进行 256-QAM 调制, 突破了协议限制的最高速率, 可以达到 200M, 称为 Turbo QAM. </p>
</li>
<li><p>对802.11ac 协议信号进行 1024-QAM 调制, 突破了协议限制的最高速率, 可达到 541.7M, 称为 Nitro QAM. </p>
</li>
</ul>
<p>要使用这种技术, 需要<strong>发射端</strong>和<strong>接收端</strong>都支持才可以. </p>
<h1 id="部分-TP-Link-路由器参数"><a href="#部分-TP-Link-路由器参数" class="headerlink" title="部分 TP-Link 路由器参数"></a>部分 TP-Link 路由器参数</h1><table>
<thead>
<tr>
<th align="left">型号</th>
<th align="center">MU-MIMO</th>
<th align="center">Turbo QAM</th>
<th align="center">千兆</th>
<th align="center">2.4G 天线</th>
<th align="center">5G 天线</th>
<th align="right">2.4G 带宽</th>
<th align="right">5G 带宽</th>
<th align="right">实际带宽</th>
<th align="right">宣传带宽</th>
</tr>
</thead>
<tbody><tr>
<td align="left">WR742N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="right">150 Mb/s</td>
<td align="right">0 Mb/s</td>
<td align="right">150 Mb/s</td>
<td align="right">150 Mb/s</td>
</tr>
<tr>
<td align="left">WR890N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="right">450 Mb/s</td>
<td align="right">0 Mb/s</td>
<td align="right">450 Mb/s</td>
<td align="right">450 Mb/s</td>
</tr>
<tr>
<td align="left">WDR5600</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="right">450 Mb/s</td>
<td align="right">433 Mb/s</td>
<td align="right">889 Mb/s</td>
<td align="right">900 Mb/s</td>
</tr>
<tr>
<td align="left">WDR6300</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="right">300 Mb/s</td>
<td align="right">433X2 Mb/s</td>
<td align="right">1166 Mb/s</td>
<td align="right">1200 Mb/s</td>
</tr>
<tr>
<td align="left">WDR6500</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="right">450 Mb/s</td>
<td align="right">433X2 Mb/s</td>
<td align="right">1316 Mb/s</td>
<td align="right">1300 Mb/s</td>
</tr>
<tr>
<td align="left">WDR7500</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="right">450 Mb/s</td>
<td align="right">433X3 Mb/s</td>
<td align="right">1749 Mb/s</td>
<td align="right">1750 Mb/s</td>
</tr>
<tr>
<td align="left">WDR8500</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="right">450 Mb/s</td>
<td align="right">433X4 Mb/s</td>
<td align="right">2182 Mb/s</td>
<td align="right">2200 Mb/s</td>
</tr>
<tr>
<td align="left">WDR8600</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="right">800 Mb/s</td>
<td align="right">433X4 Mb/s</td>
<td align="right">2532 Mb/s</td>
<td align="right">2600 Mb/s</td>
</tr>
</tbody></table>
<h1 id="总结-如何选择路由器"><a href="#总结-如何选择路由器" class="headerlink" title="总结: 如何选择路由器"></a>总结: 如何选择路由器</h1><h2 id="宽带速度"><a href="#宽带速度" class="headerlink" title="宽带速度"></a>宽带速度</h2><ul>
<li>如果宽带速度大于 100Mb/s, 就一定要选择具有千兆有线接口的路由器. </li>
<li>如果有 NAS 这种需要高速连接的设备, 也要选择具有千兆有线接口的路由器. </li>
<li>【注】现在的路由器都宣称 &quot;千兆路由&quot;, 这个<strong>千兆</strong>其实指的是无线速度, 就是从路由器向终端设备传输的速度. 但是我们这里所说的 &quot;千兆&quot; 是指有线速度, 从光猫向路由器传输的速度, 就是 WAN 口和 LAN 口的速度. </li>
</ul>
<p><img data-src="/images/how_to_buy_a_router/how_to_buy_a_router_2.png" alt="&quot;千兆路由&quot; 与 千兆路由"></p>
<p>如上图左面这一款路由器, 它只有无线支持千兆, 但是有线并不支持千兆, 这样其实是没啥用的. 假设你家里网线的带宽为 200 Mb/s, 那么其中 100 Mb/s 的带宽就浪费掉了, 因为路由器的有线接口并不支持千兆. 因此我们需要购买千兆路由的话, 自然要选择右面这一款. </p>
<h2 id="无线频段"><a href="#无线频段" class="headerlink" title="无线频段"></a>无线频段</h2><ul>
<li><strong>双频路由</strong>: 这是目前市场的主流, 支持 802.11ac 的终端也越来越多, 所以推荐购买双频路由. </li>
<li><strong>三频路由</strong>: 现在这种还算是新产品, 价格昂贵! 所以......</li>
<li><strong>单频路由</strong>: 除非特别原因已经不推荐购买了. </li>
</ul>
<h2 id="千万不要一味追求高端"><a href="#千万不要一味追求高端" class="headerlink" title="千万不要一味追求高端"></a>千万不要一味追求高端</h2><h3 id="路由器在实际使用中是很难达到理论最高速度的"><a href="#路由器在实际使用中是很难达到理论最高速度的" class="headerlink" title="路由器在实际使用中是很难达到理论最高速度的."></a>路由器在实际使用中是很难达到理论最高速度的.</h3><ul>
<li>因为会有其他无线路由器的信号干扰</li>
<li>因为终端设备 (手机, 空调, 冰箱, 电脑等可以连接路由器 WiFi 的设备) 并没有那么多组天线支持 MIMO. 一般来说低端手机是 1 组天线, iPhone 是2 组, iMac 和一些高端笔记本是 3 组, 支持 4 组天线的终端屈指可数.<br>所以根本没有必要刻意追求高端路由器, 一般来说 2.4GHz 和 5GHz 各有 2 组天线, 即标称 1200M 的路由器已经足够一般家庭日常使用. </li>
<li>若终端多, 则可以适度提高选购型号<br>因为高端路由内存大, CPU 性能好, 能够保证在多个设备连接的场景下也不会卡顿. </li>
</ul>
<h1 id="噱头-常见误区"><a href="#噱头-常见误区" class="headerlink" title="噱头 (常见误区)"></a>噱头 (常见误区)</h1><h2 id="天线内置与外置"><a href="#天线内置与外置" class="headerlink" title="天线内置与外置! ?"></a>天线内置与外置! ?</h2><p>结论1: <font color='red'><strong>天线内置或外置并不影响信号的强度</strong></font></p>
<p>国内市场消费者更倾向于购买多外置天线的路由器, 动辄 6 个以上外置天线. 在这点上 TP-Link 品牌尤其明显. 其在国内的产品, 300 元就能做到外置 6 天线, 而其在国外的产品, 价格 2000+ 的高端产品也只是 3 个可见的外置天线. 但显然后者的信号更强, 更稳. </p>
<p>结论2: <font color='red'><strong>外置天线的数量和信号的强度没有正相关</strong></font></p>
<p>结论3: <font color='red'><strong>全部天线的数量和信号的强度正相关 ( 天线数量 = 内置天线数量 + 外置天线数量 )</strong></font></p>
<p><img data-src="/images/how_to_buy_a_router/how_to_buy_a_router_3.png" alt="外置天线的数量和信号的强度没有正相关"></p>
<h2 id="USB-接口"><a href="#USB-接口" class="headerlink" title="USB 接口! ?"></a>USB 接口! ?</h2><p>这个通常出现在中高端路由器上, 一般是用来接存储设备或打印设备的. </p>
<p>考虑到我国家庭的打印机保有量, 就不提打印设备了. 大家一般都是挂移动硬盘来下载电影, 起到一个低端 NAS 的作用. </p>
<p>但由于路由器的芯片计算能力比较差, 通常 IO 性能都比较弱. 甚至有些路由器由于设计问题, USB3.0 接口太靠近 2.4GHz 天线, 反而影响了 2.4GHz 信号, 这就有点得不偿失了. </p>
<p>结论4: <font color='red'>**目前 USB 接口功能纯属画蛇添足! **</font></p>
<h2 id="智能路由"><a href="#智能路由" class="headerlink" title="智能路由! ?"></a>智能路由! ?</h2><p>路由器其实可以看做是一个嵌入式系统, 一般来说, 这个系统在出厂预装后就很少再有更新, 厂商也很少升级. </p>
<p>在某个事件后, 大神们明白了路由器的系统是如何操作路由器硬件的, 于是就有了第三方固件. 第三方固件的好处是可以支持更多的功能, 比如去广告, 科学上网等. 常见的第三方固件有 <strong>openwrt padavan ddwrt</strong> 等. 通常来说刷第三方固件都会让你的路由变得不稳定, 但是如果你是魔法师的话, 还有什么可畏惧的呢. </p>
<p>因此目前国内市场上的一些所谓 &quot;智能路由&quot;, 都是基于 openwrt 系统, 加上一些插件和管理 APP 而已. 本质上就是 &quot;非智能路由&quot; 刷了第三方固件而已, 你可以近似理解为安卓手机的刷机, 苹果手机的越狱. </p>
<p>结论5: <font color='red'>**智能路由? 对于爱折腾的人来说, 这就是在浪费钱, 对于不爱折腾的人来说, 这就是一个扣分项. **</font></p>
]]></content>
      <categories>
        <category>LifeTips</category>
      </categories>
      <tags>
        <tag>生活知识</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 MPV 播放器</title>
    <url>/lifetips/how_to_use_mpv_player.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="播放器简介"><a href="#播放器简介" class="headerlink" title="播放器简介"></a>播放器简介</h1><p>默认情况下, MPV 播放器并不提供 GUI 界面, 需要通过命令行或配置文件进行设置, 它配置灵活, 性能优秀, 支持硬件解码. </p>
<p>基于开源, MPV 衍生出来一大批第三方播放器, 比如 Mac 平台上的 IINA, 以及 Baka MPlayer, bomi, mpc-qt, xt7-player-mpv 等, 它们的核心都是 MPV. </p>
<h1 id="播放列表"><a href="#播放列表" class="headerlink" title="播放列表"></a>播放列表</h1><ol>
<li>MPV 支持播放列表文件 (如: m3u). </li>
<li>如果需要临时播放多个文件, 打开MPV, 选中多个文件拖入窗口. </li>
<li>鼠标右键单击 上一个 或者 下一个 按钮可以临时显示当前播放列表. </li>
<li>如果需要将该目录的所有文件全部添加进 MPV 的播放列表中, 使用命令: <code>mpv *.*</code></li>
</ol>
<h1 id="文件关联"><a href="#文件关联" class="headerlink" title="文件关联"></a>文件关联</h1><ol>
<li><p>解压 <code>mpv-install-master.zip</code> 文件, 这里是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Jvc3N5L21wdi1pbnN0YWxsL2FyY2hpdmUvbWFzdGVyLnppcA==">下载地址<i class="fa fa-external-link-alt"></i></span>. </p>
</li>
<li><p>将三个文件（<code>mpv-document</code>, <code>mpv-install.bat</code>, <code>mpv-uninstall.bat</code>）移动到自定义的 MPV 程序目录下. </p>
</li>
<li><p>以管理员身份运行 <code>mpv-install.bat</code> 进行文件关联. <code>mpv-uninstall.bat</code> 则是用来解除文件关联的. </p>
</li>
<li><p>没做第 3 步之前, 进入 Win10 Setting 设置默认应用时, 会找不到 MPV, 做完第 3 步之后就可以进入 Win10 Setting 设置默认应用了. </p>
</li>
</ol>
<h1 id="快捷键-区分大小写"><a href="#快捷键-区分大小写" class="headerlink" title="快捷键 (区分大小写)"></a>快捷键 (<font color=red>区分大小写</font>)</h1><h2 id="播放控制"><a href="#播放控制" class="headerlink" title="播放控制"></a>播放控制</h2><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">快捷键</th>
<th align="right">作用说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">p</td>
<td align="center">Space</td>
<td align="right">暂停, 继续播放</td>
</tr>
<tr>
<td align="center">Num/</td>
<td align="center">Num*</td>
<td align="right">减少音量 / 增加音量</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">0</td>
<td align="right">减少音量 / 增加音量</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center"></td>
<td align="right">静音</td>
</tr>
<tr>
<td align="center">←</td>
<td align="center">→</td>
<td align="right">快退 / 快进 5 秒</td>
</tr>
<tr>
<td align="center">↑</td>
<td align="center">↓</td>
<td align="right">快进 / 快退 1 分钟</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">&gt;</td>
<td align="right">上一个 / 下一个（播放列表中）</td>
</tr>
<tr>
<td align="center">Enter</td>
<td align="center"></td>
<td align="right">下一个（播放列表中）</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center"></td>
<td align="right">设定 / 清除 A - B 循环点</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center"></td>
<td align="right">循环播放</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center"></td>
<td align="right">对本机画面进行全屏截图</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center"></td>
<td align="right">对源画面进行全屏截图</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center"></td>
<td align="right">停止播放并退出</td>
</tr>
<tr>
<td align="center">Q</td>
<td align="center"></td>
<td align="right">保存当前播放进度并退出</td>
</tr>
</tbody></table>
<h2 id="视频音频控制"><a href="#视频音频控制" class="headerlink" title="视频音频控制"></a>视频音频控制</h2><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">快捷键</th>
<th align="right">作用说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_</td>
<td align="center"></td>
<td align="right">循环切换可用视频轨</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center"></td>
<td align="right">循环切换视频画面比例</td>
</tr>
<tr>
<td align="center">Alt+0</td>
<td align="center"></td>
<td align="right">0.5倍源视频画面大小</td>
</tr>
<tr>
<td align="center">Alt+1</td>
<td align="center"></td>
<td align="right">1倍源视频画面大小</td>
</tr>
<tr>
<td align="center">Alt+2</td>
<td align="center"></td>
<td align="right">2倍源视频画面大小</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center"></td>
<td align="right">循环切换可用音频轨</td>
</tr>
<tr>
<td align="center">Ctrl +</td>
<td align="center">Ctrl -</td>
<td align="right">音轨延迟+/- 0.1秒</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center"></td>
<td align="right">下一帧</td>
</tr>
<tr>
<td align="center">,</td>
<td align="center"></td>
<td align="right">上一帧</td>
</tr>
</tbody></table>
<h2 id="字幕控制"><a href="#字幕控制" class="headerlink" title="字幕控制"></a>字幕控制</h2><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">快捷键</th>
<th align="right">作用说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">V</td>
<td align="center"></td>
<td align="right">开启/关闭字幕</td>
</tr>
<tr>
<td align="center">j</td>
<td align="center">J</td>
<td align="right">循环切换可用字幕轨</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">z</td>
<td align="right">字幕时间轴 + / - 0.1 秒</td>
</tr>
<tr>
<td align="center">r</td>
<td align="center">t</td>
<td align="right">上移/下移字幕位置</td>
</tr>
</tbody></table>
<h2 id="窗口控制"><a href="#窗口控制" class="headerlink" title="窗口控制"></a>窗口控制</h2><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="right">作用说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">f</td>
<td align="right">进入/退出全屏</td>
</tr>
<tr>
<td align="center">ESC</td>
<td align="right">退出全屏</td>
</tr>
</tbody></table>
<h2 id="播放速度控制"><a href="#播放速度控制" class="headerlink" title="播放速度控制"></a>播放速度控制</h2><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="right">作用说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[</td>
<td align="right">0.9倍慢速播放</td>
</tr>
<tr>
<td align="center">]</td>
<td align="right">1.1倍快速播放</td>
</tr>
<tr>
<td align="center">{</td>
<td align="right">0.5倍慢速播放</td>
</tr>
<tr>
<td align="center">}</td>
<td align="right">2.0倍快速播放</td>
</tr>
<tr>
<td align="center">Backspace</td>
<td align="right">重置为正常播放速度</td>
</tr>
</tbody></table>
<h2 id="色彩调节"><a href="#色彩调节" class="headerlink" title="色彩调节"></a>色彩调节</h2><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">快捷键</th>
<th align="right">作用说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="right">对比度-/+</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">4</td>
<td align="right">亮度-/+</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">6</td>
<td align="right">伽马-/+</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">8</td>
<td align="right">饱和度-/+</td>
</tr>
</tbody></table>
<h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">快捷键</th>
<th align="right">作用说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">s</td>
<td align="center">S</td>
<td align="right">包含 / 不包含字幕进行截图</td>
</tr>
<tr>
<td align="center">i</td>
<td align="center"></td>
<td align="right">显示视频的详情参数</td>
</tr>
</tbody></table>
<h1 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h1><h2 id="程序配置文件路径"><a href="#程序配置文件路径" class="headerlink" title="程序配置文件路径"></a>程序配置文件路径</h2><p><code>C:\Users\Kirito\AppData\Roaming\mpv\mpv.conf</code></p>
<h2 id="快捷键配置文件路径"><a href="#快捷键配置文件路径" class="headerlink" title="快捷键配置文件路径"></a>快捷键配置文件路径</h2><p><code>C:\Users\Kirito\AppData\Roaming\mpv\input.conf</code></p>
<p>下面是我的自定义快捷键设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 鼠标滑轮调节音量</span></span><br><span class="line"><span class="string">WHEEL_UP</span> <span class="string">add</span> <span class="string">volume</span> <span class="number">1</span></span><br><span class="line"><span class="string">WHEEL_DOWN</span> <span class="string">add</span> <span class="string">volume</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等号键循环切换窗口置顶</span></span><br><span class="line"><span class="string">=</span> <span class="string">cycle</span> <span class="string">ontop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alt + 方向键旋转画面 (依赖 cycle-video-rotate.lua 脚本)</span></span><br><span class="line"><span class="string">alt+left</span> <span class="string">script-message</span> <span class="string">Cycle_Video_Rotate</span> <span class="number">-90</span></span><br><span class="line"><span class="string">alt+right</span> <span class="string">script-message</span> <span class="string">Cycle_Video_Rotate</span> <span class="number">90</span></span><br></pre></td></tr></table></figure>

<h2 id="脚本文件路径"><a href="#脚本文件路径" class="headerlink" title="脚本文件路径"></a>脚本文件路径</h2><p><code>C:\Users\Kirito\AppData\Roaming\mpv\scripts\...</code></p>
<p>脚本是 MPV 配置的重头戏. MPV 启动时, 保存在 scripts 文件夹里的脚本文件会自动加载并且执行. 官方 wiki 里有收录的脚本列表, 可以自行查阅, 寻找自己喜欢的功能脚本. </p>
<h1 id="脚本推荐"><a href="#脚本推荐" class="headerlink" title="脚本推荐"></a>脚本推荐</h1><h2 id="autoload-lua"><a href="#autoload-lua" class="headerlink" title="autoload.lua"></a>autoload.lua</h2><p>autoload.lua: 自动加载当前播放文件目录里的视频文件到播放列表, 也就是自动连播, 原生 MPV 不具有这个功能. </p>
<h2 id="mpv-thumbnail-script-lua"><a href="#mpv-thumbnail-script-lua" class="headerlink" title="mpv_thumbnail_script.lua"></a>mpv_thumbnail_script.lua</h2><p>mpv_thumbnail_script.lua: 生成并显示预览缩略图. </p>
<h2 id="save-sub-delay-lua"><a href="#save-sub-delay-lua" class="headerlink" title="save-sub-delay.lua"></a>save-sub-delay.lua</h2><p>save-sub-delay.lua: 遇到外挂字幕时间轴不正确的情况, 调好之后, 这个脚本会保存 delay 信息. </p>
<h2 id="cycle-video-rotate-lua"><a href="#cycle-video-rotate-lua" class="headerlink" title="cycle-video-rotate.lua"></a>cycle-video-rotate.lua</h2><p>cycle-video-rotate.lua: 实现旋转屏幕效果.</p>
<h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>脚本下载地址: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1ZpZGVvUGxheWVyQ29kZS9tcHYtdG9vbHM=">Github MPV Tools<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>LifeTips</category>
      </categories>
      <tags>
        <tag>MPV</tag>
      </tags>
  </entry>
  <entry>
    <title>学习社会保险制度</title>
    <url>/lifetips/social_insurance.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="社会保险的结构构成"><a href="#社会保险的结构构成" class="headerlink" title="社会保险的结构构成"></a>社会保险的结构构成</h1><blockquote>
<p>注: 由于后续政策可能变动, 所以在阅读本文之前, 请注意文章的最新更新时间. </p>
</blockquote>
<p>直接上图: </p>
<p><img data-src="/images/social_insurance/Social_Insurance.png" alt="保险的构成"></p>
<ul>
<li><p>&quot;社会保险&quot; 简称 &quot;社保&quot;, &quot;城镇职工社会保险&quot; 简称 &quot;职保&quot;, &quot;城乡居民社会保险&quot; 简称 &quot;居保&quot;. </p>
</li>
<li><p>&quot;社保&quot; 一词非常广泛, 内部包含 7 种社会保险. </p>
</li>
<li><p>&quot;社保&quot; 分为两个大类: 一个是针对就业群体的 &quot;职保&quot;, 另一个是针对无业人群的 &quot;居保&quot;. </p>
</li>
<li><p>&quot;职保&quot; 全称: &quot;城镇职工社会保险&quot;, 它包含五种保险: &quot;城镇职工基本养老保险&quot;, &quot;城镇职工基本医疗保险&quot;, &quot;城镇职工失业保险&quot;, &quot;城镇职工工伤保险&quot;, &quot;城镇职工生育保险&quot;. </p>
</li>
<li><p>&quot;居保&quot; 全称: &quot;城乡居民社会保险&quot;, 它只包含两种保险: &quot;城乡居民基本养老保险&quot; 和 &quot;城乡居民基本医疗保险&quot;. 由于 &quot;失业保险&quot;, &quot;工伤保险&quot;, &quot;生育保险&quot; 都是和工作息息相关的, 所以 &quot;居保&quot; 自然不包含这三种保险. </p>
</li>
<li><p>&quot;医保&quot; 一词非常容易混淆, 它指代两种保险: &quot;城镇职工基本医疗保险&quot; 和 &quot;城乡居民基本医疗保险&quot;, 不同情况下要弄清具体含义. </p>
</li>
</ul>
<h2 id="城镇职工基本养老保险"><a href="#城镇职工基本养老保险" class="headerlink" title="城镇职工基本养老保险"></a>城镇职工基本养老保险</h2><ul>
<li><p>&quot;城镇职工基本养老保险&quot; 的目的是保障我们年迈退休后的基本生活需求, 为我们提供稳定可靠的生活经济来源. </p>
</li>
<li><p>&quot;城镇职工基本养老保险&quot; 是由企业和我们按照不同的缴费比例共同缴纳费用的. <font color=red>按月缴纳</font>. </p>
</li>
<li><p>&quot;城镇职工基本养老保险&quot; 的待遇是当我们退休后可以领取到养老金. (有前提条件)</p>
</li>
</ul>
<h2 id="城镇职工基本医疗保险"><a href="#城镇职工基本医疗保险" class="headerlink" title="城镇职工基本医疗保险"></a>城镇职工基本医疗保险</h2><ul>
<li><p>&quot;城镇职工基本医疗保险&quot; 简称 &quot;医保&quot;. </p>
</li>
<li><p>&quot;城镇职工基本医疗保险&quot; 的目的是减轻我们生活中因患病或受伤害而带来的医疗开销. </p>
</li>
<li><p>&quot;城镇职工基本医疗保险&quot; 也是由企业和我们按照不同的缴费比例共同缴纳费用的. <font color=red>按月缴纳</font>. </p>
</li>
<li><p>&quot;城镇职工基本医疗保险&quot; 的待遇是当我们患病并去医疗机构就诊而发生医疗费用后, 由医疗保险机构给予一定的经济补偿. </p>
</li>
</ul>
<h2 id="城镇职工失业保险"><a href="#城镇职工失业保险" class="headerlink" title="城镇职工失业保险"></a>城镇职工失业保险</h2><ul>
<li><p>&quot;城镇职工失业保险&quot; 的目的是为那些因失业而暂时中断生活经济来源的劳动者提供物质帮助以保障其基本生活, 并通过专业训练, 职业介绍等手段为其再就业创造条件. </p>
</li>
<li><p>&quot;城镇职工失业保险&quot; 也是由企业和我们按照不同的缴费比例共同缴纳费用的. <font color=red>按月缴纳</font>. </p>
</li>
<li><p>&quot;城镇职工失业保险&quot; 的最主要待遇是当我们失业时可以领取到失业保险金. (有前提条件)</p>
</li>
</ul>
<h2 id="城镇职工工伤保险"><a href="#城镇职工工伤保险" class="headerlink" title="城镇职工工伤保险"></a>城镇职工工伤保险</h2><ul>
<li><p>&quot;城镇职工工伤保险&quot; 是指劳动者在工作中或在规定的特殊情况下, 遭受意外伤害或患职业病导致暂时或永久丧失劳动能力甚至死亡时, 劳动者或其遗属从国家和社会获得物质帮助的一种社会保险制度. </p>
</li>
<li><p>&quot;城镇职工保险&quot; 生效的认定办法: 工伤保险实行无过错责任原则. 无论工伤事故的责任归于用人单位还是职工个人或第三者, 用人单位均应承担保险责任. </p>
</li>
<li><p>&quot;城镇职工工伤保险&quot; 的缴费: 劳动者不缴纳工伤保险费, <font color = red>全部费用由用人单位负担, 按月缴纳</font>. </p>
</li>
<li><p>&quot;城镇职工工伤保险&quot; 的待遇是当我们因工负伤或职业病暂时或永久失去劳动能力以及死亡时, 可以获得工伤保险金. </p>
</li>
</ul>
<h2 id="城镇职工生育保险"><a href="#城镇职工生育保险" class="headerlink" title="城镇职工生育保险"></a>城镇职工生育保险</h2><ul>
<li><p>&quot;城镇职工生育保险&quot; 是在劳动者因生育子女而导致劳动力暂时中断时, 由国家和社会及时给予物质帮助的一项社会保险制度. </p>
</li>
<li><p>&quot;城镇职工生育保险&quot; 的缴费: 劳动者不缴纳生育保险费, <font color = red>全部费用由用人单位负担, 按月缴纳</font>. </p>
</li>
<li><p>&quot;城镇职工生育保险&quot; 的待遇主要包括两项: 一是生育津贴, 二是生育医疗待遇. </p>
</li>
</ul>
<h2 id="城乡居民基本养老保险"><a href="#城乡居民基本养老保险" class="headerlink" title="城乡居民基本养老保险"></a>城乡居民基本养老保险</h2><ul>
<li><p>&quot;城乡居民基本养老保险&quot; 的目的是保障城镇老年居民和乡村老年居民的基本生活需求, 为他们提供稳定可靠的生活经济来源. </p>
</li>
<li><p>&quot;城乡居民基本养老保险&quot; 的缴费是自选档次进行缴费, 档次越高费用越高, 国家补贴一部分费用. <font color=red>按年缴纳</font>. </p>
</li>
<li><p>&quot;城乡居民基本养老保险&quot; 的待遇也是可以领取到养老金, 采用多缴多得原则, 年轻时上缴的总金额越多, 年迈时领取到的养老金也就越多. (有前提条件))</p>
</li>
</ul>
<h2 id="城乡居民基本医疗保险"><a href="#城乡居民基本医疗保险" class="headerlink" title="城乡居民基本医疗保险"></a>城乡居民基本医疗保险</h2><ul>
<li><p>&quot;城乡居民基本医疗保险&quot; 也简称 &quot;医保&quot;, 医保是最需要大家关注的保险, 应当深入了解学习. </p>
</li>
<li><p>&quot;城乡居民基本医疗保险&quot; 的目的是减轻城镇居民和乡村居民因患病或受伤害而带来的医疗开销. </p>
</li>
<li><p>&quot;城乡居民基本医疗保险&quot; 的缴费也是自选档次进行缴费, 档次越高费用越高, 国家补贴一部分费用. <font color=red>按年缴纳</font>. </p>
</li>
<li><p>&quot;城乡居民基本医疗保险&quot; 的待遇也是当我们患病并去医疗机构就诊而发生医疗费用后, 由医疗保险机构给予一定的经济补偿, 但是报销比例比起 &quot;城镇职工基本医疗保险&quot; 要低一些.</p>
</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="我只是一个农民-我想知道我一直缴纳的-quot-社保-quot-是什么"><a href="#我只是一个农民-我想知道我一直缴纳的-quot-社保-quot-是什么" class="headerlink" title="我只是一个农民, 我想知道我一直缴纳的 &quot;社保&quot; 是什么?"></a>我只是一个农民, 我想知道我一直缴纳的 &quot;社保&quot; 是什么?</h2><p>农民不属于职工, 所以农民所缴纳的社保就是指 &quot;城乡居民社会保险&quot;, 包含 &quot;城乡居民基本养老保险&quot; 和 &quot;城乡居民基本医疗保险&quot; 两种. </p>
<h2 id="我现在只是一名学生-既不是失业-也不是就业-那么我一直缴纳的-quot-社保-quot-是什么"><a href="#我现在只是一名学生-既不是失业-也不是就业-那么我一直缴纳的-quot-社保-quot-是什么" class="headerlink" title="我现在只是一名学生, 既不是失业, 也不是就业, 那么我一直缴纳的 &quot;社保&quot; 是什么?"></a>我现在只是一名学生, 既不是失业, 也不是就业, 那么我一直缴纳的 &quot;社保&quot; 是什么?</h2><p>学生也不属于职工, 所以学生所缴纳的社保也是指 &quot;城乡居民社会保险&quot;, 但是学生不同于农民的地方是学生所缴纳的社保中不包含 &quot;城乡居民基本养老保险&quot;, 只包含 &quot;城乡居民基本医疗保险&quot;. 所以大多数时候老师或者校方会直接询问你是否缴纳 &quot;医保&quot;, 而不是询问你是否缴纳 &quot;社保&quot;. 当然这里所说的 &quot;医保&quot; 就是指 &quot;城乡居民基本医疗保险&quot;. </p>
<h2 id="我刚刚参加工作-听说了-quot-五险一金-quot-它是什么"><a href="#我刚刚参加工作-听说了-quot-五险一金-quot-它是什么" class="headerlink" title="我刚刚参加工作, 听说了 &quot;五险一金&quot;, 它是什么?"></a>我刚刚参加工作, 听说了 &quot;五险一金&quot;, 它是什么?</h2><p>由于已经参加了工作, 便成为了职工人员, 所以就出现了 &quot;五险一金&quot;. &quot;五险&quot; 自然就是指 &quot;城镇职工社会保险&quot; 了, 由于 &quot;城镇职工社会保险&quot; 包含五种保险, 所以也被称作 &quot;五险&quot;, 而 &quot;一金&quot; 指的是 &quot;住房公积金&quot;. </p>
<h2 id="我听说-quot-五险一金-quot-中有一个叫做-quot-生育险-quot-可是我一个男生-交-quot-生育险-quot-有什么用"><a href="#我听说-quot-五险一金-quot-中有一个叫做-quot-生育险-quot-可是我一个男生-交-quot-生育险-quot-有什么用" class="headerlink" title="我听说 &quot;五险一金&quot; 中有一个叫做 &quot;生育险&quot;, 可是我一个男生, 交 &quot;生育险&quot; 有什么用?"></a>我听说 &quot;五险一金&quot; 中有一个叫做 &quot;生育险&quot;, 可是我一个男生, 交 &quot;生育险&quot; 有什么用?</h2><ul>
<li><p>虽然男生们不能生育宝宝, 但是男生们在公司也是有 10 天看护假期的, 按照生育险规定, 已参保的男性职工按规定享受看护假假期津贴. </p>
</li>
<li><p>男生们不能生育宝宝, 但是你的太太是要生育宝宝的啊, 如果你的太太没有就业, 也就没有缴纳生育险, 但是由于你缴纳了 &quot;职保&quot;(职保包含生育险), 那么你的太太同样可以享受其中的生育险待遇. </p>
</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2ODQ2NDUwOS9hbnN3ZXIvMzM5NDY1OTQy">知乎用户 ID: 51社保余清泉<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>LifeTips</category>
      </categories>
      <tags>
        <tag>生活知识</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的网络相关名词的含义 (一)</title>
    <url>/network/network_concept_mean_1.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="🍁前言"><a href="#🍁前言" class="headerlink" title="🍁前言"></a>🍁前言</h1><p>没有上过有关网络知识的课程, 也没有读过网络相关的书籍, 脑中没有任何系统的网络知识, 有的只是一点点电脑使用经验, 真的是落后于时代了啊~</p>
<h1 id="🙄声明"><a href="#🙄声明" class="headerlink" title="🙄声明"></a>🙄声明</h1><p>由于日常生活中对话的口语性, 下文提到的所有词汇在日常生活中的具体释义应视具体对话场景而定.</p>
<h1 id="🥦常见的网络相关名词"><a href="#🥦常见的网络相关名词" class="headerlink" title="🥦常见的网络相关名词"></a>🥦常见的网络相关名词</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li>计算机网络: 英文 network, 将一台以上的电子设备互连起来, 互连的电子设备之间可以实现通信, 进行信息共享, 这就是计算机网络. 你的手机和电脑之间传输数据时就构成了一个小小的计算机网络.</li>
</ul>
<h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><ul>
<li><p>互联网: 英文为小写开头的 <strong>internet</strong>. 互联网, 顾名思义, 即互相联系的网络, 由多个<font color='red'><strong>计算机网络</strong></font>互连而成. </p>
</li>
<li><p>互联网是一个统称, 例如现代家居由家庭中各个电子设备共同组成的家庭网, 公司中上百人使用的办公网, 整个城市所使用的城市网, 整个国家使用的国家网, 这些大大小小的 &quot;网&quot; 都可以称为互联网.</p>
</li>
</ul>
<h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><ul>
<li>因特网: 英文为大写开头的 <strong>Internet</strong>. 在上面所说的这些大大小小的互联网中, 有一个互联网, 虽然最开始也很小, 但是随着越来越多的国家和地区, 越来越多的组织机构, 越来越多的个人都加入到了这个互联网中, 分享自己的数据, 所以这个互联网就越来越大, 最后被大家公认为这是一个全球公开网, 只要你想让你的数据可以被全世界任何人访问, 那么你就可以连接上这个网, 进行数据共享. 这个网就是因特网, 是国际上最大的互联网, 也称 &quot;国际互联网&quot;.</li>
</ul>
<h2 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h2><ul>
<li>万维网: 英文 <strong>World Wide Web</strong>, 简写 <strong>WWW</strong>. 因特网提供的服务可不仅仅只有网页服务, 还有邮件服务, 文件传输服务, 网上聊天服务, 电子公告板服务等等, 这其中最主要的部分就是<font color='red'><strong>网页服务</strong></font>, 即万维网. 万维网不是一种网络, 而是一项服务.</li>
</ul>
<blockquote>
<h3 id="Internet-因特网的发展历史"><a href="#Internet-因特网的发展历史" class="headerlink" title="Internet 因特网的发展历史"></a>Internet 因特网的发展历史</h3><ul>
<li>1960 年, 美国国防部高等研究计划署 (ARPA) 创建了 ARPANET. </li>
<li>ARPANET 最开始只有两个网络节点: 加利福尼亚大学洛杉矶分校的网络测量中心 和 门罗帕克斯坦福国际研究院的 NLS 系统. 第三个节点是加利福尼亚大学圣塔芭芭拉分校, 第四个节点是犹他大学.</li>
<li>1971 年底, 已经有 15 个节点连接到 ARPANET.</li>
<li>20 世纪 80 年代中后期 (1985~1990), ARPANET 在欧洲和澳大利亞迅速扩张.</li>
<li>20 世纪 80 年代后期和 20 世纪 90 年代初期 ARPANET 扩展至亚洲.</li>
<li>1989年, MCI Mail 和 CompuServe 与 ARPANET 创建了连接, ARPANET 可以提供邮件服务.</li>
<li>1990 年万维网初诞生, 1995 年万维网基本架构实现, ARPANET 可以提供网页服务.</li>
</ul>
<h3 id="internet-首字母的大小写"><a href="#internet-首字母的大小写" class="headerlink" title="internet 首字母的大小写"></a>internet 首字母的大小写</h3><ul>
<li>首字母小写的 internet 为<font color='red'><strong>任何分离的实体网络</strong></font>的集合, 这些网络以一组<font color='red'><strong>通用的协议</strong></font>相连, 形成逻辑上的单一网络.</li>
<li>首字母大写的 Internet 专指<font color='red'><strong>前身为 ARPANET</strong></font>, 后使用 <font color='red'><strong>IP 协议</strong></font>将各种实体网络链接成此单一逻辑网络. </li>
<li>Internet 是 internet 中的一种特定形式.</li>
</ul>
</blockquote>
<h1 id="🌿网络的分类"><a href="#🌿网络的分类" class="headerlink" title="🌿网络的分类"></a>🌿网络的分类</h1><p>以下名词都是互联网在不同分类下诞生的词汇, 因此这些词汇指的都是某种互联网.</p>
<h2 id="分类方式-覆盖范围"><a href="#分类方式-覆盖范围" class="headerlink" title="分类方式: 覆盖范围"></a>分类方式: 覆盖范围</h2><p>互联网按照覆盖范围可以大致分为: 个域网, 局域网, 城域网, 广域网.</p>
<h3 id="个域网"><a href="#个域网" class="headerlink" title="个域网"></a>个域网</h3><p>个域网, 即个人域网, 英文 <strong>Personal Area Network</strong>, 简写 <strong>PAN</strong>.</p>
<h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>局域网, 即本地互联网, 英文 <strong>Local Area Network</strong>, 简写 <strong>LAN</strong>.</p>
<h3 id="城域网"><a href="#城域网" class="headerlink" title="城域网"></a>城域网</h3><p>城域网, 即城市范围内所建立的互联网, 英文 <strong>Metropolitan Area Network</strong>, 简写 <strong>MAN</strong>.</p>
<h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><p>广域网, 即比城域网范围还要大的互联网, 英文 <strong>Wide Area Network</strong>, 简写 <strong>WAN</strong>, 一般由电信部门负责组建, 管理和维护.</p>
<h2 id="分类方式-是否连入因特网"><a href="#分类方式-是否连入因特网" class="headerlink" title="分类方式: 是否连入因特网"></a>分类方式: 是否连入因特网</h2><p>这是生活中最常用的分类方式, 根据这个分类可以分为: 内网, 外网.</p>
<h3 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h3><p>内网, 即未接入因特网的互联网, 又叫做 <strong>本地连接</strong>. </p>
<p>比如一个大学宿舍内, 几台电脑之间联机进行 CS 游戏对战, 此时这几台电脑便组成了一个简单的互联网. 这个互联网按照之前说的范围分类就是局域网, 按照是否连入因特网来分类就是内网.</p>
<h3 id="外网"><a href="#外网" class="headerlink" title="外网"></a>外网</h3><p>外网, 即接入了因特网的互联网, 又叫做 <strong>公网</strong>. 我们平时所说的 &quot;你电脑能上网不?&quot;, &quot;你回家之后怎么联网呀?&quot;, 这里面所说的 &quot;网&quot; 其实就是外网, &quot;联网&quot;, &quot;上网&quot; 就是接入因特网.</p>
<h1 id="🌴局域网的组网方式"><a href="#🌴局域网的组网方式" class="headerlink" title="🌴局域网的组网方式"></a>🌴局域网的组网方式</h1><p>前面提到了局域网, 而局域网的实现技术, 或者说组网方式, 有很多种, 如 <strong>令牌环</strong>, <strong>FDDI</strong>, <strong>ARCNET</strong>, <strong>以太网</strong>, <strong>Wi-Fi</strong>. 因此 <font color='red'><strong>以太网不是网络</strong></font>, 它是局域网的一种技术标准, 一种组网方式, 同样 Wi-Fi 也是.</p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><ul>
<li><p>以太网: 英文 <strong>Ethernet</strong>. 是目前应用最普遍的局域网技术, 取代了其他局域网技术, 如令牌环, FDDI, ARCNET 等.</p>
</li>
<li><p>以太网是基于 <strong>IEEE 802.3</strong> 标准实现的.</p>
</li>
</ul>
<h2 id="Wi-Fi"><a href="#Wi-Fi" class="headerlink" title="Wi-Fi"></a>Wi-Fi</h2><ul>
<li><p>Wi-Fi: 英文 <strong>wireless fidelity</strong>. 又称 &quot;无线热点&quot; 或 &quot;无线网络&quot;, 也是目前应用非常普遍的局域网实现技术.</p>
</li>
<li><p>同时它还是 Wi-Fi 联盟的商标. Wi-Fi 常被写成 <strong><code>WiFi</code></strong> 或 <strong><code>Wifi</code></strong>, 但是这些写法并没有被 Wi-Fi 联盟认可.</p>
</li>
<li><p>Wi-Fi 是基于 <strong>IEEE 802.11</strong> 标准实现的无线局域网技术.</p>
</li>
</ul>
<p>[<strong>注</strong>]</p>
<ul>
<li>日常生活中可以简单的认为, 利用 <strong>网线</strong> 互相连接实现局域网的方式就是以太网, 利用 <strong>无线热点</strong> 实现局域网的方式就是 Wi-Fi.</li>
</ul>
<h1 id="🦄总结"><a href="#🦄总结" class="headerlink" title="🦄总结"></a>🦄总结</h1><table>
<thead>
<tr>
<th align="left">名词</th>
<th align="left">英文/同义词</th>
<th align="left">是否是网络</th>
<th align="left">简单释义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">计算机网络</td>
<td align="left">network</td>
<td align="left">是</td>
<td align="left">网络统称</td>
</tr>
<tr>
<td align="left">互联网</td>
<td align="left">internet</td>
<td align="left">是</td>
<td align="left">网络统称</td>
</tr>
<tr>
<td align="left">因特网</td>
<td align="left">Internet</td>
<td align="left">是</td>
<td align="left">专有名词, 一个叫做因特网的互联网</td>
</tr>
<tr>
<td align="left">万维网</td>
<td align="left">World Wide Web, WWW</td>
<td align="left">否, 网页服务</td>
<td align="left">专有名词, 因特网所提供的网页服务</td>
</tr>
<tr>
<td align="left">个域网</td>
<td align="left">Personal Area Network, PAN</td>
<td align="left">是</td>
<td align="left">个人域互联网</td>
</tr>
<tr>
<td align="left">局域网</td>
<td align="left">Local Area Network, LAN</td>
<td align="left">是</td>
<td align="left">小范围的互联网</td>
</tr>
<tr>
<td align="left">城域网</td>
<td align="left">Metropolitan Area Network, MAN</td>
<td align="left">是</td>
<td align="left">覆盖整个城市的互联网</td>
</tr>
<tr>
<td align="left">广域网</td>
<td align="left">Wide Area Network, WAN</td>
<td align="left">是</td>
<td align="left">比城域网范围还要大的互联网</td>
</tr>
<tr>
<td align="left">内网</td>
<td align="left">本地连接</td>
<td align="left">是</td>
<td align="left">未接入因特网的互联网</td>
</tr>
<tr>
<td align="left">外网</td>
<td align="left">公网</td>
<td align="left">是</td>
<td align="left">已接入因特网的互联网</td>
</tr>
<tr>
<td align="left">以太网</td>
<td align="left">Ethernet</td>
<td align="left">否, 技术</td>
<td align="left">一种组网方式, 技术标准: IEEE 802.3</td>
</tr>
<tr>
<td align="left">Wi-Fi</td>
<td align="left">wireless fidelity</td>
<td align="left">否, 技术</td>
<td align="left">一种组网方式, 技术标准: IEEE 802.11</td>
</tr>
</tbody></table>
<h1 id="🐬参考文章"><a href="#🐬参考文章" class="headerlink" title="🐬参考文章"></a>🐬参考文章</h1><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzY3NDAyNg==">互联网和因特网都是什么网? 好久没打渔了<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcmFueW9uc3VlL3AvOTcxMzk5Mi5odG1s">内网和外网之间的通信 (端口映射原理)<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81MGNmMTE3NDhiMjY=">因特网、互联网、以太网、局域网、万维网的区别<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>NetWork</category>
      </categories>
      <tags>
        <tag>Internet</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 异构数据库访问</title>
    <url>/oracle/oracle_gateways.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="🦴前言"><a href="#🦴前言" class="headerlink" title="🦴前言"></a>🦴前言</h1><p>从 Oracle 连接 SQL Server 数据库, 需要用透明网关 (Transparent Gateway), 通过它, 我们可以访问并操作 SQL Server 数据库, 当前也可以连接其他数据库, 实现数据库的异构服务.<br>目前是SQL SERVER2005异构连接. </p>
<h1 id="🌴声明"><a href="#🌴声明" class="headerlink" title="🌴声明"></a>🌴声明</h1><ul>
<li><p>本文写于 2020 年 07 月 29 号, 请注意文章时效性!</p>
</li>
<li><p>如果你要配置的环境不是 <code>Oracle Database 和 Oracle Gateways 安装在一台电脑上</code> 这种, 请出门左转 Google, 本文仅在这种环境下验证通过, 不保证 100% 适用于其他环境. 另外, 经测试, Microsoft SQL Server 无论是否安装和 Database 在同一台电脑上本文均有效!</p>
</li>
<li><p>在 Oracle 8i 中没有透明网关, Oracle 10.2 的透明网关是单独的一个插件 <code>10201_gateways_win32.zip</code>, 需要另外安装. 因此本文只适用于 Oracle 11 版本, 其他版本没有进行单独测试, 但相近的版本应该也是适应的. (不保证)</p>
</li>
</ul>
<h1 id="🐌Oracle-Database-使用-Oracle-Gateways-访问-Microsoft-SQL-Server"><a href="#🐌Oracle-Database-使用-Oracle-Gateways-访问-Microsoft-SQL-Server" class="headerlink" title="🐌Oracle Database 使用 Oracle Gateways 访问 Microsoft SQL Server"></a>🐌Oracle Database 使用 Oracle Gateways 访问 Microsoft SQL Server</h1><p>公司中一个项目要用 Oracle 访问 SQL Server, 于是我先在自己电脑上做一下配置实验, 本次实验中 Oracle Database 和 Oracle Gateways 安装在自己电脑上, SQL Server 数据库安装在另一台电脑上.</p>
<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><h3 id="Oracle-Database"><a href="#Oracle-Database" class="headerlink" title="Oracle Database"></a>Oracle Database</h3><ul>
<li>版本: Oracle Database 11.2.0.1.0 - Production (32 bit)</li>
<li>服务器名称(IP): 192.168.11.95</li>
<li>数据库名: orcl</li>
<li>账号密码: scott/a</li>
<li>本地监听: 1521</li>
<li>对外监听: 1522</li>
</ul>
<h3 id="Oracle-Gateways"><a href="#Oracle-Gateways" class="headerlink" title="Oracle Gateways"></a>Oracle Gateways</h3><ul>
<li>版本: Oracle Gateways 11.2.0.1.0 (32 bit)</li>
<li>服务器名称(IP): 192.168.11.95</li>
<li>数据库名: dg4msql</li>
<li>本地监听: 1521</li>
<li>对外监听: 1522</li>
</ul>
<p>[<strong>注</strong>] Oracle Database 和 Oracle Gateways 的版本和位数都必须保持一致. (不要问我怎么知道的, 问就是不知道! 🙄)</p>
<h3 id="Microsoft-SQL-Server"><a href="#Microsoft-SQL-Server" class="headerlink" title="Microsoft SQL Server"></a>Microsoft SQL Server</h3><ul>
<li>版本: Microsoft SQL Server 2008 R2 (64 bit)</li>
<li>服务器名称(IP): 192.168.10.9</li>
<li>实例名: (null)</li>
<li>数据库名: htgl20180809</li>
<li>账号密码: sa/sa2008</li>
</ul>
<h4 id="查看-Microsoft-SQL-Server-数据库的信息"><a href="#查看-Microsoft-SQL-Server-数据库的信息" class="headerlink" title="查看 Microsoft SQL Server 数据库的信息"></a>查看 Microsoft SQL Server 数据库的信息</h4><ol>
<li><p>在 Microsoft SQL Server 的对象资源管理器中找到要查看的数据库, 右键属性</p>
<p> <img data-src="/images/oracle_gateways/SQL_Server1.png" alt="SQL_Server_1"></p>
</li>
<li><p>在弹出的窗口中点击左下方的 &quot;查看连接属性&quot;.</p>
<p> <img data-src="/images/oracle_gateways/SQL_Server2.png" alt="SQL_Server_2"></p>
</li>
<li><p>在弹出的窗口中就可以看到需要的信息了, 其中 <code>服务器主机名</code>, <code>实例名</code> 和 <code>数据库名</code> 在安装 Gateways 时会用到.</p>
<p> <img data-src="/images/oracle_gateways/SQL_Server3.png" alt="SQL_Server_3"></p>
</li>
</ol>
<h2 id="下载-Oracle-Database-和-Oracle-Gateways"><a href="#下载-Oracle-Database-和-Oracle-Gateways" class="headerlink" title="下载 Oracle Database 和 Oracle Gateways"></a>下载 Oracle Database 和 Oracle Gateways</h2><p>目前 Oracle 官网把所有信息都放置到一个菜单中, 导致很多平时不怎么访问这种官网的人根本找不到 Oracle 家的软件在哪里下载...还是说一下如何下载 Oracle 软件吧...</p>
<ol>
<li><p>登录 <span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS8=">Oracle 官网<i class="fa fa-external-link-alt"></i></span>, 展开上方的 <code>Products</code> 菜单, 点击其中的 <code>Oracle Database</code> 选项.</p>
<p> <img data-src="/images/oracle_gateways/Oracle_Download1.png" alt="Oracle_Download_1"></p>
</li>
<li><p>点击下载最新版本的 Oracle Database 软件: <code>Download Database 19c</code>.</p>
<p> <img data-src="/images/oracle_gateways/Oracle_Download2.png" alt="Oracle_Download_2"></p>
</li>
<li><p>随后会跳转到一个很长很长的页面, 这个页面包含了几乎所有 Oracle 的数据库产品软件, 不再受到 Oracle 支持的版本这里不会显示, 比如 10g 系列就已经不再受 Oracle 支持了, 所以这里也就找不到 10g 系列的下载地址了. 一直往下滑, 找到需要的 <code>11.2.0.1.0</code> 版本的位置, 由于我需要 32 位的数据库软件, 所以这里点击 <code>Microsoft Windows (32-bit)</code> 右侧的 <code>See All</code>, 进入相应的详细信息页面.</p>
<p> <img data-src="/images/oracle_gateways/Oracle_Download3.png" alt="Oracle_Download_3"></p>
</li>
<li><p>详细信息页面的第一条就是 <code>Oracle Database</code> 的下载地址, Oracle 官方将软件打包成了两个压缩包, 全部下载即可. 第二条便是客户端的下载地址, 如果需要使用 PL/SQL 等软件操作数据库, 就需要下载安装 <code>Oracle Database Client</code> 了.</p>
<p> <img data-src="/images/oracle_gateways/Oracle_Download4.png" alt="Oracle_Download_4"></p>
</li>
<li><p>详细信息页面中, 紧接着客户端的第三条信息就是 <code>Oracle Gateways</code> 的下载地址了, 点击下载即可.</p>
<p> <img data-src="/images/oracle_gateways/Oracle_Download5.png" alt="Oracle_Download_5"></p>
</li>
<li><p>[<strong>注</strong>] 全部下载之后先不要着急解压, 先看一看下图, 下图是一个 <code>分卷压缩包</code>, 可以看到这个压缩包除了第一卷以外, 从第二卷开始, 后缀名使用了序号进行命名, 这种压缩包只要解压以 <code>zip</code> 为后缀名的第一卷即可, 以 <code>序号</code> 为后缀名并且文件名称和以 <code>zip</code> 为后缀名的文件 <strong><code>同名</code></strong> 的分卷压缩包都会自动解压.</p>
<p> <img data-src="/images/oracle_gateways/Oracle_Download6.png" alt="Oracle_Download_6"></p>
<p> 但是, 从 Oracle 官网下载的压缩包中, Database 的包被分成了两个: </p>
<p> <code>win32_11gR2_database_1of2.zip</code> </p>
<p> <code>win32_11gR2_database_2of2.zip</code></p>
<p> 需要注意的是这俩货可不是分卷压缩包, 必须两个都解压, 不要只解压了第一个就不管了, 不然后面会报错的. (不要问我怎么知道的, 问就是不知道! 🙄) 解压后应该是这个样子:</p>
<p> <code>win32_11gR2_database_1of2.zip</code> 和 <code>win32_11gR2_database_2of2.zip</code> 都会解压到 database 文件夹中.</p>
<p> <img data-src="/images/oracle_gateways/Oracle_Download7.png" alt="Oracle_Download_7"></p>
</li>
</ol>
<h2 id="安装-Oracle-Gateways"><a href="#安装-Oracle-Gateways" class="headerlink" title="安装 Oracle Gateways"></a>安装 Oracle Gateways</h2><ol>
<li><p>启动 gateways 文件夹中的安装程序.</p>
<p> <img data-src="/images/oracle_gateways/Gateways_Install1.png" alt="Oracle_Gateways_Install_1"></p>
</li>
<li><p>在这个页面可以查看已经安装的产品或者卸载产品, 点击下一步进行安装配置.</p>
<p> <img data-src="/images/oracle_gateways/Gateways_Install2.png" alt="Oracle_Gateways_Install_2"></p>
</li>
<li><p>在选择产品名称和路径时, 下面是默认配置. </p>
<p> [<strong>注</strong>] 由于 Database 和 Gateways 安装在同一台电脑上, 为了避免两者的监听出现问题, 要将 Gateways 安装到 Database 的路径中, 所以不要使用下面的默认配置.</p>
<p> <img data-src="/images/oracle_gateways/Gateways_Install3.png" alt="Oracle_Gateways_Install_3"></p>
<p> 而是从下拉框中选择 Oracle Database 的产品名称和路径: <code>OraDb11g_home1</code>, 如图.</p>
<p> <img data-src="/images/oracle_gateways/Gateways_Install4.png" alt="Oracle_Gateways_Install_4"></p>
<p> 选择后的配置是这个样子的:</p>
<p> <img data-src="/images/oracle_gateways/Gateways_Install5.png" alt="Oracle_Gateways_Install_5"></p>
</li>
<li><p>选择安装产品组件, 安装用于访问 Microsoft SQL Server 的组件. 由于我之前已经安装过了, 所以截图中显示的是 &quot;重新安装&quot;, 如果你电脑上没还有安装这个组件, 应该会显示 &quot;未安装&quot;.</p>
<p> <img data-src="/images/oracle_gateways/Gateways_Install6.png" alt="Oracle_Gateways_Install_6"></p>
</li>
<li><p>输入要连接的 Microsoft SQL Server 的信息, 包括服务器主机名, 实例名, 数据库名, 由于我之前查看 SQL Server 信息的时候发现我要连接的 SQL Server 数据库实例名为空, 所以图中填写实例名的地方空着.</p>
<p> <img data-src="/images/oracle_gateways/Gateways_Install7.png" alt="Oracle_Gateways_Install_7"></p>
</li>
<li><p>最后点击安装.</p>
<p> <img data-src="/images/oracle_gateways/Gateways_Install8.png" alt="Oracle_Gateways_Install_8"></p>
</li>
</ol>
<h2 id="配置-Oracle-Database-和-Oracle-Gateways"><a href="#配置-Oracle-Database-和-Oracle-Gateways" class="headerlink" title="配置 Oracle Database 和 Oracle Gateways"></a>配置 Oracle Database 和 Oracle Gateways</h2><ol>
<li><p>关闭数据库监听程序. </p>
<p> Windows 服务中带有 <code>TNSListener</code> 的服务就是监听程序, 找到与待配置数据库对应的监听程序, 右键, 停止.</p>
<p> [<strong>注</strong>] 修改 <code>监听程序</code> 和 <code>服务命名</code> 的配置文件之前, 一定要先关闭监听程序, 否则很容易导致 PL/SQL 连接数据库时报错: <code>ORA-12514: TNS: 监听程序当前无法识别连接描述符中请求的服务</code>, 甚至会导致数据库无法访问, 监听程序也无法启动, 启动监听程序时报错: <code>某些服务在未由其他服务或程序使用时将自动停止</code>, 这时就只能重启数据库了, (不说了, 说多了都是泪啊~ 😫), 为了避免这些乱七八糟的麻烦, 一开始就先把监听程序停止掉就好了. </p>
<p> <img data-src="/images/oracle_gateways/Oracle_Configure1.png" alt="Oracle_Configure_1"></p>
</li>
<li><p>修改 Gateways 的数据库连接配置, 配置文件路径:</p>
<p> <code>...\product\11.2.0\dbhome_1\dg4msql\admin\initdg4msql.ora</code></p>
<p> 这个文件告诉了 Gateways 具体要连接到哪个 SQL Server 数据库, 这个文件会使用在安装 Gateways 的时候填写的信息进行默认设置, 如果只需要连接一个 SQL Server 数据库, 默认设置就可以了, 不需要做任何改动, 当然也可以进行自定义, 下面是这个文件的默认设置.</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HS_FDS_CONNECT_INFO&#x3D;[192.168.10.9]&#x2F;&#x2F;htgl20180809</span><br><span class="line">HS_FDS_TRACE_LEVEL&#x3D;OFF</span><br><span class="line">HS_FDS_RECOVERY_ACCOUNT&#x3D;RECOVER</span><br><span class="line">HS_FDS_RECOVERY_PWD&#x3D;RECOVER</span><br></pre></td></tr></table></figure>

<p> 这个文件重要配置的内容很少, 就只有异构数据库的连接信息.</p>
<ul>
<li><p><code>initdg4msql.ora</code> 文件的命名规则是: <code>initSID.ora</code>, Gateways 安装时默认的 SID 为 dg4msql, 所以文件的名字就是 initdg4msql.ora, 当需要连接多个 SQL Server 数据库的时候, 这里的 SID 自然就需要自定义了. 每一个要连接的 SQL Server 数据库都对应一个 initSID.ora 文件, SID 写一个通俗易懂的, 唯一的名称即可, 这个 SID 得记好, 后面还需要用到. 比如要连接两个 SQL Server 数据库 <code>htgl</code> 和 <code>cggl</code>, 那么就可以复制一份 initdg4msql.ora 文件, 并重命名为 <code>inithtgl.ora</code> 和 <code>initcggl.ora</code>, 分别进行配置即可.</p>
</li>
<li><p><code>HS_FDS_CONNECT_INFO</code> 的填写规则: <code>[SQL Server 服务器主机名]/SQL Server 实例名/SQL Server 数据库名</code>. 这个就是具体的 SQL Server 连接信息了.</p>
</li>
<li><p>这个文件夹中还有两个配置示例文件: <code>listener.ora.sample</code> 和 <code>tnsnames.ora.sample</code>, 这是用于 Database 配置时的示例文件, 用意是教会我们怎么修改 <code>监听程序</code> 和 <code>服务命名</code> 的配置, 不需要修改, 即使你修改了也不会生效, 因为文件的后缀是 <code>.sample</code>.</p>
</li>
</ul>
</li>
<li><p>修改 Oracle Database 的 <strong>监听程序</strong> 配置, 配置文件路径:</p>
<p> <code>...\product\11.2.0\dbhome_1\NETWORK\ADMIN\listener.ora</code></p>
<p> 在监听程序配置文件的 <code>SID_LIST_LISTENER</code> 中添加之前配置好的 Gateways SID, 下图中高亮的这段配置文本就是之前配置的 SID 为 dg4msql 的 Gateways, 其实这一段文本是从之前提到的模板文件 <code>listener.ora.sample</code> 中复制过来的.</p>
<p> <img data-src="/images/oracle_gateways/Oracle_Configure2.png" alt="Oracle_Configure_2"></p>
<ul>
<li><code>SID_NAME</code> 填写之前配置的 <code>initSID.ora</code> 文件使用的 SID 名.</li>
<li><code>PROGRAM</code> 是 Gateways 所在的文件夹的名字, 可以看到目前 Gateways 就是安装到了 <code>dg4msql</code> 文件夹中, 所以不要修改这个值.</li>
<li><code>ORACLE_HOME</code> 数据库软件的安装位置.</li>
</ul>
</li>
<li><p>修改 Oracle Database 的 <strong>服务命名</strong> 配置, 配置文件路径:</p>
<p> <code>...\product\11.2.0\dbhome_1\NETWORK\ADMIN\tnsnames.ora</code></p>
<p> 在服务命名配置文件中添加之前创建的 dg4msql 服务. 高亮的这段配置文本就是从之前提到的模板文件 <code>tnsnames.ora.sample</code> 中复制过来的.</p>
<p> <img data-src="/images/oracle_gateways/Oracle_Configure3.png" alt="Oracle_Configure_3"></p>
</li>
<li><p>重启 Oracle 监听程序.</p>
<p> 此时再将之前关闭的监听程序启动.</p>
</li>
</ol>
<h2 id="创建数据库连接-DBLink"><a href="#创建数据库连接-DBLink" class="headerlink" title="创建数据库连接 DBLink"></a>创建数据库连接 DBLink</h2><p>使用下面的格式写一条语句创建 DBLink, 也可以使用 PL/SQL 进行可视化创建.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">create database link 变量名(随意)</span></span><br><span class="line"><span class="comment">  connect to 用户名 identified by 用户密码</span></span><br><span class="line"><span class="comment">  using &#x27;透明网关标识&#x27;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">link</span> htgl</span><br><span class="line">  <span class="keyword">connect</span> <span class="keyword">to</span> sa <span class="keyword">identified</span> <span class="keyword">by</span> sa2008</span><br><span class="line">  <span class="keyword">using</span> <span class="string">&#x27;dg4msql&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="连接测试"><a href="#连接测试" class="headerlink" title="连接测试"></a>连接测试</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--select &quot;字段名&quot; from &quot;SQL Server 中的表名&quot;@(DBLink变量名)</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&quot;rybh&quot;</span> <span class="keyword">from</span> <span class="string">&quot;ryb&quot;</span>@htgl;</span><br><span class="line"><span class="comment">--当需要多表连接查询时, 可以这样写</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&quot;zt&quot;</span> <span class="keyword">as</span> <span class="keyword">id</span>,</span><br><span class="line">       (<span class="keyword">select</span> <span class="string">&quot;xm&quot;</span> <span class="keyword">from</span> <span class="string">&quot;ryb&quot;</span>@htgl <span class="keyword">where</span> <span class="string">&quot;rybh&quot;</span> = <span class="string">&quot;htqxb&quot;</span>.<span class="string">&quot;rybh&quot;</span>@htgl) <span class="keyword">as</span> <span class="keyword">name</span></span><br><span class="line">  <span class="keyword">from</span> <span class="string">&quot;htqxb&quot;</span>@htgl</span><br><span class="line"> <span class="keyword">where</span> <span class="string">&quot;rybh&quot;</span> = <span class="string">&#x27;150007&#x27;</span>;</span><br><span class="line"><span class="comment">--另外异构数据库不支持 join 类查询.</span></span><br></pre></td></tr></table></figure>

<p>[<strong>注</strong>] 使用 Oracle 访问 SQL Server 时, 你会发现总是会报这样一个错误: <code>***字段名无效!</code>. 这个错误是因为 Oracle 访问 SQL Server 时, 字段名要使用 <code>双引号</code> 括起来. (不要问我怎么知道的, 问就是不知道! 🙄) 表名最好也使用双引号括起来.</p>
<h1 id="🦄多异构数据库的配置"><a href="#🦄多异构数据库的配置" class="headerlink" title="🦄多异构数据库的配置"></a>🦄多异构数据库的配置</h1><p>公司的项目现在又要求 Oracle 数据库必须能够访问 SQL Server 中的 <code>htgl20180809</code> 和 <code>cggl20180808</code> 这两个数据库, 之前提到过, 每一个要连接的异构数据库都对应一个 initSID.ora 文件, 唯一标识就是 SID.</p>
<h2 id="修改-Gateways-的数据库连接配置"><a href="#修改-Gateways-的数据库连接配置" class="headerlink" title="修改 Gateways 的数据库连接配置"></a>修改 Gateways 的数据库连接配置</h2><p>建立两个 initSID.ora 文件, 起名为: <code>inithtgl.ora</code> 和 <code>initcggl.ora</code>, 对应的 SID 就是 <code>htgl</code> 和 <code>cggl</code>.</p>
<p><img data-src="/images/oracle_gateways/Gateways_Multiple1.png" alt="Gateways_Multiple_1"></p>
<p>这个是文件 inithtgl.ora 的内容, 连接 192.168.10.9 上的 htgl20180809 数据库.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HS_FDS_CONNECT_INFO&#x3D;[192.168.10.9]&#x2F;&#x2F;htgl20180809</span><br><span class="line">HS_FDS_TRACE_LEVEL&#x3D;OFF</span><br><span class="line">HS_FDS_RECOVERY_ACCOUNT&#x3D;RECOVER</span><br><span class="line">HS_FDS_RECOVERY_PWD&#x3D;RECOVER</span><br></pre></td></tr></table></figure>

<p>这个是文件 initcggl.ora 的内容, 连接 192.168.10.9 上的 cggl20180808 数据库.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HS_FDS_CONNECT_INFO&#x3D;[192.168.10.9]&#x2F;&#x2F;cggl20180808</span><br><span class="line">HS_FDS_TRACE_LEVEL&#x3D;OFF</span><br><span class="line">HS_FDS_RECOVERY_ACCOUNT&#x3D;RECOVER</span><br><span class="line">HS_FDS_RECOVERY_PWD&#x3D;RECOVER</span><br></pre></td></tr></table></figure>

<h2 id="修改-Oracle-Database-监听程序配置"><a href="#修改-Oracle-Database-监听程序配置" class="headerlink" title="修改 Oracle Database 监听程序配置"></a>修改 Oracle Database 监听程序配置</h2><p>监听程序的配置, 其实就是把之前配置好的 Gateways 的 SID 放到监听程序的 LIST 中, 反映到文件中就是在 <code>SID_LIST_LISTENER</code> 中添加 SID 设置.</p>
<p><img data-src="/images/oracle_gateways/Gateways_Multiple2.png" alt="Gateways_Multiple_2"></p>
<ul>
<li><p><code>PROGRAM</code> 是 Gateways 的安装路径, Gateways 就是安装在 dg4msql 文件夹下的, 所以这个值不能变.</p>
</li>
<li><p><code>SID_NAME</code> 是 Gateways 的 SID 值.</p>
</li>
</ul>
<h2 id="修改-Oracle-Database-服务命名配置"><a href="#修改-Oracle-Database-服务命名配置" class="headerlink" title="修改 Oracle Database 服务命名配置"></a>修改 Oracle Database 服务命名配置</h2><p>服务命名的配置顾名思义, 就是将配置好的 Gateways 服务在服务配置文件中列出来, 告诉 Oracle 数据库我们配置了 Gateways 服务, 不然 Oracle 数据库是不知道的.</p>
<p><img data-src="/images/oracle_gateways/Gateways_Multiple3.png" alt="Gateways_Multiple_3"></p>
<ul>
<li><p>= 号前面的是服务的名称, 一般保持和 SID 的名称一致, <code>dg4msql/admin</code> 文件夹中的 <code>tnsnames.sample</code> 文件也是这样教我们的.</p>
</li>
<li><p><code>SID</code> 改成之前配置 Gateways 时使用的 SID.</p>
</li>
</ul>
<h2 id="连接测试-1"><a href="#连接测试-1" class="headerlink" title="连接测试"></a>连接测试</h2><p>配置都做好之后, 建立 DBLink, 就可以访问 SQL Server 了.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">link</span> htgl <span class="keyword">connect</span> <span class="keyword">to</span> sa <span class="keyword">identified</span> <span class="keyword">by</span> sa2008</span><br><span class="line">  <span class="keyword">using</span> <span class="string">&#x27;htgl&#x27;</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">link</span> cggl <span class="keyword">connect</span> <span class="keyword">to</span> sa <span class="keyword">identified</span> <span class="keyword">by</span> sa2008</span><br><span class="line">  <span class="keyword">using</span> <span class="string">&#x27;cggl&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--drop database link htgl;</span></span><br><span class="line"><span class="comment">--drop database link cggl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">&quot;khyh&quot;</span>, <span class="string">&quot;htbh&quot;</span>, <span class="string">&quot;htmc&quot;</span>, <span class="string">&quot;htje&quot;</span> <span class="keyword">from</span> <span class="string">&quot;cghtb&quot;</span>@htgl <span class="keyword">where</span> <span class="string">&quot;wpbh&quot;</span> <span class="keyword">like</span> <span class="string">&#x27;2018%&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="string">&quot;wpbh&quot;</span>, <span class="string">&quot;wpmc&quot;</span>, <span class="string">&quot;shl&quot;</span>, <span class="string">&quot;dw&quot;</span> <span class="keyword">from</span> <span class="string">&quot;cggl_sqmxb&quot;</span>@cggl;</span><br></pre></td></tr></table></figure>

<p>这是 htgl20180809 数据库的查询结果:</p>
<p><img data-src="/images/oracle_gateways/Gateways_Multiple4.png" alt="Gateways_Multiple_4"></p>
<p>这是 cggl20180808 数据库的查询结果:</p>
<p><img data-src="/images/oracle_gateways/Gateways_Multiple5.png" alt="Gateways_Multiple_5"></p>
<h1 id="🐬参考链接"><a href="#🐬参考链接" class="headerlink" title="🐬参考链接"></a>🐬参考链接</h1><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rhbmd4aW5nSUxvdmV5b3UvYXJ0aWNsZS9kZXRhaWxzLzgwNjc2NDM3">Oracle连接Sql Server (win32_11gR2_gateways)<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pkYzUyNTU1NTUvYXJ0aWNsZS9kZXRhaWxzLzEyNTc1NzIz">Oracle11g+ 配置多个gateway 连接sqlserver<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle 全拼和首字母查询</title>
    <url>/oracle/oracle_trigger.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h1><p>首先在 Oracle 数据库中建立 &quot;汉字转全拼&quot; 和 &quot;汉字转首字母&quot; 的方法, 网上的方法基本全部不可信, 支持的汉字很少, 我使用的是从 &quot;ItPub&quot; 论坛上下载的, 目前没有发现不支持的汉字.</p>
<p><img data-src="/images/oracle_trigger/oracle_pinyin.png" alt="itpub"></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9vZC5say9kL056TmZNalUxT1RZeU1UZGYvb3JhY2xlX2NvZGUuN3o=">下载地址<i class="fa fa-external-link-alt"></i></span> 解压密码是: <code>https://kuroha.vip/</code></p>
<p>解压之后, 直接执行里面的 sql 文件, 会建立一个 <code>package</code> 和一个 <code>package body</code>, 之后就可以使用 <code>hzpy.gethzfullpy()</code> 和 <code>hzpy.hzpycap()</code> 方法获取汉字的拼音和首字母了.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> hzpy.hzpycap(<span class="string">&#x27;又双叒叕&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> hzpy.gethzfullpy(<span class="string">&#x27;又双叒叕&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">lower</span>(hzpy.hzpycap(<span class="string">&#x27;又双叒叕&#x27;</span>)) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">lower</span>(hzpy.gethzfullpy(<span class="string">&#x27;又双叒叕&#x27;</span>)) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<h1 id="新思路"><a href="#新思路" class="headerlink" title="新思路"></a>新思路</h1><p>之前的思路是对人员表中的所有人员姓名进行转换, 将转换后的结果和用户的实时输入做 like 对比, 但是项目中的人员数动辄就近万条, 再加上用户如果使用全拼方式查询, 那速度真是~ 就像电脑要死机一样. 于是后来转换思路, 在人员表中加入两列, 一列用来保存姓名所对应的首字母形式, 另一列用来保存姓名所对应的全拼形式.</p>
<p>使用 <code>update</code> 语句更新已存在人员的全拼和首字母信息, 新增人员使用触发器进行自动更新. 下面是触发器使用时的一些要点.</p>
<h1 id="SQL-语句分类"><a href="#SQL-语句分类" class="headerlink" title="SQL 语句分类"></a>SQL 语句分类</h1><ul>
<li><p><strong>DDL</strong>: 全称 Data Definition Languages, 译为 &quot;数据定义语言&quot;, 定义了不同的数据段, 数据库, 表, 列, 索引等数据库对象, 简单来说就是对数据库内部的对象进行创建, 删除和修改的操作语言, 常用的语句关键字主要包括 <code>create</code>, <code>drop</code>, <code>alter</code>.</p>
</li>
<li><p><strong>DML</strong>: 全称 Data Manipulation Language, 译为 &quot;数据操作语言&quot;, 用于添加, 删除, 更新和查询数据库记录, 并检查数据完整性, 简单来说就是对表内部数据的增删改查操作, 不涉及到表定义, 表结构的修改, 更不会涉及到其他对象, 常用的语句关键字主要包括 <code>insert</code>, <code>delete</code>, <code>udpate</code>, <code>select</code>.</p>
</li>
<li><p><strong>DCL</strong>: 全称 Data Control Language, 译为 &quot;数据控制语言&quot;, 用于控制不同数据段的访问许可和访问级别的语句, 这些语句定义了数据库, 表, 字段, 用户的访问权限和安全级别. 主要的语句关键字包括 <code>grant</code>, <code>revoke</code>.</p>
</li>
</ul>
<h1 id="DML-触发器"><a href="#DML-触发器" class="headerlink" title="DML 触发器"></a>DML 触发器</h1><ol>
<li><p>触发器不能接收参数.</p>
</li>
<li><p>触发器的执行顺序:</p>
</li>
</ol>
<ul>
<li><ul>
<li>执行 before 语句级触发器</li>
</ul>
</li>
<li><ul>
<li>执行 before 行级触发器</li>
</ul>
</li>
<li><ul>
<li>执行 DML 语句</li>
</ul>
</li>
<li><ul>
<li>执行 after 行级触发器 </li>
</ul>
</li>
<li><ul>
<li>执行 after 语句级触发器</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>语句级触发器中, 不得使用 <code>:new</code> 和 <code>:old</code>, 行级触发器中, <code>:old</code> 为 &quot;操作前&quot; 的整行记录, <code>:new</code> 为 &quot;操作后&quot; 的整行记录.</p>
<table>
<thead>
<tr>
<th align="left">---</th>
<th align="left">insert</th>
<th align="left">update</th>
<th align="left">delete</th>
</tr>
</thead>
<tbody><tr>
<td align="left">old</td>
<td align="left">不允许使用</td>
<td align="left">更新前记录</td>
<td align="left">删除前记录</td>
</tr>
<tr>
<td align="left">new</td>
<td align="left">插入后记录</td>
<td align="left">更新后记录</td>
<td align="left">不允许使用</td>
</tr>
</tbody></table>
</li>
<li><p><font color='red'><strong>只有 before 行级触发器可以修改 :new 记录的值.</strong></font></p>
</li>
<li><p><font color='red'><strong>在行级触发器中, 不得将 <code>insert</code>, <code>update</code>, <code>delete</code> 语句作用于 &quot;自身触发表&quot;!</strong></font></p>
</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--在插入新纪录之前, 修改这条待插入记录的 szm 字段和 qp 字段.</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> trigger_ryb_pinyin</span><br><span class="line"><span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> ryb</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">:new.szm := <span class="keyword">lower</span>(hzpy.hzpycap(:new.xm));</span><br><span class="line">:new.qp := lower(hzpy.gethzfullpy(:new.xm));</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vSERLMjAxNi9wLzY5MTEwODcuaHRtbA==">详解ORACLE中的trigger<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuaXRwdWIubmV0LzIyNTI1Njc2L3ZpZXdzcGFjZS0xMTE3MDYwLw==">关于oracle触发器中修改自身表字段的问题<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON 参考手册</title>
    <url>/program/json_notes.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在实现毕业设计游戏的存档读档功能时选用了 JSON 文件进行读取和存储, 于是赶紧学习了一下 JSON 是啥...</p>
<h1 id="JSON-简介"><a href="#JSON-简介" class="headerlink" title="JSON 简介"></a>JSON 简介</h1><p>JSON 全称是: JavaScript Object Notation (JavaScript 对象表示法)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;sites&quot;</span>:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Kuroha&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;kuroha.vip&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;google&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;www.google.com&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JSON-语法"><a href="#JSON-语法" class="headerlink" title="JSON 语法"></a>JSON 语法</h1><ol>
<li><p>JSON 语法是 JavaScript 语法的子集.</p>
</li>
<li><p>JOSN 的数据使用 键值对 (Key/Value) 表示. Key 必须是 string, Value 可以是 string, 可以是 number, 可以是 bool 等等, 数据与数据之间使用 , 分割.</p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;aaa&quot;</span> : <span class="string">&quot;Kuroha&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;bbb&quot;</span> : <span class="number">1234</span>,</span><br><span class="line">    <span class="attr">&quot;ccc&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;ddd&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;eee&quot;</span> : <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON 中的类使用 {} 表示. 一个类中可以包含多个数据. 这里的数据可以是 类, 数组, 单条数据等.</p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;sites1&quot;</span> : </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;google&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;www.google.com&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;二次元游宅客&quot;</span> : </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Kuroha&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;kuroha.vip&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;sites1_1&quot;</span> : </span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Kirito&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;sao.com&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Asuna&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;url&quot;</span>:<span class="string">&quot;sao.online&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON 中的数组使用 [] 表示. 一个数组中可以包含多个类, 此时只能有类中的数据, 不能有类名. 数组中只包含数据的时候, 不能有数据名(Key), 只能有数据(Value). 因为数组是: 值的集合. (不同于编程语言, 这些值的类型是可以不同的.)</p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;aaa&quot;</span> : </span><br><span class="line">    [</span><br><span class="line">        <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ccc&quot;</span>,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;游宅客&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;url&quot;</span> : <span class="string">&quot;kuroha.vip&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/program/regular_expression.html</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式?"></a>正则表达式?</h1><blockquote>
<p>正则表达式是一种被用于从文本中检索符合某些特定模式的文本, 英文为 &quot;Regular Expression&quot;, 缩写 &quot;regex&quot; 或者 &quot;regexp&quot;.</p>
</blockquote>
<ol>
<li><p>正则表达式可以很简单的实现比较复杂的字符串匹配逻辑, 来快速地对用户输入施加限制条件.</p>
</li>
<li><p>在日常的文本编辑中, 正则表达式还可以快速的实现复杂的替换操作, 使得文本编辑省时省力.</p>
</li>
<li><p>正则表达式依赖于所处的环境, JavaScript, C#, Java, C++ 等不同的开发语言中以及 VSCode 等不同的文本编辑器下, 正则表达式的匹配规则会有一些细微的差别.</p>
</li>
<li><p>元字符不能写在字符集合 <code>[ ]</code> 的里面. <code>[ ]</code> 中的元字符全部会变为普通字符.</p>
</li>
</ol>
<h1 id="普通元字符"><a href="#普通元字符" class="headerlink" title="普通元字符"></a>普通元字符</h1><table>
<thead>
<tr>
<th align="center">元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td>表示一个除换行符以外的任意字符</td>
</tr>
<tr>
<td align="center">()</td>
<td><strong>字符组</strong>, 占位长度和字符串长度一致, 匹配其中的字符串或者逻辑</td>
</tr>
<tr>
<td align="center">[ ]</td>
<td><strong>字符集合</strong>, 默认占位长度为 1, 匹配集合中的任意一个字符, 可以使用范围符 <code>-</code> 来表示范围, 如: 0-9, a-z, A-Z 等</td>
</tr>
<tr>
<td align="center">[^ ]</td>
<td>否定字符集合, 默认占位长度为 1, 匹配集合中的所有字符以外的任意一个字符</td>
</tr>
<tr>
<td align="center">|</td>
<td>逻辑或</td>
</tr>
<tr>
<td align="center">\</td>
<td>转义符</td>
</tr>
</tbody></table>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>[<strong>注意</strong>] 字符集名称(<strong>大小写敏感</strong>), \w 和 \W 的含义完全相反. </p>
<table>
<thead>
<tr>
<th align="center">转义符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\f</td>
<td>匹配一个换页符</td>
</tr>
<tr>
<td align="center">\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td align="center">\r</td>
<td>匹配一个回车符</td>
</tr>
<tr>
<td align="center">\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td align="center">\v</td>
<td>匹配一个垂直制表符</td>
</tr>
<tr>
<td align="center">\w</td>
<td>匹配所有字母和数字的字符, 某些环境下也会匹配汉字</td>
</tr>
<tr>
<td align="center">\W</td>
<td>匹配非字母和数字的字符, 某些环境下汉字也会排除</td>
</tr>
<tr>
<td align="center">\d</td>
<td>匹配数字: <code>[0-9]</code></td>
</tr>
<tr>
<td align="center">\D</td>
<td>匹配非数字: <code>[^ 0-9]</code></td>
</tr>
<tr>
<td align="center">\s</td>
<td>匹配任何空白字符, 包括空格, 制表符, 换页符等</td>
</tr>
<tr>
<td align="center">\S</td>
<td>匹配非空格符</td>
</tr>
</tbody></table>
<h1 id="次数限定符"><a href="#次数限定符" class="headerlink" title="次数限定符"></a>次数限定符</h1><p>写在一个特定的字符或者字符组 <code>()</code> 的后面, 控制字符或者字符组的出现次数.</p>
<table>
<thead>
<tr>
<th align="center">次数限定符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td>匹配前面的子表达式 0 次或多次</td>
</tr>
<tr>
<td align="center">+</td>
<td>匹配前面的子表达式 1 次或多次</td>
</tr>
<tr>
<td align="center">?</td>
<td>匹配前面的子表达式 0 次或 1 次, 或指明一个非贪婪限定符</td>
</tr>
<tr>
<td align="center">{n}</td>
<td>花括号, 匹配前面字符或字符组 n 次</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td>花括号, 匹配前面字符或字符组至少 n 次</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td>花括号, 匹配前面字符或字符组至少 n 次, 但是不超过 m 次</td>
</tr>
</tbody></table>
<h1 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h1><p>定位符表示字符所处的位置.</p>
<table>
<thead>
<tr>
<th align="center">定位符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td>表示行的开始</td>
</tr>
<tr>
<td align="center">$</td>
<td>表示行的结束</td>
</tr>
<tr>
<td align="center">\b</td>
<td>匹配一个单词边界</td>
</tr>
<tr>
<td align="center">\B</td>
<td>非单词边界匹配</td>
</tr>
</tbody></table>
<h1 id="前后缀逻辑-断言"><a href="#前后缀逻辑-断言" class="headerlink" title="前后缀逻辑 (断言)"></a>前后缀逻辑 (断言)</h1><p>Q1: 匹配字符串中以全角美元符开头的 &#39;12000.00&#39;</p>
<p><code>12000.00 ￥12000.00 ＄12000.00</code></p>
<p>Q2: 匹配字符串中以全角美元符结尾的 &#39;12000.00&#39;</p>
<p><code>12000.00 12000.00￥ 12000.00＄</code></p>
<p>上面的两个问题, 就可以通过在正则表达式中添加前后缀逻辑来解决. &#39;前后缀逻辑&#39; 是我自己起的名字, 方便自己记忆, 但是有的文章中叫作 &quot;断言&quot;, 有的文章中叫 &quot;预匹配&quot;, 我都感觉好别扭啊!</p>
<p>[<strong>注</strong>] <font color='red'><strong>前后缀逻辑必须写在字符组 () 里面, 如: <code>(?&lt;=K)</code></strong></font>.</p>
<h2 id="前后缀逻辑组件"><a href="#前后缀逻辑组件" class="headerlink" title="前后缀逻辑组件"></a>前后缀逻辑组件</h2><p>[<strong>注</strong>] 下面是前后缀逻辑实现时用到的字符, 不能直接使用, 这样拆开写只是为了容易理解! 切记不可直接使用!</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">?&lt;</td>
<td>前缀描述符, 必须写在 &quot;被描述字符或字符组&quot; 的 <code>前面</code></td>
</tr>
<tr>
<td align="center">?</td>
<td>后缀描述符, 必须写在 &quot;被描述字符或字符组&quot; 的 <code>后面</code></td>
</tr>
<tr>
<td align="center">=</td>
<td>是</td>
</tr>
<tr>
<td align="center">!</td>
<td>不是</td>
</tr>
</tbody></table>
<h2 id="前缀逻辑-前行断言"><a href="#前缀逻辑-前行断言" class="headerlink" title="前缀逻辑 (前行断言)"></a>前缀逻辑 (前行断言)</h2><p><img data-src="/images/regular_expression/regular_expression_01.png" alt="前行断言"></p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(?&lt;=)</td>
<td><code>前缀为</code> 描述符</td>
</tr>
<tr>
<td align="center">(?&lt;!)</td>
<td><code>前缀不为</code> 描述符</td>
</tr>
</tbody></table>
<p>[<strong>注</strong>] 前缀描述符必须写在 &quot;被描述字符或字符组&quot; 的 <code>前面</code> ! 切记 !</p>
<p>示例: </p>
<p><code>(?&lt;=K)[0-9]&#123;11&#125;</code>: 匹配以 &#39;K&#39; 为前缀的 11 位数字.</p>
<p><code>(?&lt;!K)[0-9]&#123;11&#125;</code>: 匹配不以 &#39;K&#39; 为前缀的 11 位数字.</p>
<h2 id="后缀逻辑-后行断言"><a href="#后缀逻辑-后行断言" class="headerlink" title="后缀逻辑 (后行断言)"></a>后缀逻辑 (后行断言)</h2><p><img data-src="/images/regular_expression/regular_expression_02.png" alt="后行断言"></p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(?=)</td>
<td><code>后缀为</code> 描述符</td>
</tr>
<tr>
<td align="center">(?!)</td>
<td><code>后缀不为</code> 描述符</td>
</tr>
</tbody></table>
<p>[<strong>注</strong>] 后缀描述符必须写在 &quot;被描述字符或字符组&quot; 的 <code>后面</code> ! 切记 !</p>
<p>示例: </p>
<p><code>[\d]&#123;11&#125;(?=K)</code>: 匹配以 &#39;K&#39; 为后缀的 11 位数字.</p>
<p><code>[\d]&#123;11&#125;(?!K)</code>: 匹配不以 &#39;K&#39; 为后缀的 11 位数字.</p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>A1: <code>(?&lt;=＄)[\d.]+</code> <font color='red'>答案不唯一</font></p>
<p>A2: <code>[\d.]+(?=＄)</code> <font color='red'>答案不唯一</font></p>
<h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><p>会修改正则表达式的匹配模式, 可以以任意顺序或组合使用, 先将要修饰的整个正则表达式前后加一个 <code>/</code> 字符, 然后在后面的 <code>/</code> 字符后面加修饰符.</p>
<table>
<thead>
<tr>
<th align="center">标记</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td>不区分大小写: 将匹配设置为不区分大小写.</td>
</tr>
<tr>
<td align="center">g</td>
<td>全局搜索: 搜索整个输入字符串中的所有匹配.</td>
</tr>
<tr>
<td align="center">m</td>
<td>多行匹配: 会匹配输入字符串每一行.</td>
</tr>
</tbody></table>
<p>示例:</p>
<ul>
<li><p><code>/(T|t)he/gi</code> : 全局搜索, 不区分大小写, 正则: <code>(T|t)he</code></p>
</li>
<li><p><code>/.(at)/g</code> : 全局搜索, 正则: <code>.(at)</code></p>
</li>
<li><p><code>/at(.)?$/gm</code> :全局搜索, 多行匹配, 正则: <code>at(.)?$</code></p>
</li>
</ul>
<h1 id="C-中的正则表达式"><a href="#C-中的正则表达式" class="headerlink" title="C# 中的正则表达式"></a>C# 中的正则表达式</h1><ol>
<li>全部匹配</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> content = <span class="string">&quot;content&quot;</span>;</span><br><span class="line">Regex regex = <span class="keyword">new</span> Regex(<span class="string">@&quot;[0-9]&#123;8&#125;&quot;</span>);</span><br><span class="line">MatchCollection matchs = regex.Matches(content);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (Match match <span class="keyword">in</span> matchs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(match.Value))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//TODO...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>匹配第一项</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> content = <span class="string">&quot;content&quot;</span>;</span><br><span class="line">Regex regex = <span class="keyword">new</span> Regex(<span class="string">@&quot;[0-9]&#123;8&#125;&quot;</span>);</span><br><span class="line">Match match = regex.Match(content);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(match.Value))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TODO...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>Program</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 中的坐标系</title>
    <url>/unity/unity_coordinatesystem.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在制作魔剑镇魂曲的 TileMap 时用到了各种坐标系之间的转换, 当时被整得云里雾里的, 现在来回顾一下. 游戏中我只用到了笛卡尔坐标系, 没有用到极坐标系, 后面就直接简称为坐标系了.</p>
<h1 id="坐标系与坐标"><a href="#坐标系与坐标" class="headerlink" title="坐标系与坐标"></a>坐标系与坐标</h1><ul>
<li><p>首先需要强调一下坐标系和坐标完全不是一回事, 文章中有很多地方涉及到坐标系和坐标, 为了避免混淆, 一定要在脑海中清晰地区分两者. 坐标系是一个系统, 而坐标只是一个表示位置的数字.</p>
</li>
<li><p>坐标是不可能独立存在的, 它必须依存于某个坐标系, 因此很多时候我们就直接简称为某某坐标. 比如在屏幕坐标系中一个点的坐标简称为 &quot;屏幕坐标&quot;, 在世界坐标系中一个点的坐标简称为 &quot;世界坐标&quot;.</p>
</li>
</ul>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>Unity 中的坐标大致分为 4 种:</p>
<table>
<thead>
<tr>
<th align="left">坐标</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">世界坐标</td>
<td align="left">World Point</td>
</tr>
<tr>
<td align="left">本地坐标</td>
<td align="left">Local Point</td>
</tr>
<tr>
<td align="left">屏幕坐标</td>
<td align="left">Screen Point</td>
</tr>
<tr>
<td align="left">视图坐标</td>
<td align="left">View Point</td>
</tr>
</tbody></table>
<h1 id="世界坐标-World-Point"><a href="#世界坐标-World-Point" class="headerlink" title="世界坐标 (World Point)"></a>世界坐标 (World Point)</h1><ul>
<li><p>Unity 中有一个覆盖全部游戏物体的坐标系, 所有的游戏物体都靠这个坐标系来确定自身在游戏世界中的准确位置, 这个坐标系就是世界坐标系. 有时为了明显和 &quot;局部坐标系&quot; 相对应也被称为 &quot;全局坐标系&quot;. 在世界坐标系中得出的点的坐标称为世界坐标 (World Point).</p>
</li>
<li><p>但是遗憾的是在游戏物体 Inspector 面板中, Transform 处显示的 Position 是<font color='red'><strong>在父物体坐标系中的坐标</strong></font>, 而不是在世界坐标系中的坐标. 只有当物体没有父物体的时候, Transform 处显示的 Position 才是在世界坐标系中的坐标.</p>
</li>
<li><p>但是在脚本中, 使用 transform.position 获取的却是游戏物体的世界坐标.</p>
</li>
</ul>
<h1 id="本地坐标-Local-Point"><a href="#本地坐标-Local-Point" class="headerlink" title="本地坐标 (Local Point)"></a>本地坐标 (Local Point)</h1><ul>
<li><p>Unity 中每个游戏物体都有其自身坐标系, 其子物体便是使用这个坐标系来确定与父物体的相对位置关系. 在父物体坐标系下得出的点的坐标称为本地坐标 (Local Point).</p>
</li>
<li><p>由于本地坐标系和物体绑定, 因此当游戏物体进行旋转, 移动的时候, 坐标系也会进行相应的旋转和移动. 但是本地坐标却有一个特点: <font color='red'><strong>不变性</strong></font>. 当游戏物体进行旋转, 移动的时候, 其子物体的本地坐标是不变的, 即子物体相对于自身的相对位置不会改变, 因此子物体会跟随其父物体旋转, 移动.</p>
</li>
<li><p>Unity 中模型 Mesh 保存的顶点坐标均为本地坐标, 因为本地坐标的不变性, 即使物体进行旋转或者移动, 也不会影响顶点的坐标.</p>
</li>
<li><p>在脚本中使用 transform.position 获取的是游戏物体的世界坐标, 使用 transform.localPosition 获取的便是游戏物体的本地坐标. 但是当物体没有父物体的时候,  transform.localPosition 获取的也是世界坐标.</p>
</li>
</ul>
<h1 id="屏幕坐标-Screen-Point"><a href="#屏幕坐标-Screen-Point" class="headerlink" title="屏幕坐标 (Screen Point)"></a>屏幕坐标 (Screen Point)</h1><ul>
<li><p>屏幕坐标系是基于游戏窗口建立的坐标系. </p>
</li>
<li><p>屏幕坐标系以像素为单位, 窗口的左下角坐标为 (0, 0), 右上角坐标为窗口大小. 脚本中可以通过 (Screen.width, Screen.height) 来获取窗口大小.</p>
</li>
<li><p>脚本中使用 Input.mousePosition 可以获得鼠标坐标, 这个坐标便是基于屏幕坐标系计算得来的. 另外使用 Input.GetTouch(0).position 可以获得单个手指触摸屏幕时手指的坐标, 这个坐标也是基于屏幕坐标系计算得来的.</p>
</li>
<li><p>需要注意的是屏幕坐标不是根据玩家显示器的大小建立的坐标系, 而是以游戏窗口建立的坐标系, 比如玩家屏幕为: 1920 X 1080, 但是游戏窗口是: 800 X 600, 那么右上角的坐标是 (800, 600).</p>
</li>
</ul>
<h1 id="视图坐标-View-Point"><a href="#视图坐标-View-Point" class="headerlink" title="视图坐标 (View Point)"></a>视图坐标 (View Point)</h1><ul>
<li><p>摄像机预览窗口显示的画面, 也是基于游戏窗口建立的坐标系.</p>
</li>
<li><p>视图坐标系的大小为单位 1, 窗口的左下角坐标为 (0, 0), 右上角坐标为 (1, 1).</p>
</li>
<li><p>屏幕坐标单位化后得到的就是视图坐标.</p>
</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTM2NTUxL2FydGljbGUvZGV0YWlscy85MDI2OTkwOA==">Unity中屏幕坐标、视口坐标和世界坐标、局部坐标与其之间的相互转换<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cDovL2xpdXFpbmd3ZW4ubWUvMjAxNy8wNy8zMS91bmRlcnN0YW5kaW5nLWNvb3JkaW5hdGUtc3lzdGVtLWluLXVuaXR5M2Qv">理解Unity3D中的四种坐标体系<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>如何创建自定义瓦片</title>
    <url>/unity/unity_customizeTile.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="选用待继承的瓦片"><a href="#选用待继承的瓦片" class="headerlink" title="选用待继承的瓦片"></a>选用待继承的瓦片</h1><p>编写自定义瓦片其实就是通过继承 Unity 原有瓦片, 并添加新数据来创建自己的瓦片, 因此首先需要选用待继承的瓦片, 这个根据项目的需要选择即可. </p>
<p>如果瓦片需要播放动画, 便需要继承动画瓦片, 需要使用预制体就继承预制体瓦片, 需要使用普通瓦片, 随机瓦片, 规则瓦片时都可以继承自规则瓦片.</p>
<h1 id="添加自定义数据"><a href="#添加自定义数据" class="headerlink" title="添加自定义数据"></a>添加自定义数据</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 魔剑镇魂曲瓦片, 继承自 RuleTile</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line">[<span class="meta">CreateAssetMenu(fileName = <span class="meta-string">&quot;New Sword Requiem Tile.asset&quot;</span>, menuName = <span class="meta-string">&quot;Sword Requiem Tile&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SwordRequiemTile</span> : <span class="title">RuleTile</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 枚举: 地形类型</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> EM_Terrain defaultTerrainType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是我自定义的 <code>Sword Requiem Tile</code>, 只添加了一个简单的枚举类型数据.</p>
<ul>
<li><p>Serializable: 标记此类可以被序列化.</p>
</li>
<li><p>CreateAssetMenu: 标记此脚本可以在资源菜单中直接创建, 菜单项为: <code>New Sword Requiem Tile.asset</code>, 菜单项的路径为: <code>Sword Requiem Tile</code>.</p>
</li>
<li><p>SwordRequiemTile: 继承自规则瓦片, 自定义的瓦片类型.</p>
</li>
<li><p>defaultTerrainType: 自定义数据-默认地形类型.</p>
</li>
</ul>
<p>[<strong>注</strong>] 这个地方有一个挺大的坑, 可以看到我这里的自定义数据使用的是 &#39;字段&#39; 而非 &#39;属性&#39;, 因为使用属性, Inspector 面板中便无法持久保存瓦片属性. </p>
<p>表现在项目中就是, 首先创建枚举, &#39;森林&#39; 的枚举值为 0, &#39;断层&#39; 为 1, 我创建了一个 Sword Requiem Tile, 默认地形类型自动初始化为 &#39;森林&#39;, 然后修改瓦片的地形类型为 &#39;断层&#39;, 之后绘制地形, 运行游戏, 发现一切正常, 但是一旦关闭 Unity, 再次打开时所有瓦片的自定义数据全部会被重置为 &#39;森林&#39;, 即默认值, 想想这个多可怕!</p>
<p>以上情况不知道是不是我自己的失误, 总之这里使用原始的字段不会有任何问题.</p>
<h1 id="编写自定义瓦片的-Inspector-面板"><a href="#编写自定义瓦片的-Inspector-面板" class="headerlink" title="编写自定义瓦片的 Inspector 面板"></a>编写自定义瓦片的 Inspector 面板</h1><p>之前使用 &#39;属性&#39; 作为自定义数据的时候编写了 Inspector 面板的脚本, 后来改用了 &#39;字段&#39; 之后就发现根本不用单独编写脚本了, Unity 会自动进行渲染...😅 这里就先不写 Inspector 面板该如何自定义了, 因为我也不会啊~ 留一个链接, 以便日后捡起来用.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDIzNDMxNQ==">自定义属性面板<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Tile</tag>
      </tags>
  </entry>
  <entry>
    <title>战棋游戏中使用 Flood Fill 算法计算行动范围</title>
    <url>/unity/unity_floodfill.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>文章中的项目是使用 Unity 创建的 2D 游戏项目, 代码是基于 <code>Microsoft Visual Studio</code> 编写, 使用的编程语言是 <code>csharp</code>.</p>
<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p>Flood Fill 算法翻译为中文可以叫: &quot;洪水填充&quot; 算法.</p>
<p>从起始位置开始, 不断向外围进行检测, 就像从中心一点向外不断蔓延的洪水一般.</p>
<p>话说这个蔓延方式也不像洪水啊, 不应该是核弹爆炸嘛~ 今天又是核平的一天呐~ 😅</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>Flood Fill 算法的基本原理是基于一个待检查队列, 这个队列中存放接下来待检查的结点, 首先取出待检查队列中一个结点, 检查其坐标周围的四个结点, </p>
<p><img data-src="/images/floodfill/floodfill01.png" alt="Flood Fill 1"></p>
<p>将这个四个结点中满足条件的结点添加到待检查队列, 之后从待检查队列中取出下一个待检查结点以同样的规则进行检查, 再将满足条件的结点添加到待检查队列, 如此反复, </p>
<p><img data-src="/images/floodfill/floodfill02.png" alt="Flood Fill 2"></p>
<p>直到将待检查队列中的结点全部检查完毕!</p>
<h1 id="定义待检查队列中的结点类型"><a href="#定义待检查队列中的结点类型" class="headerlink" title="定义待检查队列中的结点类型"></a>定义待检查队列中的结点类型</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Data Struct 范围结点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DS_FloodFill_Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 结点的 X 坐标</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> positionX;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 结点的 Y 坐标</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> positionY;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 到达此结点时剩余的步数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> overStep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义两个 int 字段存储结点的坐标, 再定义一个 overStep, 表示从起始坐标到达此结点所在坐标时剩余的步数.</p>
<h1 id="创建算法类"><a href="#创建算法类" class="headerlink" title="创建算法类"></a>创建算法类</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 算法类: Flood Fill</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 洪水填充</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AR_FloodFill</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 算法具体内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="创建算法需要的临时变量"><a href="#创建算法需要的临时变量" class="headerlink" title="创建算法需要的临时变量"></a>创建算法需要的临时变量</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 地图数据</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">private</span> EM_Terrain[,] map;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 1. 检查过的格子</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 2. 可行动范围 (无其他数据)</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">bool</span>[,] flagChecked;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 可行动范围 (有其他数据)</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="title">List</span>&lt;<span class="title">DS_FloodFill_Node</span>&gt; range</span> = <span class="keyword">new</span> List&lt;DS_FloodFill_Node&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 1. 循环检查游标, 指明列表中 &quot;当前待检查结点&quot; 的位置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 2. 循环检查次数计数器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">int</span> checkIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 是否无视地形</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">bool</span> isIgnoreTerrain;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>map 是整张地图的数据, 虽然这里只是一个枚举数组, 但是项目中有一个字典变量, 通过这个枚举值便可以查到特定的地形类型所对应的全部数据, 包含地形名称, 地形提供的闪避率, 防御力, 攻击力, 生命回复等等. 全部的数据结构牵扯的东西比较多, 这里就不列出了.</p>
</li>
<li><p>flagChecked 用来标记算法在循环过程中哪些坐标已经被检查通过了, 这样可以避免重复检查. 另外, flagChecked 使用的存储方式是二维数组, 它是将检查过的位置标记在相应的坐标处, 且只标记通过的位置, 即 flagChecked 的值就是最终的行动范围, 但是它不附带其他的数据.</p>
</li>
<li><p>range 记录的也是被检查通过的结点, 但是它会将全部信息进行保存.</p>
</li>
<li><p>checkIndex 是待检查队列的游标, 表示当前检查到什么位置了.</p>
</li>
<li><p>isIgnoreTerrain 标识是否无视地形, 用于区分检测的是移动范围还是攻击范围.</p>
</li>
</ul>
<h1 id="实现-Flood-Fill-算法"><a href="#实现-Flood-Fill-算法" class="headerlink" title="实现 Flood Fill 算法"></a>实现 Flood Fill 算法</h1><h2 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 洪水填充算法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;map&quot;&gt;</span>地图数据<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;startPositionX&quot;&gt;</span>人物坐标 X<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;startPositionY&quot;&gt;</span>人物坐标 Y<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;minRange&quot;&gt;</span>最小直接行动范围<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;maxRange&quot;&gt;</span>最大直接行动范围<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;isIgnoreTerrain&quot;&gt;</span>是否无视地形<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>可行动范围<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">bool</span>[,] FloodFill(EM_Terrain[,] map, <span class="keyword">int</span> startPositionX, <span class="keyword">int</span> startPositionY, <span class="keyword">int</span> minRange, <span class="keyword">int</span> maxRange, <span class="keyword">bool</span> isIgnoreTerrain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 地图</span></span><br><span class="line">    <span class="keyword">this</span>.map = map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否无视地形</span></span><br><span class="line">    <span class="keyword">this</span>.isIgnoreTerrain = isIgnoreTerrain;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化存放已检查格子的数组</span></span><br><span class="line">    flagChecked = <span class="keyword">new</span> <span class="keyword">bool</span>[map.GetLength(<span class="number">0</span>), map.GetLength(<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flagChecked.GetLength(<span class="number">0</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; flagChecked.GetLength(<span class="number">1</span>); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            flagChecked[i, j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将起点存入 可行动范围</span></span><br><span class="line">    DS_FloodFill_Node startPosition = <span class="keyword">new</span> DS_FloodFill_Node</span><br><span class="line">    &#123;</span><br><span class="line">        positionX = startPositionX,</span><br><span class="line">        positionY = startPositionY,</span><br><span class="line">        overStep = maxRange,</span><br><span class="line">    &#125;;</span><br><span class="line">    range.Add(startPosition);</span><br><span class="line">    flagChecked[startPositionX, startPositionY] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描地图上特定坐标周围的格子, 计算行动范围</span></span><br><span class="line">    ScanMap(checkIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否去除起始坐标</span></span><br><span class="line">    RemoveMinRange(minRange);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据</span></span><br><span class="line">    <span class="keyword">return</span> flagChecked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法做的事情不多 (读者: 整个 Flood Fill 算法做的事情也不多好吧! !), 首先初始化算法需要的数据, 之后将初始位置存入待检查队列等待第一次检查, 记得同时更新 range 和 flagChecked 的值, 然后便可以使用 ScanMap() 方法检查整张地图了, 最后判断一下是否需要移除起始坐标, 像使用物品是可以对自己使用的, 但是移动的时候原地移动是不算真正移动了的, 攻击也同样不能攻击自己, 最后将计算好的范围返回外部, 由外部进行处理.</p>
<h2 id="ScanMap-方法"><a href="#ScanMap-方法" class="headerlink" title="ScanMap 方法"></a>ScanMap 方法</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 扫描地图上特定坐标周围的格子, 计算行动范围</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;checkIndex&quot;&gt;</span>特定坐标的索引<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ScanMap</span>(<span class="params"><span class="keyword">int</span> checkIndex</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 只要还没有将所有的可移动范围检测完, 就继续检测</span></span><br><span class="line">    <span class="keyword">while</span> (checkIndex &lt; range.Count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> positionX = range[checkIndex].positionX;</span><br><span class="line">        <span class="keyword">int</span> positionY = range[checkIndex].positionY;</span><br><span class="line">        <span class="keyword">int</span> overStep = range[checkIndex].overStep;</span><br><span class="line"></span><br><span class="line">        CheckMapPos(positionX, positionY + <span class="number">1</span>, overStep);</span><br><span class="line">        CheckMapPos(positionX - <span class="number">1</span>, positionY, overStep);</span><br><span class="line">        CheckMapPos(positionX, positionY - <span class="number">1</span>, overStep);</span><br><span class="line">        CheckMapPos(positionX + <span class="number">1</span>, positionY, overStep);</span><br><span class="line"></span><br><span class="line">        checkIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScanMap() 方法就是一个循环, 针对当前坐标计算出周围坐标, 然后使用 CheckMapPos() 方法检测特定坐标.</p>
<h2 id="CheckMapPos-方法"><a href="#CheckMapPos-方法" class="headerlink" title="CheckMapPos() 方法"></a>CheckMapPos() 方法</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 检查地图上特定坐标</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;positionX&quot;&gt;</span>特定坐标 X 轴<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;positionY&quot;&gt;</span>特定坐标 Y 轴<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;overStep&quot;&gt;</span>剩余步数<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckMapPos</span>(<span class="params"><span class="keyword">int</span> positionX, <span class="keyword">int</span> positionY, <span class="keyword">int</span> overStep</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (positionX &lt; <span class="number">0</span> || positionX &gt;= map.GetLength(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (positionY &lt; <span class="number">0</span> || positionY &gt;= map.GetLength(<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否可以到达当前单元格</span></span><br><span class="line">    overStep = isIgnoreTerrain ? overStep - <span class="number">1</span> : overStep - AD_Terrain.AD_Terrains[map[positionX, positionY]].BaseStepCost;</span><br><span class="line">    <span class="keyword">if</span> (overStep &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前单元格已经在行动范围内了</span></span><br><span class="line">    <span class="keyword">if</span> (flagChecked[positionX, positionY])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> checkedRangeDataIndex = GetCheckedRangeDataIndex(positionX, positionY);</span><br><span class="line">        <span class="keyword">if</span> (overStep &gt; range[checkedRangeDataIndex].overStep)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 更新在行动范围内的数据</span></span><br><span class="line">            DS_FloodFill_Node updatePosition = <span class="keyword">new</span> DS_FloodFill_Node</span><br><span class="line">            &#123;</span><br><span class="line">                positionX = positionX,</span><br><span class="line">                positionY = positionY,</span><br><span class="line">                overStep = overStep,</span><br><span class="line">            &#125;;</span><br><span class="line">            range[checkedRangeDataIndex] = updatePosition;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果当前单元格没有在行动范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">        DS_FloodFill_Node currentPosition = <span class="keyword">new</span> DS_FloodFill_Node</span><br><span class="line">        &#123;</span><br><span class="line">            positionX = positionX,</span><br><span class="line">            positionY = positionY,</span><br><span class="line">            overStep = overStep,</span><br><span class="line">        &#125;;</span><br><span class="line">        range.Add(currentPosition);</span><br><span class="line">        flagChecked[positionX, positionY] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CheckMapPos() 方法的重点就是退出条件.</p>
<h3 id="退出条件"><a href="#退出条件" class="headerlink" title="退出条件"></a>退出条件</h3><ol>
<li>是否越界</li>
</ol>
<p>由于我项目中地图的坐标是从 (0, 0) 开始设计的, 所以这里的越界判断自然就是这样的写法啦~</p>
<ol start="2">
<li>是否可以到达当前坐标</li>
</ol>
<p>这里的判断使用了 &#39;isIgnoreTerrain&#39; 变量, 当无视地形时, 每移动一个位置消耗的步数为 1, 用于使用物品以及攻击范围的计算, 不无视地形时, 每移动一个位置消耗的步数需要根据地形类型进行判断, 用于计算移动范围.</p>
<p>[<strong>注</strong>] 另一个需要注意的是 overStep, 里面保存的值不一定是最大剩余步数.</p>
<p>这个问题是计算行动范围时会遇到的特殊情况. 由于每个坐标消耗的步数不同, 所以经常会出现这种情况:</p>
<p><img data-src="/images/floodfill/floodfill03.png" alt="Flood Fill 3"></p>
<p>假设行动步数为 10 步, 翻越城镇城墙消耗 5 步, 进入城镇消耗 1 步, 那么:</p>
<p>路线1首先检测到了城镇入口, 到达时剩余步数为: 4;</p>
<p>路线2之后检测到了城镇入口, 到达时剩余步数为: 6;</p>
<p>于是单独写一个 if 进行判断, 如果结点已经检查过了, 那么比较两次路线的剩余步数, 并更新为大的剩余步数. 当然这个地方不写 (上面代码段中的最后一个 if else 逻辑) 也已经可以充分的实现计算行动范围了. </p>
<h2 id="独立方法"><a href="#独立方法" class="headerlink" title="独立方法"></a>独立方法</h2><p>最后便是提取出来的独立方法.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 得到已经检查过的结点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;positionX&quot;&gt;</span>特定坐标 X 轴<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;positionY&quot;&gt;</span>特定坐标 Y 轴<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>结点索引<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">GetCheckedRangeDataIndex</span>(<span class="params"><span class="keyword">int</span> positionX, <span class="keyword">int</span> positionY</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 已经检查过的就不用比较了, 因为已经检查过的剩余步数肯定已经最大了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = checkIndex + <span class="number">1</span>; i &lt; range.Count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (range[i].positionX == positionX &amp;&amp;</span><br><span class="line">            range[i].positionY == positionY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 移除小于最小范围的非法坐标</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;minRange&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RemoveMinRange</span>(<span class="params"><span class="keyword">int</span> minRange</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录下起始位置坐标</span></span><br><span class="line">    <span class="keyword">int</span> startPositionX = range[<span class="number">0</span>].positionX;</span><br><span class="line">    <span class="keyword">int</span> startPositionY = range[<span class="number">0</span>].positionY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minRange &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.Abs(startPositionX - range[i].positionX) + Math.Abs(startPositionY - range[i].positionY) &lt; minRange)</span><br><span class="line">            &#123;</span><br><span class="line">                flagChecked[range[i].positionX, range[i].positionY] = <span class="literal">false</span>;</span><br><span class="line">                range.RemoveAt(i);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样最终返回的 bool 数组便是可行动的范围!</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><span class="exturl" data-url="aHR0cHM6Ly9pdHV1ei5jb20vMjAxOS8wOS8yMS9maXJlLWVtYmxlbS1wYXRoLw==">cocos creator 实现战棋类游戏移动范围效果<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>如何让 Unity 走代理?</title>
    <url>/unity/unity_proxy.html</url>
    <content><![CDATA[<a id="more"></a>

<p>最近在学习制作 Unity 游戏, 到了最后需要发布 Android 版本游戏程序的时候, 发现根本导不出来!!! </p>
<p>每次都会卡在 Gradle 的构建上... 看了日志之后知道了原来是从仓库下载包的时候下载失败了...那我就更郁闷了, 我 24 小时全天开着梯子, 你跟我说现在还有我下载不下来的东西? 后来在这篇文章中找到了答案! <span class="exturl" data-url="aHR0cHM6Ly93d3cueW9tdW5jaGFuLm1vZS9hcmNoaXZlcy8zMjAjc2VhcmNo">解决Unity的网络水土不服问题<i class="fa fa-external-link-alt"></i></span></p>
<p>原来 Unity 压根不吃梯子啊~ ~ !</p>
<h1 id="解决方法一"><a href="#解决方法一" class="headerlink" title="解决方法一"></a>解决方法一</h1><p><strong><code>使用阿里的镜像源替代 Google 源</code></strong></p>
<ol>
<li><p>找到 Unity 的安装目录.</p>
</li>
<li><p>使用 VSCode 打开路径: <code>Editor\Data\PlaybackEngines\AndroidPlayer\Tools\GradleTemplates</code>.</p>
</li>
<li><p>对路径中的文件逐一修改, 将其中所有的</p>
</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">google()</span><br><span class="line">jcenter()</span><br></pre></td></tr></table></figure>

<p>修改为:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">maven</span><br><span class="line">&#123;</span><br><span class="line">    url <span class="string">&quot;https://maven.aliyun.com/repository/google&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">maven</span><br><span class="line">&#123;</span><br><span class="line">    url <span class="string">&quot;https://maven.aliyun.com/repository/jcenter&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><font color='red'><strong>重启 Unity 项目</strong></font>, 重新发布即可!</li>
</ol>
<p>[<strong>注</strong>]</p>
<ol>
<li><p>文件中要替换的 <code>google() jcenter()</code> 不止一处, 必须全部替换!</p>
</li>
<li><p>Unity 每次打开项目的时候, 都会从模板中复制文件, 在项目中建立缓存, 其中就包含我们刚刚修改的文件. 如果不重启项目, 那么项目中的缓存文件依旧使用的是修改前的文件, 此时发布依旧会失败, 所以必须重启 Unity 项目, 让 Unity 使用我们修改后的模板重新建立缓存!</p>
</li>
</ol>
<h1 id="解决方法二"><a href="#解决方法二" class="headerlink" title="解决方法二"></a>解决方法二</h1><p><strong><code>为 Unity Hub 和 Unity 设置代理</code></strong></p>
<p>Unity Hub 和 Unity 在连接网络时并不会读取浏览器配置, 因此梯子时无效的! 但是 Unity Hub 和 Unity 会读取环境变量中 <code>HTTP_PROXY</code> 和 <code>HTTPS_PROXY</code> 的值判断是否使用代理.</p>
<p>因此只要配置好这两个环境变量就好了, 下面是引用的这篇博客 (<span class="exturl" data-url="aHR0cHM6Ly93d3cueW9tdW5jaGFuLm1vZS9hcmNoaXZlcy8zMjAjc2VhcmNo">解决Unity的网络水土不服问题<i class="fa fa-external-link-alt"></i></span>) 中的一段:</p>
<blockquote>
<p>Windows 下, 写一个 bat 脚本, 内容如下:</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">&gt;@<span class="built_in">echo</span> off</span><br><span class="line">&gt;<span class="built_in">set</span> HTTP_PROXY = http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">1080</span></span><br><span class="line">&gt;<span class="built_in">set</span> HTTPS_PROXY = http://<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">1080</span></span><br><span class="line">&gt;<span class="built_in">start</span> &quot;&quot; &quot;C:\Program Files\Unity Hub\Unity Hub.exe&quot;</span><br></pre></td></tr></table></figure>

<p>注意, HTTPS_PROXY 的设置也是 &quot;<span class="exturl" data-url="aHR0cDovL3h4eHgmcXVvdDsv">http://xxxx&quot;<i class="fa fa-external-link-alt"></i></span>, 而不是 &quot;<span class="exturl" data-url="aHR0cHM6Ly94eHh4JnF1b3Q7Lw==">https://xxxx&quot;<i class="fa fa-external-link-alt"></i></span></p>
<p>mac 下, 脚本如下:</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">echo</span> &#x27;#!/bin/bash</span><br><span class="line">&gt;export HTTP_PROXY=proxy-url</span><br><span class="line">&gt;export HTTPS_PROXY=proxy-url</span><br><span class="line">&gt;nohup &quot;/Applications/Unity Hub.app/Contents/MacOS/Unity Hub&quot; &amp;&gt;/dev/null &amp;&#x27; &gt; launchUnityHub.command</span><br><span class="line">&gt;chmod +x launchUnityHub.command</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我用的方法是第一种方法, 确实可行! 第二种没用, 因为我不喜欢动环境变量! 😂</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW9tdW5jaGFuLm1vZS9hcmNoaXZlcy8zMjAjc2VhcmNo">解决Unity的网络水土不服问题<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoYW5nZV9mcm9tX25vdy9hcnRpY2xlL2RldGFpbHMvMTAwNTE5NTQ2">Unity使用Gradle打包出错问题<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 在脚本中修改 UGUI 中 UI 的位置和尺寸</title>
    <url>/unity/unity_rect_transform.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="🌴-前言"><a href="#🌴-前言" class="headerlink" title="🌴 前言"></a>🌴 前言</h1><p>在制作魔剑镇魂曲的对话框系统时, 在对话框的后面要显示当前人物的立绘图片, 这里的立绘图片我用的是 UGUI 里面的 Image 组件, 使用的位置组件就不再是 Transform, 而是继承自它的 RectTransform 组件, 但怎么用呢?</p>
<h1 id="🌾-RectTransform"><a href="#🌾-RectTransform" class="headerlink" title="🌾 RectTransform"></a>🌾 RectTransform</h1><p>强烈推荐一篇博客: <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kYmVmYTc0NmU1MGQ=">Unity进阶技巧 - RectTransform详解<i class="fa fa-external-link-alt"></i></span> 看完这篇博客, RectTransform 组件就基本明白了, 这里不再赘述.</p>
<h1 id="🦄-脚本控制-RectTransform"><a href="#🦄-脚本控制-RectTransform" class="headerlink" title="🦄 脚本控制 RectTransform"></a>🦄 脚本控制 RectTransform</h1><p>在 Inspector 面板中我们关注的数值:</p>
<table>
<thead>
<tr>
<th align="left">数值名</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Top</td>
<td align="left">顶部距离</td>
</tr>
<tr>
<td align="left">Bottom</td>
<td align="left">底部距离</td>
</tr>
<tr>
<td align="left">Left</td>
<td align="left">左侧距离</td>
</tr>
<tr>
<td align="left">Right</td>
<td align="left">右侧距离</td>
</tr>
<tr>
<td align="left">PosX</td>
<td align="left">位置坐标 X</td>
</tr>
<tr>
<td align="left">PosY</td>
<td align="left">位置坐标 Y</td>
</tr>
<tr>
<td align="left">Width</td>
<td align="left">宽度</td>
</tr>
<tr>
<td align="left">Height</td>
<td align="left">高度</td>
</tr>
</tbody></table>
<p>在脚本中, RectTransform 下可以获取的属性值, 同时我也列出了这些值和 Inspector 面板中数值的关系.</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">类型</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">anchoredPosition</td>
<td align="left">Vector2 : (anchoredPosition.x, anchoredPosition.y)</td>
<td align="left">(PosX, PosY)</td>
</tr>
<tr>
<td align="left">anchorMin</td>
<td align="left">Vector2 : (anchorMin.x, anchorMin.y)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">anchorMax</td>
<td align="left">Vector2 : (anchorMax.x, anchorMax.y)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">offsetMin</td>
<td align="left">Vector2 : (offsetMin.x, offsetMin.y)</td>
<td align="left">(Left, Bottom)</td>
</tr>
<tr>
<td align="left">offsetMax</td>
<td align="left">Vector2 : (offsetMax.x, offsetMax.y)</td>
<td align="left">(-Right, -Top)</td>
</tr>
<tr>
<td align="left">sizeDelta</td>
<td align="left">Vector2 : (sizeDelta.x, sizeDelta.y)</td>
<td align="left">(Width, Height)</td>
</tr>
<tr>
<td align="left">pivot</td>
<td align="left">Vector2 : (pivot.x, pivot.y)</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>在脚本中如何修改数值. 下面的代码中, 如果需要某个值不变, 直接赋予原值即可.</p>
<h2 id="Right-和-Top"><a href="#Right-和-Top" class="headerlink" title="Right 和 Top"></a>Right 和 Top</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> customTopValue = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">float</span> customRightValue = <span class="number">1.0f</span>;</span><br><span class="line">GetComponent&lt;RectTransform&gt;().offsetMax = <span class="keyword">new</span> Vector2(-customRightValue, -customTopValue);</span><br></pre></td></tr></table></figure>

<h2 id="Left-和-Bottom"><a href="#Left-和-Bottom" class="headerlink" title="Left 和 Bottom"></a>Left 和 Bottom</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> customBottomValue = <span class="number">2.0f</span>;</span><br><span class="line"><span class="keyword">float</span> customLeftValue = <span class="number">2.0f</span>;</span><br><span class="line">GetComponent&lt;RectTransform&gt;().offsetMin = <span class="keyword">new</span> Vector2(customLeftValue, customBottomValue);</span><br></pre></td></tr></table></figure>

<h2 id="PosX-和-PosY"><a href="#PosX-和-PosY" class="headerlink" title="PosX 和 PosY"></a>PosX 和 PosY</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> customPosXValue = <span class="number">3.0f</span>;</span><br><span class="line"><span class="keyword">float</span> customPosYValue = <span class="number">3.0f</span>;</span><br><span class="line">GetComponent&lt;RectTransform&gt;().anchoredPosition = <span class="keyword">new</span> Vector2(customPosXValue, customPosYValue);</span><br></pre></td></tr></table></figure>

<h2 id="Width-和-Height"><a href="#Width-和-Height" class="headerlink" title="Width 和 Height"></a>Width 和 Height</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> customWidthValue = <span class="number">4.0f</span>;</span><br><span class="line"><span class="keyword">float</span> customHeightValue = <span class="number">4.0f</span>;</span><br><span class="line">GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(customWidthValue, customHeightValue);</span><br></pre></td></tr></table></figure>

<h1 id="🐬-属性之间的关系"><a href="#🐬-属性之间的关系" class="headerlink" title="🐬 属性之间的关系"></a>🐬 属性之间的关系</h1><h2 id="anchoredPosition-和-pivot-offsetMin-offsetMax"><a href="#anchoredPosition-和-pivot-offsetMin-offsetMax" class="headerlink" title="anchoredPosition 和 pivot, offsetMin, offsetMax"></a>anchoredPosition 和 pivot, offsetMin, offsetMax</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">anchoredPosition = ((Vector2.one - pivot) * offsetMin) + (pivot * offsetMax);</span><br></pre></td></tr></table></figure>

<h2 id="sizeDelta-和-offsetMin-offsetMax"><a href="#sizeDelta-和-offsetMin-offsetMax" class="headerlink" title="sizeDelta 和 offsetMin, offsetMax"></a>sizeDelta 和 offsetMin, offsetMax</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sizeDelta = offsetMax - offsetMin;</span><br></pre></td></tr></table></figure>

<h1 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a>总结图</h1><p><img data-src="/images/rectTransform/rectTransform.png" alt="RectTransform"></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kYmVmYTc0NmU1MGQ=">Unity进阶技巧 - RectTransform详解<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnNreS9wLzUwNDUyMDEuaHRtbA==">修改RectTransform的值<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>UGUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity - 2D 精灵 和 3D 物体的渲染顺序</title>
    <url>/unity/unity_render_order.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h1><p>我在学习 SiKi 学院出的一款捕鱼达人的游戏教程时, 教程中使用了一个 3D 物体, 在其上面制作水波纹特效, 为了容易观察渲染层级, 我还特意将同一个层级 (Sorting Layer) 的精灵全部放到同一个 Z 位置上, 一共分了四层.</p>
<p><img data-src="/images/unity_render_order/unity_render_order_1.png" alt="3D 游戏物体被遮挡"></p>
<p>但是从相机预览效果中可以看出, 水波纹效果被遮挡了. 在这个场景中所有的 Canvas 的渲染层级都是一个自定义的 UI 层, 但是这个 3D 游戏物体的层级该怎么设置呢? 根本找不到设置的地方啊? 😥</p>
<h1 id="MeshRenderer-与-SpriteRenderer-的渲染顺序"><a href="#MeshRenderer-与-SpriteRenderer-的渲染顺序" class="headerlink" title="MeshRenderer 与 SpriteRenderer 的渲染顺序"></a>MeshRenderer 与 SpriteRenderer 的渲染顺序</h1><p>3D 游戏物体使用的是 MeshRenderer, 2D 精灵使用的是 SpriteRenderer, 两者都是继承自 Renderer, 在 Renderer 中渲染层级是 <code>sortingLayerName</code> 字段, 渲染顺序是 <code>sortingOrder</code> 字段.</p>
<ol>
<li><p>SpriteRenderer 中的 <code>Sorting Layer</code> 对应的是 sortingLayerName 字段, <code>Order in Layer</code> 对应的是 sortingOrder 字段.</p>
</li>
<li><p>在 MeshrRenderer 中这两个字段并没有做处理, 只是在面板上隐藏了而已, 因此可以在脚本中直接使用.</p>
 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> orderinLayer = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> sortingLayer = <span class="string">&quot;UI&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MeshRenderer meshRenderer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    meshRenderer = GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设定 3D 游戏物体的渲染层级</span></span><br><span class="line">    meshRenderer.sortingLayerName = sortingLayer;</span><br><span class="line">    meshRenderer.sortingOrder = orderinLayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 ParticleSystem 中同样也有 Renderer 组件控制粒子特效的渲染顺序, 同样可以使用脚本控制, 也可以直接在面板上设置.</p>
 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> orderinLayer = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> sortingLayer = <span class="string">&quot;UI&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ParticleSystem[] particleSystems;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设定粒子特效的渲染层级</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; particleSystems.Length; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        rendererParticle = particleSystems[index].GetComponent&lt;Renderer&gt;();</span><br><span class="line">        rendererParticle.sortingLayerName = sortingLayer;</span><br><span class="line">        rendererParticle.sortingOrder = orderinLayer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="问题解决后效果"><a href="#问题解决后效果" class="headerlink" title="问题解决后效果"></a>问题解决后效果</h1><p>使用上面脚本中的设置就可以让 MeshRenderer 也参与到 2D UI 的排序中来了, 效果还是不错的.</p>
<p><img data-src="/images/unity_render_order/unity_render_order_2.png" alt="修复后效果"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82YmNjZjc5ZmEzNjc=">SpriteRenderer 与 MeshRenderer的渲染排序层级<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity TileMap 瓦片与瓦片之间的线条</title>
    <url>/unity/unity_tileborderline.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在使用 TileMap 制作 2D 游戏的时候, 发现瓦片与瓦片之间总是存在一条缝隙, 这条缝隙什么颜色的都有, 可是我已经把所有素材的过滤方式都设置为了: &quot;Point (no filter)&quot;, 为什么还会有这个问题呢? 原本以为是瓦片之间没拼接好, 大小没设置对(原谅我没有图形学方面的知识), 后来查阅资料得知, 目前美工在制作 2D 游戏素材时, 基本都会将同类的精灵图放到一张贴图中, 这样紧贴着的两个精灵图在某种特殊情况下就会出现使用了相邻精灵图中像素的问题. </p>
<p><img data-src="/images/unity_tileborderline/tileborderline0.png" alt="精灵图放到一张贴图中"></p>
<p>从上面的素材图中可以看到, 多个精灵图组成了一张贴图, 其中中间位置的一张看似像 &quot;车轮印&quot; 的精灵图和右侧一张表示 &quot;海洋&quot; 的贴图相连, 于是在游戏中就会出现这种情况:</p>
<p><img data-src="/images/unity_tileborderline/tileborderline1.png" alt="蓝色细线, 万恶之源"></p>
<p>代表 &quot;车轮印&quot; 精灵图的右侧就会出现代表 &quot;海洋&quot; 精灵图的一个蓝色的像素, 导致出现了一条蓝色的细线. 实乃万恶之源!</p>
<p>先说一下已经试过的网友们的方法.</p>
<h1 id="将-TileMap-的-cell-大小设置为接近-1-的值"><a href="#将-TileMap-的-cell-大小设置为接近-1-的值" class="headerlink" title="将 TileMap 的 cell 大小设置为接近 1 的值"></a>将 TileMap 的 cell 大小设置为接近 1 的值</h1><p>默认情况下 TileMap 中 cell 的大小为 1 个单位, 瓦片在地图中的大小通常也是一个单位, 于是就想到将 cell 大小设置为比 1 个单位小那么一丢丢, 让最外围的一个像素不显示出来不就好了~ 赶紧尝试一下, 于是:</p>
<p><img data-src="/images/unity_tileborderline/tileborderline2.png" alt="改变 cell 大小"></p>
<p>乍看上去好像没有细线了, 但是放大一下就会发现, 不仅是右侧有蓝色的细线, 现在上方也有了...呃...看来这种方法不适合我啊~</p>
<h1 id="建立图集"><a href="#建立图集" class="headerlink" title="建立图集"></a>建立图集</h1><p>听另一位大佬说, 将精灵图添加到图集时, Unity 会自动补全像素, 因此可以作为一个解决此问题的办法, 于是赶紧照着大佬说的操作一番~ 然后:</p>
<p><img data-src="/images/unity_tileborderline/tileborderline3.png" alt="建立图集"></p>
<p>关于图集的知识我也不是很懂, 总之依旧没有实现比较完美的效果, 或者是让我满意的效果...可以看到图中确实已经没有了蓝色的细线, 但是会发现瓦片与瓦片之间的衔接变得很不自然, 有一条明显的分界线...呃...看来这种方法同样不适合我~</p>
<hr>
<h1 id="素材分辨率"><a href="#素材分辨率" class="headerlink" title="素材分辨率"></a>素材分辨率</h1><p>后来我想到了之前做泰拉瑞亚的仿制 demo 时曾出现过的一个情况, 当时自己从网上搞来一批素材, 开始搭建人物. 人物的素材是拆成很多部分的, 我在拼接这些部分的时候发现像素对应不起来, 当时我的解决办法是把图片的分辨率改成了 2 的幂, 当时改成了 64, 然后像素就能对应上了. 同时我也发现 Unity 中有一项 Max Size 的设置, 这里也只支持 2 的幂, 会不会就是这里导致 Unity 会自动补全像素呢? 于是我赶紧将素材都改为了 2 的幂, 256 X 256, 重新导入并设置好后, 神奇的一幕发生了: </p>
<p><img data-src="/images/unity_tileborderline/tileborderline4.png" alt="处理素材"></p>
<p>而且瓦片与瓦片之间也衔接的不错, 虽然仔细观察还是有瑕疵, 但是这应该是素材自身的问题了!</p>
<p><img data-src="/images/unity_tileborderline/tileborderline5.png" alt="瓦片之间的衔接"></p>
<h1 id="MSAA-多重采样"><a href="#MSAA-多重采样" class="headerlink" title="MSAA 多重采样"></a>MSAA 多重采样</h1><p>再到后来编写摄像机脚本的时候, 发现摄像机中有一个 MSAA 的设置选项, 忽然想起之前大佬提到过 MSAA 啊! 赶紧查一下 MSAA 是啥!</p>
<p>MSAA 是 &quot;多重采样&quot; 技术, 用来实现 &quot;抗锯齿&quot; 的效果. 在不规则图形的渲染中需求比较大. 下面是一张简单表示 MSAA 效果的图片. (引用自文章: <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjgyMzM3MA==">深入剖析MSAA<i class="fa fa-external-link-alt"></i></span>)</p>
<p><img data-src="/images/unity_tileborderline/msaa.png" alt="MSAA"></p>
<p>由此可见在没有开启 MSAA 时, 一条斜线上的锯齿感非常明显, 开始 MSAA 之后, 斜线上的锯齿感便开始弱化. 理想状态下可以无限接近于真正的斜线.</p>
<p>但是在我这个项目中, MSAA 反而会形成困扰, 导致瓦片之间衔接不好, 甚至出现前面所说的细线, 毕竟游戏本就是像素风格嘛~ 于是我开始好奇将 MSAA 关闭后会有什么效果呢?</p>
<p><img data-src="/images/unity_tileborderline/tileborderline6.png" alt="关闭 MSAA"></p>
<p>于是我回退到之前没有修改素材分辨率的版本, 找到摄像机中的 MSAA 选项, 选择 &quot;Off&quot;, 然后神奇的一幕又发生了, 关闭 MSAA 后, 也实现了近乎完美的瓦片衔接...</p>
<p>那我之前耗费那么多时间处理素材是图啥子嘞~ 😭 又吃了没文化的亏~</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果你的项目中也出现了文章中所提到的问题, 不妨尝试尝试这几种方法:</p>
<ol>
<li><p>将 TileMap 的 cell 大小设置为接近 1 的值.</p>
</li>
<li><p>建立图集, 在图集的 Padding 处设置自动补全的像素值, 可选: 2 4 8.</p>
<p> <img data-src="/images/unity_tileborderline/tileborderline7.png" alt="图集自动补全像素"></p>
</li>
<li><p>处理素材的分辨率为 2 的幂.</p>
</li>
<li><p>关闭 MSAA</p>
</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAyNzU5MzIvYXJ0aWNsZS9kZXRhaWxzLzEwNjYwODE0Mw==">3D 瓦片地图采坑录<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjgyMzM3MA==">深入剖析 MSAA<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhcmtyYWJiaXQvYXJ0aWNsZS9kZXRhaWxzLzc5MTgxOTQ1">绘制地图(Tile Map)<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhcmtyYWJiaXQvYXJ0aWNsZS9kZXRhaWxzLzc5MjEyNjI1">图集(Atlas)<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>TileMap</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp 迭代器</title>
    <url>/csharp/ienumerator.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="🌴前言"><a href="#🌴前言" class="headerlink" title="🌴前言"></a>🌴前言</h1><p>在之前的 csharp 学习过程中学习了索引器, 这样我自定义类中的数据也就可以使用方括号的形式进行访问啦, 同时我还看到了一个 &quot;迭代器&quot; 的词汇, 这是啥东西啊? 网上一查, 标志性词汇是 &quot;IEnumerable&quot; 和 &quot;IEnumerator&quot;...这个我熟悉啊, Unity 的协程 &#39;Coroutines&#39; 技术中也使用到了这个词汇, 那赶紧看看其中的知识吧.</p>
<h1 id="🍀C-1-0-中的迭代器"><a href="#🍀C-1-0-中的迭代器" class="headerlink" title="🍀C# 1.0 中的迭代器"></a>🍀C# 1.0 中的迭代器</h1><p>C# 1.0 中, 迭代模式是通过两个接口实现的: <strong>IEnumerable</strong> 和 <strong>IEnumerator</strong>.</p>
<ol>
<li><p>&quot;正确实现了 IEnumerable 接口&quot; 或者 &quot;具有完全符合特征的方法&quot; 的类型可以被迭代访问, 比如 C# 内置的数组, 链表类型, 这些都可以被迭代访问, 它们都实现了 IEnumerable 接口.</p>
<p> <img data-src="/images/csharp/ienumerator/ienumerator_01.png" alt="内置可被迭代类型"></p>
</li>
</ol>
<p>但是正确实现了 IEnumerable 接口的并不是迭代器, IEnumerable 接口中只有一个需要实现的方法 <strong>GetEnumerator()</strong>, 这个方法作用是会返回一个迭代器, 并不是实现一个迭代器.</p>
<ol start="2">
<li>正确实现了 IEnumerator 接口的类型才是迭代器.</li>
</ol>
<h2 id="C-1-0-中如何自己实现一个可迭代访问的类型"><a href="#C-1-0-中如何自己实现一个可迭代访问的类型" class="headerlink" title="C# 1.0 中如何自己实现一个可迭代访问的类型"></a>C# 1.0 中如何自己实现一个可迭代访问的类型</h2><p>C# 1.0 中, 想要实现一个可以被迭代访问的类型, 只要让这个类型正确实现 IEnumerable 接口即可. IEnumerable 接口中只有一个需要实现的方法 <strong>GetEnumerator()</strong>, 没有参数, 返回值类型是 <code>IEnumerator</code>. 比如实现一个可以迭代访问的 CharList 类型.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 可迭代类型 CharList</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CharList</span> : <span class="title">IEnumerable</span> <span class="comment">// 继承接口 IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 枚举数据</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> charArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 构造器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;str&quot;&gt;</span>枚举数据<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharList</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        charArray = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> IEnumerable 中的 GetEnumerator 方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CharEnumerator(charArray); <span class="comment">// new 一个迭代器并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-1-0-中如何自己实现一个迭代器类型"><a href="#C-1-0-中如何自己实现一个迭代器类型" class="headerlink" title="C# 1.0 中如何自己实现一个迭代器类型"></a>C# 1.0 中如何自己实现一个迭代器类型</h2><p>C# 1.0 中, 想要实现一个迭代器类型, 只要让这个类型正确实现 IEnumerator 接口即可. IEnumerator 接口中需要实现的内容有:</p>
<blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// 摘要:</span></span><br><span class="line">   <span class="comment">//     获取集合中位于枚举数当前位置的元素。</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// 返回结果:</span></span><br><span class="line">   <span class="comment">//     集合中位于枚举数当前位置的元素。</span></span><br><span class="line">   <span class="keyword">object</span> Current &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// 摘要:</span></span><br><span class="line">   <span class="comment">//     将枚举数推进到集合的下一个元素。</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// 返回结果:</span></span><br><span class="line">   <span class="comment">//     如果枚举数已成功地推进到下一个元素，则为 true；如果枚举数传递到集合的末尾，则为 false。</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// 异常:</span></span><br><span class="line">   <span class="comment">//   T:System.InvalidOperationException:</span></span><br><span class="line">   <span class="comment">//     创建枚举器后，已修改该集合。</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// 摘要:</span></span><br><span class="line">   <span class="comment">//     将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// 异常:</span></span><br><span class="line">   <span class="comment">//   T:System.InvalidOperationException:</span></span><br><span class="line">   <span class="comment">//     创建枚举器后，已修改该集合。</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><p>Current 属性. 必须是 public 修饰, 必须返回 object 类型, 必须实现 Get 器, 必须遵守的 Get 器规则: 获取当前索引位置的值.</p>
</li>
<li><p>MoveNext 方法. 必须是 public 修饰, 必须返回 bool 类型. 必须遵守的返回值规则: 如果可以获取下一个值, 返回 true, 如果无法或许下一个值, 则返回 false.</p>
</li>
<li><p>Reset 方法. 必须是 public 修饰, 必须返回 void 类型. 必须遵守的逻辑规则: 将此时的索引位置设置为 <font color='red'><strong>第一个元素之前</strong></font>.</p>
</li>
</ol>
<p>只有同时满足了上面全部要求, 才算是正确实现了一个迭代器.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 迭代器 CharEnumerator</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CharEnumerator</span> : <span class="title">IEnumerator</span> <span class="comment">// 继承 IEnumerator 接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 枚举数据</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> charArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 索引位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 构造器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;str&quot;&gt;</span>枚举数据<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharEnumerator</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        currentIndex = <span class="number">-1</span>; <span class="comment">// 初始化索引位置</span></span><br><span class="line">        charArray = str; <span class="comment">// 初始化枚举数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> IEnumerator 中的 Current 属性</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> Current</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> charArray[currentIndex]; <span class="comment">// 获取当前索引位置的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> IEnumerator 中的 MoveNext 方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>如果可以获取下一个值, 返回 true, 如果无法或许下一个值, 则返回 false.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> ++currentIndex &lt; charArray.Length; <span class="comment">// 如果 &quot;索引位置&quot; 自增后小于枚举数据长度, 说明可以获取下一个值, 返回 true, 否则返回 false.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> IEnumerator 中的 Reset 方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        currentIndex = <span class="number">-1</span>; <span class="comment">// 将索引位置设置为第一个元素之前</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码段实现了一个最基础的迭代器, 这样 CharList 这个类型便可以使用 foreach 进行迭代访问了.</p>
<h1 id="✨C-2-0-中的迭代器"><a href="#✨C-2-0-中的迭代器" class="headerlink" title="✨C# 2.0 中的迭代器"></a>✨C# 2.0 中的迭代器</h1><p>C# 2.0 中便可以使用 <code>yield return</code> 来简化迭代器的实现. 这样相比 1.0, 我们直接可以省略一个 CharEnumerator 类的实现, 方便了很多.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CharList</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 枚举数据</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> charArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 构造器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;str&quot;&gt;</span>枚举数据<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharList</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        charArray = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> IEnumerable 中的 GetEnumerator 方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> charArray[i]; <span class="comment">// 使用 yield return 构造一个迭代器</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="🦄迭代器的执行顺序"><a href="#🦄迭代器的执行顺序" class="headerlink" title="🦄迭代器的执行顺序"></a>🦄迭代器的执行顺序</h1><p>将 C# 1.0 迭代器例子补全 (本文最后附有已补全的代码), 并在一个 foreach 中进行逐步调试就可以看到迭代访问时的代码执行顺序.</p>
<p><code>foreach (var item in charList)</code></p>
<ol>
<li><p>charList: 调用 GetEnumerator 方法.</p>
</li>
<li><p>in: 调用 MoveNext 方法.</p>
</li>
<li><p>item: 获取 Current 属性.</p>
</li>
</ol>
<p>但是如果我们没有使用 C# 1.0 提供的形式实现迭代器, 而是使用了 C# 2.0 中的 yield return 实现迭代器, 那么此时迭代器的执行顺序又是什么呢?</p>
<p>我们来做一个例子测试一下, 先创建一个类 <code>CreateEnumerable</code>, 这个类可以返回一个可迭代器类型 <code>IEnumerable&lt;int&gt;</code>, 之后使用 <code>GetEnumerator</code> 方法获取迭代器, 然后使用 while 循环手动调用迭代器的 <code>MoveNext</code> 方法以及 <code>Current</code> 属性, 并输出执行顺序.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Exercise</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> runIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span> Padding = <span class="keyword">new</span> <span class="keyword">string</span>(<span class="string">&#x27;\t&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">CreateEnumerable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0,3&#125; : &#123;1&#125;Start of CreateEnumerable&quot;</span>, runIndex, Padding); runIndex++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0,3&#125; : &#123;1&#125;\tBefore yield &#123;2&#125;&quot;</span>, runIndex, Padding, i); runIndex++;</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0,3&#125; : &#123;1&#125;\tAfter yield&quot;</span>, runIndex, Padding); runIndex++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0,3&#125; : &#123;1&#125;Yielding final value&quot;</span>, runIndex, Padding); runIndex++;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0,3&#125; : &#123;1&#125;End of CreateEnumerable()&quot;</span>, runIndex, Padding); runIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// 创建一个可以迭代访问的实例</span></span><br><span class="line">            IEnumerable&lt;<span class="keyword">int</span>&gt; iterable = CreateEnumerable();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取这个实例中的迭代器</span></span><br><span class="line">            IEnumerator&lt;<span class="keyword">int</span>&gt; iterator = iterable.GetEnumerator();</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0,3&#125; : Starting to iterate&quot;</span>, runIndex); runIndex++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0,3&#125; : Calling MoveNext()...&quot;</span>, runIndex); runIndex++;</span><br><span class="line">                <span class="keyword">bool</span> result = iterator.MoveNext(); <span class="comment">// 调用迭代器的 MoveNext 方法</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0,3&#125; : ...MoveNext result=&#123;1&#125;&quot;</span>, runIndex, result); runIndex++;</span><br><span class="line">                <span class="keyword">if</span> (!result) <span class="keyword">break</span>;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0,3&#125; : Fetching Current...&quot;</span>, runIndex); runIndex++;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0,3&#125; : ...Current result=&#123;1&#125;&quot;</span>, runIndex, iterator.Current); runIndex++; <span class="comment">// 获取迭代器的 Current 属性</span></span><br><span class="line">            &#125;</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> 0 : Starting to iterate</span><br><span class="line"> 1 : Calling MoveNext()...</span><br><span class="line"> 2 :                           Start of CreateEnumerable</span><br><span class="line"> 3 :                                   Before yield 0</span><br><span class="line"> 4 : ...MoveNext result=True</span><br><span class="line"> 5 : Fetching Current...</span><br><span class="line"> 6 : ...Current result=0</span><br><span class="line"> 7 : Calling MoveNext()...</span><br><span class="line"> 8 :                                   After yield</span><br><span class="line"> 9 :                                   Before yield 1</span><br><span class="line">10 : ...MoveNext result=True</span><br><span class="line">11 : Fetching Current...</span><br><span class="line">12 : ...Current result=1</span><br><span class="line">13 : Calling MoveNext()...</span><br><span class="line">14 :                                   After yield</span><br><span class="line">15 :                                   Before yield 2</span><br><span class="line">16 : ...MoveNext result=True</span><br><span class="line">17 : Fetching Current...</span><br><span class="line">18 : ...Current result=2</span><br><span class="line">19 : Calling MoveNext()...</span><br><span class="line">20 :                                   After yield</span><br><span class="line">21 :                           Yielding final value</span><br><span class="line">22 : ...MoveNext result=True</span><br><span class="line">23 : Fetching Current...</span><br><span class="line">24 : ...Current result=-1</span><br><span class="line">25 : Calling MoveNext()...</span><br><span class="line">26 :                           End of CreateEnumerable()</span><br><span class="line">27 : ...MoveNext result=False</span><br></pre></td></tr></table></figure>

<p>从输出结果中可以看出使用 yield return 所创建的迭代器的运行步骤如下.</p>
<ol>
<li><p>直到第一次执行 <code>MoveNext</code> 方法时, 程序才会进入到 <code>CreateEnumerable</code> 方法中执行.</p>
</li>
<li><p>之后在方法 CreateEnumerable 中, 遇到 <code>yield return</code> 时会跳出方法, 回到之前的 MoveNext 处, 使 MoveNext 返回 <code>true</code>, 并继续向下执行.</p>
</li>
<li><p>直到经由 while 循环再次遇到 MoveNext 方法时, 程序便会再次进入 CreateEnumerable 方法, 并且是从上次跳出方法的位置, 即 yield return 位置处继续向下执行 for 循环.</p>
</li>
<li><p>最后一次执行 MoveNext 方法时, 程序进入 CreateEnumerable 方法, 但是此时 CreateEnumerable 方法中已经没有可执行的 yield return 语句了, 于是运行完 CreateEnumerable 方法的最后一条语句后跳出 CreateEnumerable 方法, 使 MoveNext 返回 <code>false</code>, 并继续向下执行.</p>
</li>
<li><p>遇到 break 跳出 while 循环, 程序结束.</p>
</li>
</ol>
<p>从 CreateEnumerable 内部来看, yield return 相当于暂时退出了方法去执行另一段代码, 另一端代码执行完之后, 再回到 yield return 的位置继续执行.</p>
<h1 id="yield-break-退出迭代器"><a href="#yield-break-退出迭代器" class="headerlink" title="yield break 退出迭代器"></a>yield break 退出迭代器</h1><p>一般情况下, <code>return</code> 的作用是用于返回给调用者方法的结果或者结果一个方法的运行, 并在返回数值或者结束方法运行之前运行 <code>finally</code> 中的语句. </p>
<p>在返回值为 IEnumerable&lt;&gt; 类型的方法中, 如果想快速退出方法, 可以使用 <code>yield break</code>.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">CountWithTimeLimit</span>(<span class="params">DateTime limit</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (DateTime.Now &gt;= limit)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Finally: Stopping&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line">        DateTime stopTime = DateTime.Now.AddSeconds(<span class="number">2</span>); <span class="comment">// 获取 2 秒后的时间</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Start of Main&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">int</span> index <span class="keyword">in</span> program.CountWithTimeLimit(stopTime))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\tReceived &#123;0&#125;&quot;</span>, index);</span><br><span class="line"></span><br><span class="line">            System.Threading.Thread.Sleep(<span class="number">300</span>); <span class="comment">// 毫秒</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;End of Main&quot;</span>);</span><br><span class="line">        Console.Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Start of Main</span><br><span class="line">        Received 1</span><br><span class="line">        Received 2</span><br><span class="line">        Received 3</span><br><span class="line">        Received 4</span><br><span class="line">        Received 5</span><br><span class="line">        Received 6</span><br><span class="line">        Received 7</span><br><span class="line">Finally: Stopping</span><br><span class="line">End of Main</span><br></pre></td></tr></table></figure>

<p>可以看出, <code>yield return</code> 只是暂时离开方法, 到另一个位置执行其他的代码, 并不会执行 finally 语句块, 而 <code>yield break</code> 则直接转而执行了 finally 语句块中的语句, 并彻底结束了 foreach 的运行.</p>
<h1 id="🍒参考文献"><a href="#🍒参考文献" class="headerlink" title="🍒参考文献"></a>🍒参考文献</h1><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2lsYmVyMjAxMy9wLzQyOTk1MjkuaHRtbA==">C#迭代器<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="🙄代码"><a href="#🙄代码" class="headerlink" title="🙄代码"></a>🙄代码</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Exercise</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CharList charList = <span class="keyword">new</span> CharList(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> charList)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(item);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 可迭代类型 CharList</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CharList</span> : <span class="title">IEnumerable</span> <span class="comment">// 继承接口 IEnumerable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 枚举数据</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> charArray;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 构造器</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;str&quot;&gt;</span>枚举数据<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CharList</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            charArray = str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> IEnumerable 中的 GetEnumerator 方法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CharEnumerator(charArray); <span class="comment">// new 一个迭代器并返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 迭代器 CharEnumerator</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CharEnumerator</span> : <span class="title">IEnumerator</span> <span class="comment">// 继承 IEnumerator 接口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 枚举数据</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">string</span> charArray;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 索引位置</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> currentIndex;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 构造器</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;str&quot;&gt;</span>枚举数据<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CharEnumerator</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            currentIndex = <span class="number">-1</span>; <span class="comment">// 初始化索引位置</span></span><br><span class="line">            charArray = str; <span class="comment">// 初始化枚举数据</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> IEnumerator 中的 Current 属性</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">object</span> Current</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> charArray[currentIndex]; <span class="comment">// 获取当前索引位置的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> IEnumerator 中的 MoveNext 方法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>如果可以获取下一个值, 返回 true, 如果无法或许下一个值, 则返回 false.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> ++currentIndex &lt; charArray.Length; <span class="comment">// 如果 &quot;索引位置&quot; 自增后小于枚举数据长度, 说明可以获取下一个值, 返回 true, 否则返回 false.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> IEnumerator 中的 Reset 方法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            currentIndex = <span class="number">-1</span>; <span class="comment">// 将索引位置设置为第一个元素之前</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>日记系列--2020年02月</title>
    <url>/diary/2020_02.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>感觉好久没写日记了, 有好多好多想要记录下来的事情, 这个系列的主题也悄悄地改变了, 日记日记嘛, 是写给未来的自己看的, 之前的我都给犯了一个错误, 那就是把读者当成是来看我博客的人, 这说白了就不是日记了, 那就和在 Twitter 上发表动态一样了, 这是最重要的一个转变, 其他的后面再说, 未来的自己, 你现在过得还好吗? (微笑脸)</p>
<h1 id="2020-年-02-月-25-号"><a href="#2020-年-02-月-25-号" class="headerlink" title="2020 年 02 月 25 号"></a>2020 年 02 月 25 号</h1><p>2 月 25 号了......哈哈😂, 说出来自己都不敢相信啊, 不知不觉又玩了这么久, 上一篇日记是 2020 年 01 月 18 号, 就是说已经 38 天没写日记了, 哈哈, 拖出去打死...😒</p>
<h2 id="武汉疫情"><a href="#武汉疫情" class="headerlink" title="武汉疫情"></a>武汉疫情</h2><p>说正题吧, 不知道未来的我, 你现在还记不记得哈, 2020 年春节武汉爆发了新型冠状病毒, 目前的情况是已经累计确诊了 77779 人了, 当前还剩余的确诊人数有 47672 人, 累计死亡人数已经达到了 2666 人, 未来的我, 如果你已经对这个死亡数字没什么感想了, 那我可得狠狠地打你一拳, 把你打醒, 你现在应该已经结婚了吧, 你可以这样想一下: 你设想你最爱的妻子, 现在就在你的面前被人狠狠地刺了一刀, 然后不治身亡. 而这次疫情就意味着 &quot;最爱的人死亡&quot; 这件事在 2020 年 01 月和 02 月这短短的两个月内发生了 2666 次. 你还会觉得少吗? 我现在狠不得一个人都不死.</p>
<p>好了好了, 这个话题太沉重了, 其实咱们当时山东这边管控的还不错, 每天戴口罩, 尽量不外出, 不和武汉人接触, 电梯每日消毒, 出入小区测体温, 下班回家要出示身份证, 出示上班证明, 公司上班全程带口罩, 基本也就这些了, 接下来说的别的吧.</p>
<h2 id="博客主题改变的原因"><a href="#博客主题改变的原因" class="headerlink" title="博客主题改变的原因"></a>博客主题改变的原因</h2><p>上面已经和你说了, 这个系列的主题从 &quot;分享&quot; 变成了 &quot;记录&quot;, 记录自己当下遇到的事情, 记录自己对待这些事情时当下的心情, 好让将来的自己回忆起自己的往事, 还能够想起当时的心情. 但是这只是结果, 就是主题改变了, 但是我还没有交代原因哈, 为什么主题会改变呢? 前言里说是自己意识到了这是日记, 不是动态, 所以主题不该是分享, 而是记录, 后来捋了捋发现, 这只是主题改变了之后, 又不想说出自己那丑陋的心态而圆的自己的话而已, 下面说一下真正的原因吧, 但是说原因的时候, 我又必须先说明一下我现在的背景, 因为未来的我, 你现在的背景和现在的我肯定是不一样的, 希望看了下面的话你能想起我现在的心情.</p>
<p>首先我现在还是单身哈, 然后目前有两个挺在意的女孩, 一个是黎雅倩, 一个是巧巧, 我现在和她们都有交流, 但是交流都开始慢慢变少哈, 不知道未来的我, 你会选择谁哈, 目前以我来看, 我是谁都不会选的, 因为现在的我真的是太糟糕了, 我真的挺好奇的, 如果你现在结婚了, 那么到底是谁看上你了(我并不仅仅指这两位女孩), 哪个女的瞎成这样, TM 能看上你? ? ? 就你那烂脾气, 你那外面一套家里一套的超级糟糕习惯居然有人能受得了你? ? ? 嘛, 可能你现在还单身呢, 哈哈! 扯远了, 回归正题. 在我回顾 1 月份写的日记的时候, 我发现全是负面情绪, 几乎找不到积极乐观的一面, 那你说我写这东西干嘛? 我分享这东西干嘛? 为了降低别人对我的好感度? 为了让别人提起我, 就说我是一个病丧? 整天郁郁寡欢, 没点好情绪, 关键是我发现, 不仅仅是博客, 最近在和其他人的 &quot;聊天&quot; 中也全是负面情感, 不仅仅是上面提到的那两位女孩, 和大学舍友们 (王健, 吴逸然) 也是这样, 于是我就有了断掉这个系列的想法, 因为我总是在向外人传达负面情感, 垃圾情感, 黑色情感, 我再继续这样下去, 不仅朋友们会渐渐远离我, 甚至我自己还会黑化, 然后自暴自弃, 这绝对不行, 于是断掉这个系列的想法越来越强烈.</p>
<p>带着这种想法, 加上武汉现在的疫情导致几乎不能外出, 于是我又开始了玩游戏, 中间呢也穿插着看动漫, 大部分是哆啦A梦的剧场版, 最开始玩 &quot;时空召唤&quot;, 还打上了 宗师 段位, 相当于 LOL 里面的大师, 最终分数是宗师 16 分, 但是其实刚进入宗师起步就是 25 分哈, 就是说我在 宗师 段位基本全是在输; 之后新赛季开始, 我就不玩了, 去玩最终幻想 6 了, 玩到快通关了, 游戏模式变成了类似开放世界的玩法, 超高自由度, 于是我就又不玩了, 因为自由度太高了, 我不知道该去哪里推进下一部分剧情啊...之后便回济南工作了, 公司在上班这件事情上管得是贼细致, 贼严谨, 上下午的工作状态是在家办公啊还是请假啊记录地是清清楚楚, 明明白白, 提前说好在家办公和请假没有基础工资只有绩效, 但是公司不开空调, 说是为了防止感染病毒, 行, 可以, 我理解, 但是你也总不能一点御寒措施也不做啊, 在公司办公, 做椅子上就能冷的发抖, 止都止不住, 这 TM 怎么干活? ? ? 中午只能吃泡面, 吃火腿肠......我 TM 这是来上班? 我这是来遭罪吧? ? ?让员工冒着感染病毒的危险来上班, 也就是冒着生命危险上班啊, , 但是却一点诚意都没有, 工资一拖再拖, 先拖一周, 然后再拖一周; 吃饭自己解决, 但是就是不能出去买, 不买解决不了? 那我不管, 反正就是不能出去; 冷是吧, 自己多穿点! 我 TM ... 就是说一切不好的事情都是有正当理由的, 那就是 &quot;为了防止感染&quot;, 但是就是必须上班, 话说不上班才是最好的防止感染的措施吧? ? ! !</p>
<p>之前对自己整天抱有负面情绪的失望, 加上公司那冷的我发抖的办公环境, 让我的心情彻底跌落到了谷底, 再加上学校让写论文的开题报告, 于是我做出了请假的决定, 我和经理说, 我感冒了, 在家办公, 他自然也不好说什么, 在这个病毒扩散期间, 万一我的感冒是感染了病毒所致呢? 对吧? 当然我是没有感冒的. 请假第一天, 我是极其无聊的, 真的是感到了前所未有的巨大寂寞感, 看什么都提不起劲头来, 于是第一天就这么过去了, 我在床上躺了一天, 对, 就是躺了一天.... 第二天醒来嘛, 就好多了, 没有那么严重的空虚感了, 不至于干什么都提不起劲头了, 但是我依旧没有开始开题报告的写作. 我看动漫去了, 先看了 No Game No Life, 我去, 主人公牛批, 无敌! 看的我热血沸腾, 不行, 我要学习! ! ! 于是我又打开一部动漫, 叫做 命运石之门, 呜哇 ~ ~ Kurisu! 助手! 克里斯汀娜! 呜啊, 眼泪止不住啊 ... 作者你知道吗, 明天我就让你的怀表停了!! 然后我抑郁了... 于是我就玩游戏去了, 对, 没错, 我玩游戏去了, 玩的是 游戏王 卡片力量 2, 玩得津津有味, 毒蛇神卡组牛批, 无敌, 艾克佐迪亚, 牛批! 无敌! NPC 们你们很不是牛批吗? 你再打我啊? 你再强夺啊! MD... 晚上玩到凌晨 2 点, 贼 TM 嗨, 哈哈哈, 强无敌! ! 直到周六晚上 10 点我还在玩, 但是我的开题报告也就才写了 1/6, 好在我周日早上 3 点左右就醒了, 起来写报告, 大概早上 10 点才写完, 交上后又稍微修改了一点点, 只改了一下措辞啥的, 基本没啥问题, 就过了. 然后继续我开始不想玩游戏了, 加上看了一期关于生命的视频, 还有一些再次对自己的思考, 我打开了尘封已久的博客, 看了一遍之前写的日记, 我知道我该好好反思一下了.</p>
<h1 id="2020-年-02-月-26-号"><a href="#2020-年-02-月-26-号" class="headerlink" title="2020 年 02 月 26 号"></a>2020 年 02 月 26 号</h1><h2 id="对于自身产生大量负面情绪的思考"><a href="#对于自身产生大量负面情绪的思考" class="headerlink" title="对于自身产生大量负面情绪的思考"></a>对于自身产生大量负面情绪的思考</h2><p>经过这一段与自己相处的不算短也不算长的时间, 我意识到了我一直生活在矛盾之中, 我追求完美, 追求自己和弟子规中描述的那样完美, 于是对于自己犯下的错误每次都感到十分的羞耻, 开始慢慢的厌恶自己, 一方面想要完善自己, 而另一方面却在厌恶自己, 于是就不停的恶性循环, 激励自己, 追求完美, 然后偶然间沉迷诱惑, 责备自己, 厌恶自己, 之后再想办法激励自己, 追求完美......但是自己的进步是看不到的, 自己只能看到自己的错误, 于是错误越积越多, 对自己的责备也就越来越深, 不知不觉自己的自信心已经被打击的几乎完全消散了, 于是抵制诱惑的能力就越来越低, 然后就造成了现在的这副惨状. 想要改变这个局面, 就必须能够控制这个循环, 因为这个循环是无法打破的, 只能让自己去控制住这个循环. 首先我想了一下, 从记事时开始到今天 (2020-02-25) 为止, 我自己所坚决不能原谅的我所犯过的错误, 以至于今后必须不能再犯的错误: </p>
<ol>
<li>小学时和王硕的<strong>游戏王-黑魔导的执行官</strong>卡片事件</li>
<li>初中时和张雪的<strong>桑尼</strong>事件</li>
<li><strong>高中班主任</strong>事件</li>
<li>大学时的<strong>李敏</strong>事件</li>
</ol>
<p>想来想去就这四件事了, 这是我一生的污点, 这四件事情我没有和任何人提起过, 就是说在我现在的朋友里面没有任何人知道这四件事, 哪怕是一丁点, 因为在这四件事情上我真的是太不是东西了, 我怕说出去别人直接打我, 唉, 不提了不提了...这样想来, 我朋友少真的是因为我不善于交谈吗? 会不会是我条件反射般的去刻意远离那些可能知道这四件事的人呢? 可能是后者的原因更多一些吧. 由于没有任何人知道这四件事, 而其它我又基本没有犯过什么对不起别人并且之后没有及时道歉解决问题的事, 所以我一直在责备自己什么呢? 我为什么要一直打击自己呢? 就因为自己没有做到完美? 就因为自己在应该学习的时候打游戏了? 因为自己在应该努力的时候看动漫了? 就因为自己又做春梦了? 就因为自己没有克制住自己的性欲? 就因为自己没有遵守时间计划又通宵一晚? 我难道是 M 吗🤣? 想到这里, 我突然就想开了, 我不该过分地纠结于自己犯过的错误, 我该做的是吸取教训, 然后平淡地去看待过去的事情, 而不是一直耿耿于怀, 否则我是无法前进的, 我的时间会停滞, 既然过去的事情都已经过去了, 那么现在往前看就是了. 比如接下来最重要的工作就是毕业设计, 大概六月十号之前就必须弄完, 大概还剩下 100 天的时间, 由于要做一款沙盒游戏, 所以肯定花费的时间很长, 但是我们现在要想的事情不是为什么不早开始干活, 为什么拖到现在, 而是仅仅去思考如何在这 100 天内做出一款自己满意的沙盒求生类游戏就可以了. <font color='red'> 对过去的事耿耿于怀没有任何用处, 只会让自己的时间停滞. </font> 于是我释怀了, 我包容了自己之前所有的负面情绪, 放下过去, 努力面前! </p>
<h2 id="对于出现了-quot-之前的自己总是想要把事情分享给朋友-但是最近独自生活的这段时间里却从来没有想过要联系朋友-quot-这样的情况的思考"><a href="#对于出现了-quot-之前的自己总是想要把事情分享给朋友-但是最近独自生活的这段时间里却从来没有想过要联系朋友-quot-这样的情况的思考" class="headerlink" title="对于出现了 &quot;之前的自己总是想要把事情分享给朋友, 但是最近独自生活的这段时间里却从来没有想过要联系朋友&quot; 这样的情况的思考"></a>对于出现了 &quot;之前的自己总是想要把事情分享给朋友, 但是最近独自生活的这段时间里却从来没有想过要联系朋友&quot; 这样的情况的思考</h2><p>回顾一月份所写下的前言可以知道, 当时的我是想要满足自己的分享欲望而创建了这个系列, 但是最近独自生活的这几天我却一丁点想要联系朋友的想法都没有, 但是这几天我同样是遇到了很多我认为有意思的事情, 无论是之前看的 No Game No Life 以及命运石之门, 还是玩的 游戏王 和 最终幻想 6, 甚至是昨晚刚看的电影 二之国, 都是非常有意思的或者是相当值得吐槽的, 但是我却一丁点想要分享的意思都没有, 那这说明了什么? 我之前想要分享事情真的是因为我的分享欲望吗? 很显然, 不是. 而我也发现了一个共通点, 那就是我之前想要分享的人就是前面所提到的巧巧和黎雅倩, 说白了点就是, 那只是性激素影响下的结果, 就是说我可能在不知不觉地情况下喜欢上她们了, (她? ! 们 ? ! 这个 &quot;们&quot; 是什么情况? ?)所以才想要找话题和她们聊天, 真是万恶的性激素啊! 至此我终于弄明白了自己脑子里的那点小算盘, 你以为我会让你得逞吗? 做梦吧你, 你自己适不适合恋爱, 你自己心里没点 B 数吗?</p>
<p>于是出于前面这两点的思考, 我决定了, 重开这个系列, 并且将主题改为 &quot;记录&quot;, 将读者换成了未来的自己.</p>
<h1 id="2020-年-02-月-27-号"><a href="#2020-年-02-月-27-号" class="headerlink" title="2020 年 02 月 27 号"></a>2020 年 02 月 27 号</h1><h2 id="对理性人的看法-同时也是对-quot-爱-quot-这个词的看法以及对目前的自己适不适合结婚的看法"><a href="#对理性人的看法-同时也是对-quot-爱-quot-这个词的看法以及对目前的自己适不适合结婚的看法" class="headerlink" title="对理性人的看法, 同时也是对 &quot;爱&quot; 这个词的看法以及对目前的自己适不适合结婚的看法"></a>对理性人的看法, 同时也是对 &quot;爱&quot; 这个词的看法以及对目前的自己适不适合结婚的看法</h2><p>&quot;自己适不适合结婚&quot; 这个问题, 我从很早之前就开始思考了, 也一直认为我自己不适合结婚哈, 这个结论到现在都还没有变, 甚至我对此的看法更加坚定了, 这源自最近在家看的哆啦A梦剧场版以及二之国还有命运石之门. 未来的我, 如果你已经忘记了自己关于这件事情的看法, 那么我现在来提醒你一下. 先说一个结论, 如果我是静香, 那么我也会选择大雄作为自己的伴侣, 而不是选择出木衫. 未来的我, 你现在还记得原因吗?</p>
<ul>
<li><p>第一: 在一个以静香为赌注的游戏中, 出木衫为了能够触发所有剧情最后战胜恶龙, 遵守了这个游戏里所有的规则, 达到了所谓的完美, 但是大雄想到的却是用任意门在第一时间赶到忐忑不安的静香身边.</p>
</li>
<li><p>当世界末日真的要来临的时候, 大雄想到的是什么呢? 对, 是静香, 哪怕世界末日没有时间逃跑了, 都不能丢下静香不管, 还有什么好说的? 你是静香, 你不嫁给他吗?</p>
</li>
<li><p>二之国中, 当自己心爱的人面临死亡的时候, 佑是怎么做的, 他是用身体挡住了落下来的尖椎, 即使自己会死, 也要保护了自己心爱的人.</p>
</li>
<li><p>命运石之门中从 α 线过渡到 β 线的时候, 冈部伦太郎是怎么做的, 用自己的鲜血来欺骗整个世界, 救回自己心爱的人. </p>
</li>
</ul>
<p>这么想来, 出木杉就是这里的理性人, 理性人在关键时刻选择的是能保护最大利益的做法, 而真正爱你的人却只会做出能让你幸福的选择, 哪怕会牺牲自己. 试想一下, 未来的我啊, 你试想一下, 即便是未来的你, 如果将来你结婚了, 你的妻子面临生命危险的时候, 哪怕自己的生命也会面临危险, 你也会不顾一切地去救她吗? 如果不会, 那你还是暂时不要结婚了. 如果你已经结婚了. 那就一定要树立这份信念, 树立这份无论如何都要让她幸福的信念. 算是过去的你对你的一份期望吧. 所以我认为现在的我不适合结婚, 我还没有那份即使失去生命也要保护爱人的信念. 这也解释了为什么当我询问巧巧会找什么样的人作为伴侣的时候, 她的回复是 &quot;对我好的人&quot;, 或许这就是 &quot;爱&quot; 吧. 之前总是说两人在一起最需要的是什么门当户对, 什么价值观相同, 什么兴趣爱好一致, 现在想想, 那些都不过是次要因素罢了, 真正需要的还是那个老生常谈的字: &quot;爱&quot;.</p>
<p>借用朋友一句话: <font color='red'><strong>欣赏一个人, 始于颜值, 敬于才华, 合于性格, 久于善良, 终于人品</strong></font>.</p>
<h1 id="2020-年-02-月-28-号"><a href="#2020-年-02-月-28-号" class="headerlink" title="2020 年 02 月 28 号"></a>2020 年 02 月 28 号</h1><h2 id="对于自己-quot-玩游戏时欢-玩过之后又非常懊悔-quot-这种心态的思考"><a href="#对于自己-quot-玩游戏时欢-玩过之后又非常懊悔-quot-这种心态的思考" class="headerlink" title="对于自己 &quot;玩游戏时欢, 玩过之后又非常懊悔&quot; 这种心态的思考."></a>对于自己 &quot;玩游戏时欢, 玩过之后又非常懊悔&quot; 这种心态的思考.</h2><p>当时请假那段时间, 在家迷上了 &quot;游戏王 卡片力量 2&quot;, 玩得不亦乐乎, 好几次玩到晚上24点, 搭建毒蛇神卡组和黑暗大法师卡组, 当时的想法是: 我就不信打不过你! 我就不行我的黑暗大法师出不来! 我就不信我的毒蛇神出不来! 于是便一次又一次地将时间忽略, 其实每次保存的时候, 是有时间提醒的, 当时也注意到挺晚的了, 但还是止不住啊...不过, 玩了一段时间之后呢, 就变得懊悔, 觉得当时咋就傻乎乎地玩游戏不干正事呢? ! 明明有那么多的事情等着做呢! </p>
<p>但是这种事情在我身上已经发生很多很多次了, 我都数不清了, 于是我就趁请假那段时间考虑了一下这个问题. 首先我玩游戏耗费了一段时间, 没有应该做的其他事情, 于是事后感到了懊悔, 但是这时候我想到一个问题, 我问自己: 那是不是我只要玩游戏或者看动漫耗费了时间, 我都会感到懊悔呢? 我仔细思考了一下, 以目前的情况看, 还真是这样! 于是我又联系自己的生活安排发现了大致有两个原因:</p>
<ol>
<li>我现在没有符合自己规定的, 自己许可的看动漫, 看电影或者玩游戏之类的休息时间.</li>
<li>自己的思想意识还没有清晰地认识到现在的局面, 现在这个根本没有时间去娱乐的局面.</li>
</ol>
<p>就导致无论我做什么娱乐, 只要耗费了时间我就会事后感到懊悔.</p>
<p>未来的我, 如果你现在还是处于这种恶性循环中, 建议你赶紧制定带有 &quot;休息时间&quot; 的计划. 空出一段自己允许的时间休息, 只有这样才能既满足自己的休息欲望, 又能够很好的控制情绪以及生活节奏. </p>
<blockquote>
<p><font color='red'><strong>有压迫的地方就会有反抗, 压迫越重, 反抗越重!</strong></font> 切记切记! </p>
</blockquote>
]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 3.9.0 + NexT 7.2.0 =&gt; Hexo 5.1.0 + NexT 8.0.0</title>
    <url>/hexo/hexo_update.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="🏳‍🌈惨案"><a href="#🏳‍🌈惨案" class="headerlink" title="🏳‍🌈惨案"></a>🏳‍🌈惨案</h1><p>一个 <font color='red'>Warning</font> 引发的惨案!</p>
<h1 id="升级方式"><a href="#升级方式" class="headerlink" title="升级方式"></a>升级方式</h1><p>全新安装, 因为我不会升级啊~~😂</p>
<h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><p>进入 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS8=">Git 官方网站<i class="fa fa-external-link-alt"></i></span> 下载安装. </p>
<p>可以使用 <code>git --version</code> 进行验证, 出现版本号就说明成功了. </p>
<h2 id="安装-Nodejs"><a href="#安装-Nodejs" class="headerlink" title="安装 Nodejs"></a>安装 Nodejs</h2><p>进入 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">Nodejs 官方网站<i class="fa fa-external-link-alt"></i></span> 下载安装. </p>
<p>尽量长期支持版本 (LTS), 最新发布版可能会有警报, 甚至会有错误发生!</p>
<p>可以使用 <code>node -v</code> 和 <code>npm -v</code> 进行验证, 出现版本号就说明成功了. </p>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>安装 Hexo 之前, 设置 Hexo 的安装位置. 具体见我的另一篇博客: <a href="https://kuroha.vip/hexo/hexo_blog.html">Hexo + Github Pages 搭建个人博客</a> 这里不再赘述!</p>
<p>安装 Hexo: <strong><code>npm install hexo-cli -g</code></strong></p>
<h2 id="创建本地博客"><a href="#创建本地博客" class="headerlink" title="创建本地博客"></a>创建本地博客</h2><ol>
<li><p>新建文件夹, 放置本地博客, 名称随意. <code>F:\WorkSpace\Hexo</code></p>
</li>
<li><p>初始化本地博客, 在 Git Bash Here 中输入: <code>hexo init</code> </p>
</li>
</ol>
<p>[<strong>注</strong>] <font color='red'><strong>此步骤需要耗费较长一段时间, 我大概用了 25 分钟! 慢慢等吧!</strong></font></p>
<blockquote>
<p><code>hexo init</code> 是这次升级遇到的第一个大坑, 忘记了这个要执行好长一段时间, 好几次自己等不耐烦了, 直接 <code>Ctrl + C</code> 了! 😂</p>
</blockquote>
<ol start="3">
<li>安装默认依赖包, 在 Git Bash Here 中输入: <code>npm install</code></li>
</ol>
<p>[<strong>注</strong>] 在上一步中大部分的依赖其实已经安装了, 这里只是安装一小部分, 所以很快!</p>
<ol start="4">
<li><p>生成静态文件, 在 Git Bash Here 中输入: <code>hexo generate</code></p>
</li>
<li><p>开启服务, 在 Git Bash Here 中输入 <code>hexo server</code></p>
</li>
</ol>
<h2 id="部署-Hexo"><a href="#部署-Hexo" class="headerlink" title="部署 Hexo"></a>部署 Hexo</h2><ol>
<li><p>安装 Hexo deploy 插件, 在 Git Bash Here 中输入: <code>npm install hexo-deployer-git --no-optional</code></p>
</li>
<li><p>在站点配置文件中配置:</p>
</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:KurohaKirito/KurohaKirito.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>[<strong>注</strong>] repo 仓库的地址: 有 SSH 和 HTTPS 两种格式, 推荐选择 SSH 格式, 如果选择 Https 格式, <font color='red'>每次发布时都必须输入账号密码</font>, 不嫌麻烦的可以用!</p>
<h2 id="安装-NexT-主题"><a href="#安装-NexT-主题" class="headerlink" title="安装 NexT 主题"></a>安装 NexT 主题</h2><blockquote>
<p>这里是第二个大坑, 最新版的 NexT 的仓库已经换地址了, 我还傻乎乎地用之前的地址, 唉...😔</p>
</blockquote>
<ul>
<li><p>2014-2017 =&gt; <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0">https://github.com/iissnan/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>2018-2019 =&gt; <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">https://github.com/theme-next/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>2020-2020 =&gt; <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by10aGVtZS1uZXh0">https://github.com/next-theme/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<blockquote>
<p>新版的 NexT 推荐使用 <code>npm install hexo-theme-next --no-optional</code> 进行安装, 作为一个 node_module 存在! 安装之后路径为: node_module/hexo-theme-next.</p>
</blockquote>
<blockquote>
<p>新版的 NexT 推荐用户不要修改主题目录下的配置文件, 而是在站点根目录下新建一个 <font color='red'><strong>_config[.主题名称].yml</strong></font> 文件, 作为新的主题配置文件.</p>
</blockquote>
<p><img data-src="/images/hexo_update/next_theme_config.png" alt="next_theme_config"></p>
<p>可以先从 node_module/hexo-theme-next 文件夹中复制一份配置文件出来, 然后按照规则重命名, 最后修改其中的设置即可!</p>
<h1 id="自定义站点配置文件"><a href="#自定义站点配置文件" class="headerlink" title="自定义站点配置文件"></a>自定义站点配置文件</h1><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>修改 theme 的值为 next, 这里的名字要和之前新建主题配置文件时使用的名称一致! </p>
<h2 id="博客网址样式"><a href="#博客网址样式" class="headerlink" title="博客网址样式"></a>博客网址样式</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:title.html</span> </span><br></pre></td></tr></table></figure>

<h2 id="关闭-quot-半角字符自动转换全角字符-quot"><a href="#关闭-quot-半角字符自动转换全角字符-quot" class="headerlink" title="关闭 &quot;半角字符自动转换全角字符&quot;"></a>关闭 &quot;半角字符自动转换全角字符&quot;</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">smartypants:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="生成站点地图-谷歌版"><a href="#生成站点地图-谷歌版" class="headerlink" title="生成站点地图 (谷歌版)"></a>生成站点地图 (谷歌版)</h2><ol>
<li><p>安装依赖 <code>hexo-generator-sitemap</code>, 命令: <code>npm install hexo-generator-sitemap --no-optional</code>, 之后生成网站时, 便会自动在根目录生成一个 <code>sitemap.xml</code> 文件!</p>
</li>
<li><p>在 source 文件夹下新建文本文件: <code>robots.txt</code>, 并写入以下内容:</p>
</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">User-agent:</span> <span class="string">*</span></span><br><span class="line"><span class="attr">Disallow:</span></span><br><span class="line"><span class="attr">Sitemap:</span> <span class="string">https://kuroha.vip/sitemap.xml</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><code>User-agent</code> : 定义以下配置对哪些搜索引擎生效.</li>
</ul>
</li>
<li><ul>
<li><code>Allow</code> : 允许抓取的内容.</li>
</ul>
</li>
<li><ul>
<li><code>Disallow</code> : 不允许抓取的内容.</li>
</ul>
</li>
<li><ul>
<li><code>Sitemap</code> : 站点地图的存放地址.</li>
</ul>
</li>
</ul>
<p>重新发布之后, 便可以将站点地图提交给 Google Search 了!</p>
<h1 id="自定义主题配置文件"><a href="#自定义主题配置文件" class="headerlink" title="自定义主题配置文件"></a>自定义主题配置文件</h1><p>配置文件中只需要改改设置就可以出现效果的就不提了, 说一下注意事项:</p>
<h2 id="开启自定义配置"><a href="#开启自定义配置" class="headerlink" title="开启自定义配置"></a>开启自定义配置</h2><p>取消自定义配置文件的注释, 并且要在对应的路径下创建对应的文件.</p>
<h2 id="开启标签-分类-关于菜单"><a href="#开启标签-分类-关于菜单" class="headerlink" title="开启标签, 分类, 关于菜单"></a>开启标签, 分类, 关于菜单</h2><p>取消相应的设置选项后, 必须在 <code>source</code> 文件夹下创建相应的路径, 并创建相应的 markdown 文件, 文件中的内容虽然很简单, 但是也必须添加! <code>comments : false</code> 可以使当前页面禁用评论系统.</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h2 id="设置-Favicon-图标"><a href="#设置-Favicon-图标" class="headerlink" title="设置 Favicon 图标"></a>设置 Favicon 图标</h2><p>在 favicon 属性后设置路径之后, 必须在相应的路径下创建图片, 否则找不到文件会报错! 设置侧边栏头像时同理.</p>
<h2 id="添加预计阅读时间功能"><a href="#添加预计阅读时间功能" class="headerlink" title="添加预计阅读时间功能"></a>添加预计阅读时间功能</h2><p>需要安装依赖: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by13b3JkLWNvdW50ZXI=">hexo-word-counter<i class="fa fa-external-link-alt"></i></span></p>
<p><code>npm install hexo-word-counter --no-optional</code></p>
<p>[<strong>注</strong>] <font color='red'>所有需要安装依赖才能出现效果的, 安装完依赖并设置好之后, 必须清理缓存重新生成才会生效!</font></p>
<p>[<strong>注</strong>] <font color='red'>某些特效需要关闭新版 NexT 中的 Pjax</font></p>
<h2 id="关闭最受欢迎文章功能"><a href="#关闭最受欢迎文章功能" class="headerlink" title="关闭最受欢迎文章功能"></a>关闭最受欢迎文章功能</h2><p>NexT 中有这么一个设置: related_posts, 可以当作 &quot;最近受欢迎的文章&quot;, &quot;相关博客&quot; 或者 &quot;推荐阅读&quot; 使用, 但是由于其依赖有点过时, 推荐关闭此功能!</p>
<h2 id="代码高亮风格设置"><a href="#代码高亮风格设置" class="headerlink" title="代码高亮风格设置"></a>代码高亮风格设置</h2><p>如果使用 <code>Prism</code> 进行代码高亮渲染, 并且选择较高级的一些效果, 需要安装依赖.</p>
<p><code>npm install prism-themes --no-optional</code></p>
<p>并且要在 <strong>站点配置文件</strong> 中将 highlight 设为 false, prismjs 设为 true.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">prismjs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">preprocess:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>最后在 <strong>主题配置文件</strong> 的 prism 后设置使用的渲染风格.</p>
<h2 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h2><p>需要安装依赖: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by1nZW5lcmF0b3Itc2VhcmNoZGI=">hexo-generator-searchdb<i class="fa fa-external-link-alt"></i></span></p>
<p><code>npm install hexo-generator-searchdb --no-optional</code></p>
<h2 id="音乐播放器-APlayer"><a href="#音乐播放器-APlayer" class="headerlink" title="音乐播放器 APlayer"></a>音乐播放器 APlayer</h2><blockquote>
<p>APlayer 源码地址: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vZVBsYXllci9BUGxheWVy">APlayer<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>新建目录: <code>source/js/aplayer</code>, 下载并解压源码, 将 <code>dist</code> 文件夹中的四个文件复制到 <code>source/js/aplayer</code> 中. </p>
<p>返回 <code>source/js</code> 文件夹, 新建一个 <code>fixedAplayer.js</code> 文件, 输入以下代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ap = <span class="keyword">new</span> APlayer(&#123;</span><br><span class="line">    container: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;aplayer&#x27;</span>),</span><br><span class="line">    fixed: <span class="literal">true</span>,</span><br><span class="line">    autoplay: <span class="literal">false</span>,</span><br><span class="line">    audio: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">&#x27;歌曲的名字&#x27;</span>,</span><br><span class="line">        artist: <span class="string">&#x27;歌手&#x27;</span>,</span><br><span class="line">        url: <span class="string">&#x27;音乐文件的地址&#x27;</span>,</span><br><span class="line">        cover: <span class="string">&#x27;封面图片的地址&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>之后在 <code>source/_data/body-end.njk</code> 中添加: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--APlayer 吸底式音乐播放功能--&gt;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.aplayer_fixed %&#125;</span><br><span class="line">    &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/js/aplayer/APlayer.min.css&quot;</span>&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;aplayer&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/aplayer/APlayer.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/fixedAplayer.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>最后在 <strong>主题配置文件</strong> 中写入 <code>aplayer_fixed: true</code>.</p>
<h2 id="视频播放器-DPlayer"><a href="#视频播放器-DPlayer" class="headerlink" title="视频播放器 DPlayer"></a>视频播放器 DPlayer</h2><blockquote>
<p>DPlayer 源码地址: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vZVBsYXllci9EUGxheWVy">DPlayer<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>新建目录: <code>source/js/dplayer</code>, 下载并解压源码, 将 <code>dist</code> 文件夹中的四个文件复制到 <code>source/js/dplayer</code> 中.</p>
<p>在待添加视频博客的所需位置中添加以下代码:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dplayer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/dplayer/DPlayer.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> dp_update = <span class="keyword">new</span> DPlayer(&#123;</span></span><br><span class="line"><span class="javascript">    container: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;dplayer&#x27;</span>),</span></span><br><span class="line"><span class="javascript">    screenshot: <span class="literal">true</span>,</span></span><br><span class="line">    video:</span><br><span class="line">    &#123;</span><br><span class="line"><span class="javascript">        url: <span class="string">&#x27;/video/hexo_update/hexo_update.mp4&#x27;</span>, <span class="comment">//视频文件</span></span></span><br><span class="line"><span class="javascript">        pic: <span class="string">&#x27;/video/hexo_update/hexo_update.jpg&#x27;</span>, <span class="comment">//视频封面</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义单行代码段样式"><a href="#自定义单行代码段样式" class="headerlink" title="自定义单行代码段样式"></a>自定义单行代码段样式</h2><p>打开 <code>source/_data/styles.styl</code> 文件, 添加对 <code>Code</code> 标签的自定义配置即可. 下面是我博客使用的配置.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 文章``代码块的自定义样式</span><br><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">    margin: 0px 0px;             // 外边距</span><br><span class="line">    border: 2px solid #00000099; // 边框厚度, 边框样式, 边框颜色</span><br><span class="line">    border-radius: 0px;          // 边框圆润度</span><br><span class="line">    color: #d0104c;              // 代码颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="鼠标单击之心形图案特效"><a href="#鼠标单击之心形图案特效" class="headerlink" title="鼠标单击之心形图案特效"></a>鼠标单击之心形图案特效</h2><p>在 <code>source/js</code> 下创建 <code>love.js</code> 文件, 内容具体见我的另一篇博客: <a href="https://kuroha.vip/hexo/next_theme_beautify.html">Hexo + NexT 主题美化 (NexT v7.2.0)</a> 这里不再赘述!</p>
<p>之后在 <code>source/_data/body-end.njk</code> 中添加: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--心形图案效果--&gt;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.love %&#125;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/love.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>最后在 <strong>主题配置文件</strong> 中写入 <code>love: true</code>.</p>
<h2 id="鼠标单击之烟花爆炸特效"><a href="#鼠标单击之烟花爆炸特效" class="headerlink" title="鼠标单击之烟花爆炸特效"></a>鼠标单击之烟花爆炸特效</h2><ol>
<li><p>下载 <code>fireworks.js</code> 文件到 <code>source/js</code> 文件夹下</p>
</li>
<li><p>在 <code>source/_data/body-end.njk</code> 中添加: </p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--烟花爆炸特效--&gt;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.fireworks %&#125;</span><br><span class="line">    &lt;canvas <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fireworks&quot;</span> style=<span class="string">&quot;position:fixed;left:0;top:0;z-index:99999999;pointer-events:none;&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/fireworks.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <strong>主题配置文件</strong> 中写入 <code>fireworks: true</code>.</li>
</ol>
<p><strong>下载地址:</strong> <span class="exturl" data-url="aHR0cHM6Ly9vZC5say9kL056TmZNalV6TURreE1qZGYvZmlyZXdvcmtzLjd6">fireworks.7z<i class="fa fa-external-link-alt"></i></span>, 解压密码是: <code>https://kuroha.vip/</code>.</p>
<p>[<strong>注</strong>] 都读到这里了, 我想你肯定早就知道了, 想要获取文章中提到的所有资源文件, 只要 F12 就可以了! 😂 当然我还是提供了下载地址的...</p>
<h2 id="页面标题欺诈"><a href="#页面标题欺诈" class="headerlink" title="页面标题欺诈"></a>页面标题欺诈</h2><p>在 <code>source/js</code> 下创建 <code>crash_cheat.js</code> 文件, 内容具体见我的另一篇博客: <a href="https://kuroha.vip/hexo/next_theme_beautify.html">Hexo + NexT 主题美化 (NexT v7.2.0)</a> 这里不再赘述!</p>
<p>之后在 <code>source/_data/body-end.njk</code> 中添加: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--崩溃欺骗--&gt;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.crashcheat %&#125;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/crash_cheat.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>最后在 <strong>主题配置文件</strong> 中写入 <code>crashcheat: true</code>.</p>
<h2 id="球形标签云"><a href="#球形标签云" class="headerlink" title="球形标签云"></a>球形标签云</h2><p>球形标签云其实就是用这个插件 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29hdDEwMDAuY29tL3RhZ2NhbnZhcy5waHA=">TagCanvas<i class="fa fa-external-link-alt"></i></span> 实现的, 点击进入官网. </p>
<p>进入官网后下载 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29hdDEwMDAuY29tL3RhZ2NhbnZhcy5qcw==">tagcanvas.js<i class="fa fa-external-link-alt"></i></span> 文件, 也可以直接在左面我给出的链接那里 &quot;右键 =&gt; 链接另存为&quot;, 保存到: <code>source\js</code> 目录下. 需要的就是这一个 <code>tagcanvas.js</code> 文件!</p>
<p>打开 <code>source/js</code> 文件夹中再新建一个 <code>tagcloud.js</code> 文件, 写入以下内容:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TagCanvas.Start(<span class="string">&#x27;my3DTags&#x27;</span>, <span class="string">&#x27;tags&#x27;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                textFont: <span class="string">&#x27;Georgia,Optima&#x27;</span>,</span><br><span class="line">                textColour: <span class="literal">null</span>,</span><br><span class="line">                outlineColour: <span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">                weight: <span class="literal">true</span>,</span><br><span class="line">                reverse: <span class="literal">true</span>,</span><br><span class="line">                depth: <span class="number">0.8</span>,</span><br><span class="line">                maxSpeed: <span class="number">0.05</span>,</span><br><span class="line">                bgRadius: <span class="number">1</span>,</span><br><span class="line">                freezeDecel: <span class="literal">true</span></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">document</span></span><br><span class="line">            .getElementById(<span class="string">&#x27;myTags&#x27;</span>)</span><br><span class="line">            .style</span><br><span class="line">            .display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[<strong>题外话</strong>] 新版的 NexT 推荐用户不要再修改主题目录中的任何文件, 虽然我是一个前端纯小白, 但是我也在尽力去遵守这条约定, 但是我发现如果我想要实现这个标签云, 就必须修改主题目录中的文件! 如果有人知道可以不修改主题目录中的文件便可以实现相同的效果, 请务必告知, 十分感谢!</p>
<p>打开文件 <code>node_modules\hexo-theme-next\layout\page.njk</code>, 在这个 <code>&lt;div class=&quot;tag-cloud-tags&quot;&gt;</code> 的前面加上如下代码:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# 球形云标签 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tags&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myTags&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">&quot;720&quot;</span> <span class="attr">height</span>=<span class="string">&quot;720&quot;</span> <span class="attr">id</span>=<span class="string">&quot;my3DTags&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tags&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tags&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; tagcloud(&#123;</span><br><span class="line">        min_font   : 16,</span><br><span class="line">        max_font   : 35,</span><br><span class="line">        amount     : 999,</span><br><span class="line">        color      : true,</span><br><span class="line">        start_color: &#x27;black&#x27;,</span><br><span class="line">        end_color  : &#x27;green&#x27;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcanvas.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcloud.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;# 普通云标签 #&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后在 <strong>主题配置文件</strong> 中写入 <code>crashcheat: true</code>.<code>tagcanvas: true</code>.</p>
<blockquote>
<p>[<strong>注</strong>] 球形标签云也可以使用 Hexo 的插件 <code>hexo-tag-cloud</code> 来实现, 其实最终都是依赖于 <code>tagcanvas.js</code> 文件的, 而且我尝试  <code>hexo-tag-cloud</code> 后发现我不会改效果...😂 所以还是用了之前的老方法!</p>
<p>另外, 执行上面的操作后, 球形标签云和普通标签云是同时存在的, 如果只想要显示球形标签云, 把后面那个 <code>普通云标签</code> 的 <code>div</code> 标签注释掉就行了. 就像这样:</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# 普通云标签 #&#125;</span><br><span class="line">&#123;# <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tag-cloud-tags&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; tagcloud(&#123;</span><br><span class="line">      min_font: theme.tagcloud.min,</span><br><span class="line">      max_font: theme.tagcloud.max,</span><br><span class="line">      amount  : theme.tagcloud.amount,</span><br><span class="line">      orderby : theme.tagcloud.orderby,</span><br><span class="line">      order   : theme.tagcloud.order,</span><br><span class="line">      class   : &#x27;tag-cloud&#x27;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> #&#125;</span><br></pre></td></tr></table></figure>

<h2 id="粒子时钟"><a href="#粒子时钟" class="headerlink" title="粒子时钟"></a>粒子时钟</h2><p>下载文件 <a href="https://kuroha.vip/js/clock.js">clock.js</a>, 可以直接在链接上 &quot;右键 =&gt; 链接另存为&quot;, 放到 <code>source/js/</code> 路径下.</p>
<p>之后在 <code>source/_data/sidebar.njk</code> 中添加:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;# 粒子时钟 #&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.clock %&#125;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;canvas id=<span class="string">&quot;canvasDiyBlock&quot;</span> style=<span class="string">&quot;width:60%;&quot;</span>&gt;您的浏览器不支持 Canvas, 请更换浏览器!&lt;/canvas&gt;</span><br><span class="line">        &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/clock.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>最后在 <strong>主题配置文件</strong> 中写入 <code>clock: true</code>.</p>
<h2 id="站点运行时间"><a href="#站点运行时间" class="headerlink" title="站点运行时间"></a>站点运行时间</h2><p>下载文件 <a href="https://kuroha.vip/js/website_runtime.js">website_runtime.js</a>, 可以直接在链接上 &quot;右键 =&gt; 链接另存为&quot;, 放到 <code>source/js/</code> 路径下.</p>
<p>之后在 <code>source/_data/footer.njk</code> 中添加:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;# 站点已运行时间 #&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.websiteruntime %&#125;</span><br><span class="line">    &lt;div id=<span class="string">&quot;days&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/website_runtime.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>最后在 <strong>主题配置文件</strong> 中写入 <code>websiteruntime: true</code>.</p>
<h2 id="萌萌的看板娘"><a href="#萌萌的看板娘" class="headerlink" title="萌萌的看板娘"></a>萌萌的看板娘</h2><ul>
<li>第一种: <code>hexo-helper-live2d</code> 优点: 有声音, 缺点: 无法换装, 无法换模型, 响应事件少.</li>
</ul>
<p>使用方法见官方网址: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VZSE4vaGV4by1oZWxwZXItbGl2ZTJk">hexo-helper-live2d<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>第二种: <code>live2d-widget</code> 优点: 能换装, 能切换模型, 响应事件多, 缺点: 无声音, 配置较复杂. (现在可能已经有声音了)</li>
</ul>
<p>使用方法见官方网址: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0ZXZlbmpvZXpoYW5nL2xpdmUyZC13aWRnZXQ=">live2d-widget<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>第三种: <code>live2d_demo</code> 优点: 能换装, 能切换模型, 响应事件多, 缺点: 无声音, 配置较复杂. (现在可能已经有声音了)</li>
</ul>
<p>使用方法见官方网址: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZnaHJzaC9saXZlMmRfZGVtbw==">live2d_demo<i class="fa fa-external-link-alt"></i></span></p>
<p>我是用的是第 3 种 <strong>live2d_demo</strong></p>
<ol>
<li><p>下载 <code>live2d_demo</code>: <span class="exturl" data-url="aHR0cHM6Ly9vZC5say9kL056TmZNalV5TkRjMU5USmYvbGl2ZTJkX2RlbW8uN3o=">live2d_demo<i class="fa fa-external-link-alt"></i></span>, 解压密码是: <code>https://kuroha.vip/</code></p>
</li>
<li><p>解压之后放到 <code>source/js/</code> 目录下, 完成这一步之后, 在 <code>source/js/live2d_demo/</code> 目录下应该有 9 个文件.</p>
</li>
<li><p>在 <code>source/_data/body-end.njk</code> 文件的最后添加:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--萌萌看板娘--&gt;</span></span><br><span class="line">&#123;% if theme.live2d_demo %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/live2d_demo/jquery-ui.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="comment">&lt;!-- 实现拖动效果，需引入 JQuery UI --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/live2d_demo/autoload.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="comment">&lt;!-- 使用 autoload.js 自动引入看板娘 --&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后在 <strong>主题配置文件</strong> 中写入 <code>live2d_demo: true</code>, 启用看板娘!</p>
</li>
</ol>
<p>[<strong>注</strong>] </p>
<ol>
<li><p>要定制自己的看板娘, 可以修改 <code>autoload.js</code> 中的参数配置, 还可以在 <code>waifu-tips.json</code> 中修改对话, 这两处的配置足够定制自己独特的看板娘了! </p>
</li>
<li><p>经过以上操作如果还是不能达到效果, 请检查 <code>autoload.js</code> 中的路径设置是否正确! (虽然我已经配置好了, 可以直接拿来用, 不过既然出问题了, 就自己检查一下吧!)</p>
</li>
</ol>
<h1 id="aplayer-音乐效果展示"><a href="#aplayer-音乐效果展示" class="headerlink" title="aplayer 音乐效果展示"></a>aplayer 音乐效果展示</h1><link rel="stylesheet" href="/js/aplayer/APlayer.min.css">
<div id="aplayer_update"></div>
<script type="text/javascript" src="/js/aplayer/APlayer.min.js"></script>

<script>
const aplayer_update = new APlayer(
{
  container: document.getElementById('aplayer_update'),
  //fixed: true, // 吸底模式
  //mini: false, // 迷你模式
  autoplay: false, //自动播放
  theme: 'red', //主题色
  loop: 'all', //循环模式: all one none
  order: 'list', //循环顺序: list random
  preload: 'none', //预加载: auto none metadata
  volume: 0.7, //音量设置 会导致用户设置的自定义音量失效
  //customAudioType: mysudio, //自定义音乐类型
  mutex: true, //播放器之间互斥 当一个在播放时 暂停其他所有播放器
  //lrcType: 3, //歌词类型
  listFolded: false, //false: 列表默认展开 true: 列表默认折叠
  listMaxHeight: 90, //列表最大数目
  audio:
  [
    {
      name: '绯色之空', //歌曲名
      artist: '川田真美', //演唱者
      url: 'https://od.lk/s/NzNfMjUyMzcyNzVf/%E7%B7%8B%E8%89%B2%E3%81%AE%E7%A9%BA.mp3', //音乐文件
      cover: 'https://od.lk/s/NzNfMjUyMzcyODFf/%E7%B7%8B%E8%89%B2%E3%81%AE%E7%A9%BA.jpg', //音乐封面
    },
    {
      name: '光るなら', //歌曲名
      artist: 'Goose house', //演唱者
      url: 'https://od.lk/s/NzNfMjUyMzcyNzdf/%E5%85%89%E3%82%8B%E3%81%AA%E3%82%89.mp3', //音乐文件
      cover: 'https://od.lk/s/NzNfMjUyMzcyNzhf/%E5%85%89%E3%82%8B%E3%81%AA%E3%82%89.jpg', //音乐封面
    },
  ]
});
</script>

<h1 id="dplayer-视频效果展示"><a href="#dplayer-视频效果展示" class="headerlink" title="dplayer 视频效果展示"></a>dplayer 视频效果展示</h1><div id="dplayer"></div>
<script src="/js/dplayer/DPlayer.min.js"></script>

<script>
const dp_update = new DPlayer({
    container: document.getElementById('dplayer'),
    screenshot: true,
    video:
    {
        url: '/video/hexo_update/hexo_update.mp4',
        pic: '/video/hexo_update/hexo_update.jpg',
        //thumbnails: 'thumbnails.jpg',
    },
    // 外挂字幕
    // subtitle: {
    //     url: 'webvtt.vtt',
    // },
    // 弹幕
    // danmaku: {
    //     id: 'demo',
    //     api: 'https://api.prprpr.me/dplayer/',
    // },
});
</script>



]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle SQL 基础</title>
    <url>/oracle/oracle_notes.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="Oracle-中常用的功能语句"><a href="#Oracle-中常用的功能语句" class="headerlink" title="Oracle 中常用的功能语句"></a>Oracle 中常用的功能语句</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询特定表中不允许为 null 的列</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> nullable, column_name</span><br><span class="line">  <span class="keyword">from</span> dba_tab_columns</span><br><span class="line"> <span class="keyword">where</span> table_name = <span class="string">&#x27;DDB&#x27;</span></span><br><span class="line">   <span class="keyword">and</span> nullable = <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--获取全部带有 &quot;指定列名&quot; 的表</span></span><br><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> user_tab_cols <span class="keyword">where</span> column_name = <span class="string">&#x27;SAASDM&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--快速备份</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [备份表的名称] <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> [表名];</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person_backup_20201031 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> person;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询数据库中所有用户的信息 (用户名, ID, 创建日期)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> all_users;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询当前登录用户的信息</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_users;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询最近执行过的语句</span></span><br><span class="line"><span class="keyword">select</span> sql_text, sql_fulltext, first_load_time, last_active_time</span><br><span class="line">  <span class="keyword">from</span> v$<span class="keyword">sql</span></span><br><span class="line"> <span class="keyword">where</span> sql_fulltext <span class="keyword">like</span> <span class="string">&#x27;%筛选条件%&#x27;</span></span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> last_active_time <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看数据库的位数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">length</span>(address) <span class="keyword">when</span> <span class="number">8</span> <span class="keyword">then</span> <span class="string">&#x27;32 位数据库&#x27;</span> <span class="keyword">when</span> <span class="number">16</span> <span class="keyword">then</span> <span class="string">&#x27;64 位数据库&#x27;</span> <span class="keyword">end</span> <span class="keyword">as</span> 数据库版本 <span class="keyword">from</span> v$<span class="keyword">sql</span> <span class="keyword">where</span> <span class="keyword">rownum</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Oracle-锁相关"><a href="#Oracle-锁相关" class="headerlink" title="Oracle 锁相关"></a>Oracle 锁相关</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看死锁1</span></span><br><span class="line"><span class="keyword">select</span> sess.sid,</span><br><span class="line">       sess.serial<span class="comment">#,</span></span><br><span class="line">       lo.oracle_username,</span><br><span class="line">       lo.os_user_name,</span><br><span class="line">       ao.object_name,</span><br><span class="line">       lo.locked_mode</span><br><span class="line">  <span class="keyword">from</span> v$locked_object lo, dba_objects ao, v$<span class="keyword">session</span> sess</span><br><span class="line"> <span class="keyword">where</span> ao.object_id = lo.object_id</span><br><span class="line">   <span class="keyword">and</span> lo.session_id = sess.sid;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看死锁2</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;alter system kill session &#x27;&#x27;&#x27;</span> || a.sid || <span class="string">&#x27;,&#x27;</span> || a.serial<span class="comment"># || &#x27;&#x27;&#x27;;&#x27;</span></span><br><span class="line">  <span class="keyword">from</span> v$<span class="keyword">session</span> a</span><br><span class="line"> <span class="keyword">where</span> <span class="keyword">sid</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">sid</span> <span class="keyword">from</span> v$enqueue_lock t <span class="keyword">where</span> t.type =<span class="string">&#x27;TO&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--解除死锁</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">kill</span> <span class="keyword">session</span> <span class="string">&#x27;68,4221&#x27;</span>; <span class="comment">-- &quot;sess.sid,sess.serial#&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--杀死进程</span></span><br><span class="line"><span class="keyword">select</span> spid, osuser, s.program</span><br><span class="line">     <span class="keyword">from</span> v$<span class="keyword">session</span> s,v$process p</span><br><span class="line">     <span class="keyword">where</span> s.paddr=p.addr <span class="keyword">and</span> s.sid=<span class="number">68</span> <span class="comment">--&quot;sess.sid&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--CMD 中执行, spid: 实例名 thread: spid</span></span><br><span class="line">orakill spid <span class="keyword">thread</span></span><br></pre></td></tr></table></figure>

<h1 id="Oracle-时间格式相关语句"><a href="#Oracle-时间格式相关语句" class="headerlink" title="Oracle 时间格式相关语句"></a>Oracle 时间格式相关语句</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看当前的默认时间格式 (必须以管理员登录)</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> props$ <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;NLS_DATE_FORMAT&#x27;</span>;<span class="comment">--DD-MON-RR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--更新当前的默认时间格式 (必须以管理员登录, 重启数据库后生效)</span></span><br><span class="line"><span class="keyword">update</span> props$ <span class="keyword">set</span> <span class="keyword">value</span>$ = <span class="string">&#x27;YYYY-MM-DD HH24:MI:SS&#x27;</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;NLS_DATE_FORMAT&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Oracle-用户相关的操作语句"><a href="#Oracle-用户相关的操作语句" class="headerlink" title="Oracle 用户相关的操作语句"></a>Oracle 用户相关的操作语句</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建新用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> scott <span class="keyword">identified</span> <span class="keyword">by</span> scott123;</span><br><span class="line"></span><br><span class="line"><span class="comment">--修改用户密码</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> scott <span class="keyword">identified</span> <span class="keyword">by</span> scott333;</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除用户 (用户拥有对象时, 无法直接删除用户, 必须先删除对象)</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> scott;</span><br><span class="line"></span><br><span class="line"><span class="comment">--删除用户对象</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> scott <span class="keyword">cascade</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--给用户授权</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span>, <span class="keyword">resource</span>, dba <span class="keyword">to</span> scott;</span><br><span class="line"></span><br><span class="line"><span class="comment">--撤销授权</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">connect</span>, <span class="keyword">resource</span>, dba <span class="keyword">from</span> scott;</span><br></pre></td></tr></table></figure>

<h1 id="Oracle-表空间操作语句"><a href="#Oracle-表空间操作语句" class="headerlink" title="Oracle 表空间操作语句"></a>Oracle 表空间操作语句</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建新的表空间</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> assets <span class="keyword">datafile</span> <span class="string">&#x27;f:\tablespace\tablespacefolder\assets.dbf&#x27;</span> <span class="keyword">size</span> <span class="number">30000</span>m; <span class="comment">-- 30G</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--删除空表空间, 包含物理文件</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">tablespace</span> tablespace_name <span class="keyword">including</span> <span class="keyword">contents</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看所有表空间的总大小</span></span><br><span class="line"><span class="keyword">select</span> tablespace_name, (<span class="keyword">sum</span>(<span class="keyword">bytes</span>) / <span class="number">1024</span> / <span class="number">1024</span>) <span class="keyword">as</span> spacesize <span class="keyword">from</span> dba_data_files <span class="keyword">group</span> <span class="keyword">by</span> tablespace_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看表空间的使用情况</span></span><br><span class="line"><span class="keyword">select</span> tablespace_name <span class="keyword">as</span> <span class="string">&quot;表空间名称&quot;</span>, spacesize <span class="keyword">as</span> <span class="string">&quot;总空间 MB&quot;</span>, usedsize <span class="string">&quot;已使用空间 MB&quot;</span>, trunc(usedsize/spacesize*<span class="number">100</span>, <span class="number">2</span>) <span class="keyword">as</span> <span class="string">&quot;已使用百分比 %&quot;</span> <span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> tablespace_name, (<span class="keyword">sum</span>(<span class="keyword">bytes</span>) / <span class="number">1024</span> / <span class="number">1024</span>) <span class="keyword">as</span> spacesize, </span><br><span class="line">(<span class="keyword">select</span> (<span class="keyword">sum</span>(<span class="keyword">bytes</span>) / <span class="number">1024</span> / <span class="number">1024</span>) <span class="keyword">from</span> dba_segments <span class="keyword">where</span> tablespace_name = A.tablespace_name) <span class="keyword">as</span> usedsize</span><br><span class="line"><span class="keyword">from</span> dba_data_files A <span class="keyword">group</span> <span class="keyword">by</span> tablespace_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">--扩充特定表空间原本的数据文件 (只能扩大, 不能缩小, 如原大小为 2G, 现在需要将其扩大 1G, 则这里需要写 3G)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">datafile</span> <span class="string">&#x27;f:\tablespace\tablespacefolder\assets.dbf&#x27;</span> <span class="keyword">resize</span> <span class="number">300</span>m;</span><br><span class="line"></span><br><span class="line"><span class="comment">--向特定表空间追加新的数据文件</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> assets <span class="keyword">add</span> <span class="keyword">datafile</span> <span class="string">&#x27;f:\tablespace\tablespacefolder\assets1.dbf&#x27;</span> <span class="keyword">size</span> <span class="number">30000</span>m; <span class="comment">-- 30G</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">tablespace</span> assets <span class="keyword">add</span> <span class="keyword">datafile</span> <span class="string">&#x27;f:\tablespace\tablespacefolder\assets2.dbf&#x27;</span> <span class="keyword">size</span> <span class="number">30000</span>m; <span class="comment">-- 30G</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--设置表空间自动扩充</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">datafile</span> <span class="string">&#x27;f:\tablespace\tablespacefolder\assets1.dbf&#x27;</span> <span class="keyword">autoextend</span> <span class="keyword">on</span> <span class="keyword">next</span> <span class="number">200</span>m <span class="keyword">maxsize</span> <span class="keyword">unlimited</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">datafile</span> <span class="string">&#x27;f:\tablespace\tablespacefolder\assets2.dbf&#x27;</span> <span class="keyword">autoextend</span> <span class="keyword">on</span> <span class="keyword">next</span> <span class="number">200</span>m <span class="keyword">maxsize</span> <span class="keyword">unlimited</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看所有表空间文件路径</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dba_data_files;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看特定用户的默认表空间</span></span><br><span class="line"><span class="keyword">select</span> username, default_tablespace <span class="keyword">from</span> dba_users <span class="keyword">where</span> username = <span class="string">&#x27;SCOTT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--设置特定用户的默认表空间</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> scott <span class="keyword">default</span> <span class="keyword">tablespace</span> assets;</span><br></pre></td></tr></table></figure>

<h1 id="Oracle-impdp-和-expdp-的使用"><a href="#Oracle-impdp-和-expdp-的使用" class="headerlink" title="Oracle impdp 和 expdp 的使用"></a>Oracle impdp 和 expdp 的使用</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建自定义路径</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">directory</span> dir_dp <span class="keyword">as</span> <span class="string">&#x27;f:/dmp&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--授权自定义路径</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">read</span>, write <span class="keyword">on</span> <span class="keyword">directory</span> dir_dp <span class="keyword">to</span> scott;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看目录设置及相应权限设置</span></span><br><span class="line"><span class="keyword">select</span> privilege, directory_name, directory_path <span class="keyword">from</span> user_tab_privs t, all_directories d</span><br><span class="line"><span class="keyword">where</span> t.table_name(+) = d.directory_name <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">2</span>, <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用路径参数执行导出与导入</span></span><br><span class="line">expdp scott/scott123@数据库服务名 directory=dir_dp dumpfile=001.dmp logfile=001.log full=y version=10.2.0.1.0;</span><br><span class="line">impdp scott/scott123@数据库服务名 directory=dir_dp dumpfile=001.dmp logfile=001.log full=y table_exists_action=<span class="keyword">replace</span>;</span><br></pre></td></tr></table></figure>

<p>[<strong>注</strong>] </p>
<ol>
<li>有的时候也会使用 imp, exp 进行少量数据的导入导出. </li>
</ol>
<ul>
<li><ul>
<li><code>imp scott/scott123@数据库服务名 file=f:/001.dmp log=f:/001.log full=y ignore=y</code></li>
</ul>
</li>
<li><ul>
<li><code>exp scott/scott123@数据库服务名 file=f:/001.dmp log=f:/001.log full=y</code></li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>exp 不能指定版本号, expdp 可以.</p>
</li>
<li><p>imp 和 exp 可以加路径, impdp 和 expdp 不可以直接加路径, 只能通过自定义路径来更改导入导出的位置.</p>
</li>
<li><p>imp 导入时, 如果出现表已经存在的错误, 可以加入 <code>ignore=y</code> 参数, 加入此参数后, 已存在的表会进行数据追加, 不加此参数, 新导入的数据会被跳过!</p>
</li>
<li><p><code>table_exists_action</code> 参数用于指定导入操作对表的处理行为, 一共有四种:</p>
</li>
</ol>
<ul>
<li><ul>
<li><code>SKIP</code>: 这是默认行为, 如果表已存在则直接跳过, 同时报错!</li>
</ul>
</li>
<li><ul>
<li><code>APPEND</code>: 如果表已存在则向表中追加数据.</li>
</ul>
</li>
<li><ul>
<li><code>REPLACE</code>: 如果表已存在则 DROP 表, 然后创建表, 最后导入数据.</li>
</ul>
</li>
<li><ul>
<li><code>TRUNCATE</code>: 如果表已存在则 TRUNCATE 表, 然后导入数据.</li>
</ul>
</li>
</ul>
<h1 id="SQL-的大小写"><a href="#SQL-的大小写" class="headerlink" title="SQL 的大小写"></a>SQL 的大小写</h1><ol>
<li><p>sql 中的关键字, 字段名, 表名都是大小写不敏感的.</p>
</li>
<li><p>sql 中的字符串是大小写敏感的, <code>like &#39;a%&#39;</code> 和 <code>like &#39;A%&#39;</code> 是完全不一样的.</p>
</li>
</ol>
<h1 id="SQL-中的运算符"><a href="#SQL-中的运算符" class="headerlink" title="SQL 中的运算符"></a>SQL 中的运算符</h1><ol>
<li><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> 这些运算符是进行范围比较的, 因此规定实际使用时, 尽量只用作数值类型的比较. 数值类型比较的时候不能加引号. <code>where a &lt; 3 and a &gt; 1</code> 而不是 <code>where a &lt; &#39;3&#39; and a &gt; &#39;1&#39;</code></li>
<li><code>=</code>, <code>&lt;&gt;</code>, <code>!=</code> 相等和不相等这两种运算符既可以运算字符串, 也可以运算数值. <code>&lt;&gt;</code> 比 <code>!=</code> 用得更多一些. sql 中等于运算符是 <code>=</code> 不是 <code>==</code></li>
<li><code>between and</code> 运算符本质上也是范围比较运算符, 因此规定实际使用时, 也尽量只用作数值类型的比较. 语法格式是: <code>a between 1 and 2</code></li>
<li>比较运算符也适用于其他类型的比较, 比如字母, 日期. 比如: <code>where between &#39;A&#39; and &#39;H&#39;</code> <code>where between &#39;2019-01-01&#39; and &#39;2019-12-31&#39;</code></li>
</ol>
<blockquote>
<p>[<strong>注意</strong>] 在不同的数据库中, <code>between</code> 操作符会产生不同的结果! 在某些数据库中, <code>between</code> 选取介于两个值之间但不包括两个测试值的字段. 在某些数据库中, <code>between</code> 选取介于两个值之间且包括两个测试值的字段. 在某些数据库中, <code>between</code> 选取介于两个值之间且包括第一个测试值但不包括最后一个测试值的字段. 因此, 请检查您的数据库是如何处理 <code>between</code> 操作符!</p>
</blockquote>
<h1 id="SQL-中的-order-by"><a href="#SQL-中的-order-by" class="headerlink" title="SQL 中的 order by"></a>SQL 中的 order by</h1><ol>
<li><code>order by</code> 作用是将结果表中的数据进行排序.</li>
<li><code>order by asc</code> 为升序排序, 即第1条数据最小, 向后数据会越来越大. <code>asc</code> 可以省略.</li>
<li><code>order by desc</code> 为降序排序, 即第1条数据最大, 向后数据越来越小.</li>
<li><code>order by</code> 可以同时对多列进行排序, 但是实际使用时不要超过两列. 如 <code>order by a,b</code>, 数据会先根据 a 进行升序排序, 之后对具有相同 a 值的数据进行按照 b 的升序排序.</li>
</ol>
<h1 id="SQL-中的-insert-into"><a href="#SQL-中的-insert-into" class="headerlink" title="SQL 中的 insert into"></a>SQL 中的 insert into</h1><ol>
<li><p><code>insert into</code> 的作用是向表中插入一行数据, 每执行一次 <code>insert into</code> 只能插入一行数据.</p>
</li>
<li><p><code>insert into</code> 的语法格式是 <code>insert into tablename (columnname1, columnname2, ...) values (value1, value2, ...)</code>, 前面的括号写要赋值的字段名, 后面写对应的值. 要对一行的所有字段赋值的时候, 前面的括号可以省略, 此时后面的括号必须写上全部的数据.</p>
</li>
<li><p><code>insert into tablename</code> 后面也可以直接跟一个 select 语句, 作用是将查询出的数据保存到一个<strong>已存在的表</strong>中, 但是这里的 <code>tablename</code> 必须是已存在的表.</p>
</li>
<li><p>使用 select 的时候语法格式是 <code>insert into tablename (columnname1, columnname2, ...) (select * from table)</code>, 不能加 <code>values</code> 关键字, 否则报错.</p>
</li>
</ol>
<h1 id="SQL-中的-update-set"><a href="#SQL-中的-update-set" class="headerlink" title="SQL 中的 update set"></a>SQL 中的 update set</h1><ol>
<li><p><code>update set</code> 的作用是更新表中已经存在的数据.</p>
</li>
<li><p><code>update set</code> 可以一次更新多行, 这取决于 <code>where</code> 条件.</p>
</li>
<li><p><code>update set</code> 可以一次更新多个字段, 只要使用 <code>,</code> 隔开即可.</p>
</li>
<li><p><code>update set</code> 的语法格式是: <code>update table set a=1, b=2, c=3 where ()</code>, set 后面可以跟多个赋值语句, 中间使用逗号隔开, 更新语句的数量使用 where 来决定, 实际使用时必须加 where 条件.</p>
</li>
</ol>
<h1 id="SQL-中的-delete-from"><a href="#SQL-中的-delete-from" class="headerlink" title="SQL 中的 delete from"></a>SQL 中的 delete from</h1><ol>
<li><code>delete from</code> 的作用是删除表中数据.</li>
<li><code>delete from</code> 可以一次删除多行, 这取决于 <code>where</code> 条件.</li>
<li><code>delete from</code> 的语法格式是: <code>delete from table where ()</code>, delete 的语法格式基本是固定的, 只是后面的 where 条件不同.</li>
</ol>
<h1 id="SQL-中三种删除-drop-delete-truncate-的不同之处"><a href="#SQL-中三种删除-drop-delete-truncate-的不同之处" class="headerlink" title="SQL 中三种删除 (drop, delete, truncate) 的不同之处"></a>SQL 中三种删除 (drop, delete, truncate) 的不同之处</h1><ul>
<li><p>delete: 删除表内容, 不删除表结构, 不释放空间, 可以回滚.</p>
</li>
<li><p>truncate: 删除表内容, 不删除表结构, 释放空间, 默认不能回滚.</p>
</li>
<li><p>drop: 删除表内容, 同时删除表结构, 释放空间, 不能回滚.</p>
</li>
<li><p>执行速度: drop &gt; truncate &gt; delete</p>
</li>
</ul>
<h1 id="SQL-中的各种-join-on"><a href="#SQL-中的各种-join-on" class="headerlink" title="SQL 中的各种 join on"></a>SQL 中的各种 join on</h1><ol>
<li><p><code>join on</code> 不是用来单纯取交集并集的, 它更多的是用来做<strong>数据拼接</strong>的. </p>
</li>
<li><p><code>inner join on</code> 可以省略写作 <code>join on</code></p>
</li>
<li><p><code>inner join on</code> 是在两个表之间取交集. 只有符合 on 条件的数据才会被拼接并返回. <code>from tableA join tableB on tableA.a = tableB.b</code> 只有符合 <code>tableA.a = tableB.b</code> 的数据才会被拼接并返回.</p>
</li>
<li><p><code>left join on</code> 是在两个表之前取左集, 符合<code>on</code> 条件的会被拼接并返回, 不符合 <code>on</code> 条件的左表数据也会返回, 当然这些数据是没有办法作拼接的.</p>
</li>
<li><p><code>right join on</code> 是在两个表之前取右集, 符合<code>on</code>条件的会被拼接并返回, 不符合 <code>on</code> 条件的右表数据也会返回, 当然这些数据是没有办法作拼接的.</p>
</li>
</ol>
<p><img data-src="/images/oracle_notes/sql_join.png" alt="sql-join"></p>
<h1 id="SQL-中的-union-和-union-all"><a href="#SQL-中的-union-和-union-all" class="headerlink" title="SQL 中的 union 和 union all"></a>SQL 中的 union 和 union all</h1><ol>
<li><p><code>join on</code> 可以理解为横向拼接, <code>union all</code> 可以理解为纵向拼接. 2X2 的两个表使用 <code>join on</code> 拼接后是 2X4, <code>union all</code> 拼接后是 4X2. </p>
</li>
<li><p><code>union</code> 拼接自带去重, 如果想要将全部的数据保留下来, 则需要使用 <code>union all</code>.</p>
</li>
<li><p><code>union all</code> 返回表的列名使用的是第一个 select 语句的列名.</p>
</li>
</ol>
<h1 id="SQL-中的-select-into"><a href="#SQL-中的-select-into" class="headerlink" title="SQL 中的 select into"></a>SQL 中的 select into</h1><ol>
<li><p><code>select into</code> 的作用是将查询出来的数据保存到一个<strong>新的临时表</strong>中.</p>
</li>
<li><p><code>select into</code> 必须跟新表, 不允许跟已存在的表.</p>
</li>
<li><p>语法格式是 <code>select () into table_new from table_old where ()</code>.</p>
</li>
<li><p><font color='red'><strong>Oracle 和 PL/SQL 中不支持此语句! 可以使用 create table as select 进行代替.</strong></font></p>
</li>
<li><p><font color='red'><strong>在 Sql Server 中这条语句可以正常使用!</strong></font></p>
</li>
</ol>
<h1 id="SQL-中的-create"><a href="#SQL-中的-create" class="headerlink" title="SQL 中的 create"></a>SQL 中的 create</h1><ol>
<li><p><code>create database</code> 用来创建一个新数据库.</p>
</li>
<li><p><code>create table</code> 用来创建一个新表.</p>
</li>
<li><p><code>create table</code> 的语法格式:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name</span><br><span class="line">(</span><br><span class="line">    column_name_1 data_type(<span class="keyword">size</span>),</span><br><span class="line">    column_name_2 data_type(<span class="keyword">size</span>),</span><br><span class="line">    ......</span><br><span class="line">    column_name_n data_type(<span class="keyword">size</span>)</span><br><span class="line">); <span class="comment">--创建新表, 字段使用 () 括起来, 字段和类型之间使用空格隔开, 最后一个字段后没有 , 号, 语句最后加 ; 号.</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="SQL-中-select-时只返回前-n-条数据"><a href="#SQL-中-select-时只返回前-n-条数据" class="headerlink" title="SQL 中 select 时只返回前 n 条数据"></a>SQL 中 select 时只返回前 n 条数据</h1><ol>
<li><p>为了达到这个效果, Oracle 中可以使用 <code>rownum</code>, SQL Server 中可以使用 <code>select top</code>, My SQL 中可以使用 <code>limit</code>. 在这一方面, Oracle 中有一个很大的缺点, <code>rownum</code> 不能直接直接写 <code>rownum = 2</code>, 返回第二条数据, <code>rownum</code> 必须是从 1 开始的一个序列.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> () <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> () <span class="keyword">and</span> <span class="keyword">rownum</span> &lt;= <span class="number">2</span>; <span class="comment">-- Oracle, 返回前 2 条数据</span></span><br><span class="line"><span class="keyword">select</span> () <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> () <span class="keyword">and</span> <span class="keyword">rownum</span> &lt;= <span class="number">10</span>; <span class="comment">-- Oracle, 只返回前 10 条数据</span></span><br><span class="line"><span class="keyword">select</span> top <span class="number">2</span> () <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> (); <span class="comment">--Sql Server, 返回前 2 条数据</span></span><br><span class="line"><span class="keyword">select</span> top <span class="number">50</span> <span class="keyword">percent</span> () <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> (); <span class="comment">--Sql Server, 返回前 1/2 的数据</span></span><br><span class="line"><span class="keyword">select</span> () <span class="keyword">from</span> <span class="keyword">table</span> () <span class="keyword">limit</span> <span class="number">2</span>; <span class="comment">--My Sql, 返回前 2 条数据</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="SQL-中的约束"><a href="#SQL-中的约束" class="headerlink" title="SQL 中的约束"></a>SQL 中的约束</h1><p>SQL 中的约束用来规范列中的数据, 如果有违反约束的数据行为, 一般为 <code>insert</code> 和 <code>update</code>, 那么这个行为会被禁止.</p>
<p>SQL 中主要的约束有: <code>not null</code>, <code>unique</code>, <code>primary key</code>, <code>foreign key</code>, <code>check</code>, <code>default</code>.</p>
<h2 id="not-null"><a href="#not-null" class="headerlink" title="not null"></a>not null</h2><ol>
<li><p><code>not null</code> 约束是强制某一列不接受空值. </p>
</li>
<li><p>在进行 <code>insert</code> 或者 <code>update</code> 的时候如果没有给这一列赋值, 语句就会执行失败.</p>
</li>
</ol>
<h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><ol>
<li><p><code>unique</code> 约束是将某一列或者某些列作为表中数据的<strong>唯一标识</strong>. </p>
</li>
<li><p><code>unique</code> 约束可以在一张表中设置多个.</p>
</li>
<li><p><code>unique</code> 约束中, <code>null</code> 值是允许存在的.</p>
</li>
</ol>
<h2 id="primary-key"><a href="#primary-key" class="headerlink" title="primary key"></a>primary key</h2><ol>
<li><p><code>primary key</code> 约束被称为<strong>主键</strong>. 唯一标识表中的每一条数据.</p>
</li>
<li><p><code>primary key</code> 约束的列在一张表中只能有一个.</p>
</li>
<li><p><code>primary key</code> 中不允许出现 <code>null</code> 值.</p>
</li>
<li><p>每一张表中都应该有一个主键.</p>
</li>
</ol>
<h2 id="foreign-key"><a href="#foreign-key" class="headerlink" title="foreign key"></a>foreign key</h2><ol>
<li><p><code>foreign key</code> 约束被称为<strong>外键</strong>.</p>
</li>
<li><p>一个表中的 <code>foreign key</code> 指向另一个表中的 <code>primary key</code>.</p>
</li>
<li><p>一个表中的 <code>foreign key</code> 也可以指向另一个表中的 <code>unique</code>, 但是实际使用中不要这样使用. 即<strong>外键</strong>指向<strong>主键</strong>.</p>
</li>
<li><p><code>foreign key</code> 所在的表称为<strong>子表</strong>, 被指向的 <code>primary key</code> 所在的表称为<strong>父表</strong>.</p>
</li>
<li><p><code>foreign key</code> 同样可以约束 <code>insert</code>, <code>update</code> 行为. 当要插入的值或者更新后的值在父表被指向的列中不存在时, 语句执行失败.</p>
</li>
</ol>
<h2 id="check"><a href="#check" class="headerlink" title="check"></a>check</h2><ol>
<li><code>check</code> 约束用来限制列中值的范围.</li>
</ol>
<h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><ol>
<li><code>default</code> 约束用来设置列的默认值.</li>
</ol>
<h1 id="SQL-中的自动增加-auto-increment"><a href="#SQL-中的自动增加-auto-increment" class="headerlink" title="SQL 中的自动增加 (auto_increment)"></a>SQL 中的自动增加 (auto_increment)</h1><ol>
<li><p>Oracle 中并没有直接提供 <code>auto_increment</code>, 而是使用序列 <code>sequence</code> 实现了自动增加.</p>
</li>
<li><p>先创建一个新的序列 <code>sequence</code>. 最后的<strong>循环</strong>一般不要设置, 因为自动增加多用于主键, 而主键是唯一标识的, 不允许重复. <code>maxvalue</code> 一般也不用设置, 创建序列时默认会设置一个非常非常大的数字, 就是这个: <code>9999999999999999999999999999</code>, 够大了吧?</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> sequence_new</span><br><span class="line"><span class="keyword">minvalue</span> <span class="number">1</span>      <span class="comment">--最小值</span></span><br><span class="line"><span class="comment">--maxvalue 5    --最大值</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span>    <span class="comment">--开始值</span></span><br><span class="line"><span class="keyword">increment</span> <span class="keyword">by</span> <span class="number">1</span>  <span class="comment">--增量</span></span><br><span class="line"><span class="keyword">cache</span> <span class="number">2</span>         <span class="comment">--缓存大小</span></span><br><span class="line"><span class="comment">--cycle;        --循环</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用序列中的 <code>nextval</code> 属性实现自动增加. 每次调用 <code>nextval</code> 序列中的值就会自动增加.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sequence_new.nextval <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tableA (<span class="keyword">ID</span>) <span class="keyword">values</span> (sequence_new.nextval);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="SQL-中常用的日期操作"><a href="#SQL-中常用的日期操作" class="headerlink" title="SQL 中常用的日期操作"></a>SQL 中常用的日期操作</h1><ul>
<li><p>获取系统的当前日期: <code>select sysdate from dual;</code></p>
</li>
<li><p>获取月的开始: <code>select trunc(sysdate, &#39;MM&#39;) from dual;</code></p>
</li>
<li><p>获取月的结束: <code>select last_day(sysdate) from dual;</code></p>
</li>
<li><p>获取周日: <code>select trunc(sysdate, &#39;d&#39;) from dual;</code></p>
<p> [<strong>注</strong>] 上面这条语句其实是获取一周的开始, 但是西方国家中 &quot;周日&quot; 是一周的开始😅</p>
</li>
<li><p>获取周一: <code>select trunc(sysdate, &#39;d&#39;) + 1 from dual;</code></p>
<p> [<strong>注</strong>] trunc() 函数返回的是 &quot;date&quot; 类型, 可以直接做加减运算. 加减运算的单位是 &quot;天&quot;.</p>
</li>
<li><p>获取小时的开始: <code>select trunc(sysdate, &#39;hh&#39;) from dual;</code></p>
</li>
<li><p>获取分钟的开始: <code>select trunc(sysdate, &#39;mi&#39;) from dual;</code></p>
</li>
<li><p>增加一个月: <code>select add_months(sysdate, 1) from dual;</code></p>
</li>
<li><p>减少一个月: <code>select add_months(sysdate, -1) from dual;</code></p>
</li>
<li><p>增加一年: <code>select add_months(sysdate, 12) from dual;</code></p>
</li>
<li><p>减少一年: <code>select add_months(sysdate, -12) from dual;</code></p>
</li>
<li><p><code>trunc</code> 方法也可以截取数字:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.458</span>    ) <span class="keyword">from</span> dual; <span class="comment">--123</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.458</span>,  <span class="number">0</span>) <span class="keyword">from</span> dual; <span class="comment">--123</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.458</span>,  <span class="number">1</span>) <span class="keyword">from</span> dual; <span class="comment">--123.4</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.458</span>, <span class="number">-1</span>) <span class="keyword">from</span> dual; <span class="comment">--120</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.458</span>, <span class="number">-4</span>) <span class="keyword">from</span> dual; <span class="comment">--0</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.458</span>,  <span class="number">4</span>) <span class="keyword">from</span> dual; <span class="comment">--123.458</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="SQL-中常用的函数"><a href="#SQL-中常用的函数" class="headerlink" title="SQL 中常用的函数"></a>SQL 中常用的函数</h1><ol>
<li><p><code>avg()</code> 返回数值列的平均值. 括号中的列必须是数值列. 多用于比较条件中的参数. </p>
<p><code>select student_id from table_student group by student_id having avg(student_score) &gt; 80</code> 查出平均分大于 80 分的学生的 id.</p>
</li>
<li><p><code>count()</code> 有多种用法.</p>
<ul>
<li><p><code>count(*)</code> 和 <code>count(1)</code> 等效, 获取查询数据的条数. </p>
</li>
<li><p><code>count(column_name)</code> 获取 column_name 这一列中非空的值. (<strong>null 不计算, 重复值全部计算在内</strong>)</p>
</li>
<li><p><code>count(distinct column_name)</code> 获取 column_name 这一列中非空的且唯一的值的数目. (<strong>null 不计算, 重复值只计算一次</strong>)</p>
</li>
</ul>
</li>
<li><p><code>max()</code> 用于取出列中数据的最大值. <code>min()</code> 用于取出列中数据的最小值. </p>
<ul>
<li><p><code>max()</code> 函数不仅可以取出数值列的最大值, 还可以用于<strong>字符串</strong>, <strong>日期</strong>列.</p>
</li>
<li><p><code>select max(student_age) from table_student;</code> 年龄 (数值列)</p>
</li>
<li><p><code>select max(student_id) from table_student;</code> 学号 (字符串列)</p>
</li>
<li><p><code>select max(student_birth) from table_student;</code> 出生日期 (日期列)</p>
</li>
<li><p><code>min()</code> 函数同样具有以上性质.</p>
</li>
</ul>
</li>
<li><p><code>sum()</code> 返回数值列的和.</p>
<p><code>select sum(score) from table_student group by student_id;</code> 求出每个学生的总分.</p>
</li>
<li><p><code>group by</code> 根据一个或多个列, 对查询出来的结果集进行分组.</p>
<ul>
<li><p><code>where</code> 关键字无法对分组后的结果集进行筛选, 分组之前可以.</p>
</li>
<li><p><code>group by</code> 常常搭配 <code>avg()</code>, <code>count()</code>, <code>max()</code>, <code>min()</code>, <code>sum()</code>, <code>having</code> 一起使用.</p>
</li>
</ul>
</li>
<li><p><code>having</code> 关键字的出现就是为了解决 &quot;<code>where</code> 不能处理分组后的结果集&quot; 这个问题. </p>
<p><code>having</code> 可以对 <code>group by</code> 分组后的数据进行筛选.</p>
</li>
<li><p><code>exists()</code> 对括号中的子句进行判断, 如果子句中有数据, 返回 true, 没有数据返回 false.</p>
</li>
<li><p><code>substr(parame1, parame2, parame3)</code> 截取字符串</p>
<ul>
<li><p>parame1: 待处理字符串</p>
</li>
<li><p>parame2: 起始位置, 0 1 都代表第一个字符</p>
</li>
<li><p>parame3: 截取长度</p>
</li>
<li><p>substr(parame1, parame2) : 取出 parame1 中 parame2 位置之后的整个字符串</p>
</li>
</ul>
</li>
<li><p><code>instr(parame1, parame2)</code> 检索字符串</p>
<ul>
<li><p>parame1: 元字符串</p>
</li>
<li><p>parame2: 待查找字符串</p>
</li>
<li><p>parame3 (可选) : 查找的起始位置, 正数为从左向右检索, 负数为从右向左检索</p>
</li>
<li><p>parame4 (可选) : 返回第几次的检索位置</p>
</li>
</ul>
</li>
<li><p><code>replace(parame1, parame2, parame3)</code> 替换字符串</p>
<ul>
<li><p>replace(parame1, parame2, parame3): 将 parame1 中所有的 parame2 全部替换成 parame3.</p>
</li>
<li><p>replace(parame1, parame2) : 将 parame1 中所有的 parame2 全部删除.</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--举例: 取出 name 字段中 &#x27;/&#x27; 后的字符串</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="keyword">name</span>, <span class="keyword">instr</span>(<span class="keyword">name</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>) <span class="keyword">from</span> dmb <span class="keyword">where</span> saasdm = <span class="string">&#x27;test&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> dmxh;</span><br></pre></td></tr></table></figure>

<h2 id="SQL-中的大小写转换"><a href="#SQL-中的大小写转换" class="headerlink" title="SQL 中的大小写转换"></a>SQL 中的大小写转换</h2><ol>
<li><p><code>upper()</code> 方法可以将查询出来的字符串数据全部转为大写字母. </p>
</li>
<li><p><code>lower()</code> 方法可以将查询出来的字符串数据全部转为小写字母. </p>
</li>
<li><p>上面两个方式是将查询结果集中的数据转换大小写, 并不会修改数据库中真正的数据.</p>
</li>
</ol>
<h2 id="Oracle-中的字符串操作函数"><a href="#Oracle-中的字符串操作函数" class="headerlink" title="Oracle 中的字符串操作函数"></a>Oracle 中的字符串操作函数</h2><ol>
<li><p><code>substr(column_name, startPositon, length)</code> 方法是 Oracle 数据库中的字符串截取函数.</p>
<ul>
<li><p>column_name: 是要操作的列名.</p>
</li>
<li><p>startPosition: 是要截取的开始位置, 其中 0 和 1 都表示从第一个字符开始截取.</p>
</li>
<li><p>length: 是要截取的字符串的长度.</p>
</li>
</ul>
</li>
<li><p><code>length()</code> 函数返回字符串数据的长度.</p>
</li>
</ol>
<h2 id="Oracle-中的保留位数操作函数"><a href="#Oracle-中的保留位数操作函数" class="headerlink" title="Oracle 中的保留位数操作函数"></a>Oracle 中的保留位数操作函数</h2><ol>
<li><p><code>trunc()</code> 函数, 可以截取数字, 达到控制保留位数的效果, 但是不会对数据进行四舍五入.</p>
</li>
<li><p><code>round()</code> 函数, 可以对数字进行四舍五入, 达到控制保留位数的效果.</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">3456.3456</span>, <span class="number">-4</span>) <span class="keyword">from</span> dual; <span class="comment">--0</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">3456.3456</span>, <span class="number">-3</span>) <span class="keyword">from</span> dual; <span class="comment">--3000</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">3456.3456</span>, <span class="number">-2</span>) <span class="keyword">from</span> dual; <span class="comment">--3500</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">3456.3456</span>, <span class="number">-1</span>) <span class="keyword">from</span> dual; <span class="comment">--3460</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">3456.3456</span>,  <span class="number">0</span>) <span class="keyword">from</span> dual; <span class="comment">--3456</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">3456.3456</span>    ) <span class="keyword">from</span> dual; <span class="comment">--3456</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">3456.3456</span>,  <span class="number">1</span>) <span class="keyword">from</span> dual; <span class="comment">--3456.3</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">3456.3456</span>,  <span class="number">2</span>) <span class="keyword">from</span> dual; <span class="comment">--3456.35</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">3456.3456</span>,  <span class="number">3</span>) <span class="keyword">from</span> dual; <span class="comment">--3456.346</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">3456.3456</span>,  <span class="number">4</span>) <span class="keyword">from</span> dual; <span class="comment">--3456.3456</span></span><br></pre></td></tr></table></figure>

<h1 id="Oracle-查看最近执行的语句"><a href="#Oracle-查看最近执行的语句" class="headerlink" title="Oracle 查看最近执行的语句"></a>Oracle 查看最近执行的语句</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> v$<span class="keyword">sql</span> <span class="keyword">where</span> sql_fulltext <span class="keyword">like</span> <span class="string">&#x27;% %&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> last_active_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Oracle-拼接整列数据为一个以逗号分割的字符串"><a href="#Oracle-拼接整列数据为一个以逗号分割的字符串" class="headerlink" title="Oracle 拼接整列数据为一个以逗号分割的字符串"></a>Oracle 拼接整列数据为一个以逗号分割的字符串</h1><ul>
<li><p><code>wm_concat()</code> 方法可以将整列数据为一个以 <code>逗号</code> 分割的字符串.</p>
</li>
<li><p><code>chr(39)</code> 表示单引号, 这样可以将单引号拼接到字符串中.</p>
</li>
<li><p>在外层套用一个 <code>replace()</code> 方法, 可以将 <code>逗号</code> 替换为想要使用的分隔符.</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;(&#x27;</span> || <span class="keyword">chr</span>(<span class="number">39</span>) || <span class="keyword">replace</span>(wm_concat(<span class="keyword">distinct</span> mkbh), <span class="string">&#x27;,&#x27;</span>, <span class="keyword">chr</span>(<span class="number">39</span>)||<span class="string">&#x27;,&#x27;</span>||<span class="keyword">chr</span>(<span class="number">39</span>)) || <span class="keyword">chr</span>(<span class="number">39</span>) || <span class="string">&#x27;)&#x27;</span> <span class="keyword">from</span> mkb <span class="keyword">where</span> systype=<span class="string">&#x27;dwb&#x27;</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Windows-删除无用的-Oracle-服务"><a href="#Windows-删除无用的-Oracle-服务" class="headerlink" title="Windows 删除无用的 Oracle 服务"></a>Windows 删除无用的 Oracle 服务</h1><p>在 Power Shell 中输入 <code>sc delete 服务名</code> 命令可以删除 Windows 服务. 如: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sc delete OracleDBConsolesdzc</span><br></pre></td></tr></table></figure>

<h1 id="Oracle-还原数据库包"><a href="#Oracle-还原数据库包" class="headerlink" title="Oracle 还原数据库包"></a>Oracle 还原数据库包</h1><p>由于经常要还原数据库包, 所以记录一下常用的语句.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建新用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> scott <span class="keyword">identified</span> <span class="keyword">by</span> scott123;</span><br><span class="line"></span><br><span class="line"><span class="comment">--给新用户授权</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span>, <span class="keyword">resource</span>, dba <span class="keyword">to</span> scott;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看表空间文件地址</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dba_data_files;</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建新的表空间</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">tablespace</span> assets <span class="keyword">datafile</span> <span class="string">&#x27;d:\oracle\product\11.2.0\dbhome_1\database\assets.dbf&#x27;</span> <span class="keyword">size</span> <span class="number">2048</span>m;</span><br><span class="line"></span><br><span class="line"><span class="comment">--设置表空间自动扩充</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">datafile</span> <span class="string">&#x27;d:\oracle\product\11.2.0\dbhome_1\database\assets2.dbf&#x27;</span> <span class="keyword">autoextend</span> <span class="keyword">on</span> <span class="keyword">next</span> <span class="number">200</span>m <span class="keyword">maxsize</span> <span class="keyword">unlimited</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--设置默认表空间</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> scott <span class="keyword">default</span> <span class="keyword">tablespace</span> assets;</span><br><span class="line"></span><br><span class="line"><span class="comment">--新建数据泵路径</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">directory</span> dir_dp <span class="keyword">as</span> <span class="string">&#x27;f:/dmp&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用数据库导出导入</span></span><br><span class="line">expdp scott/scott123@数据库实例名 directory=dir_dp dumpfile=001.dmp logfile=001.log full=y version=10.2.0.1.0</span><br><span class="line">impdp scott/scott123@数据库实例名 directory=dir_dp dumpfile=001.dmp logfile=001.log table_exists_action=<span class="keyword">replace</span> <span class="keyword">full</span>=y</span><br></pre></td></tr></table></figure>

<h1 id="Oracle-中循环操作多个表"><a href="#Oracle-中循环操作多个表" class="headerlink" title="Oracle 中循环操作多个表"></a>Oracle 中循环操作多个表</h1><h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> REPLACE_DWDM_CHECK(NEWSAASDM <span class="built_in">VARCHAR2</span>) <span class="keyword">AS</span></span><br><span class="line">  str_sql <span class="built_in">VARCHAR2</span>(<span class="number">200</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">FOR</span> temp <span class="keyword">IN</span> (<span class="keyword">SELECT</span> table_name, <span class="keyword">rownum</span></span><br><span class="line">                 <span class="keyword">FROM</span> User_Tables</span><br><span class="line">                <span class="keyword">WHERE</span> table_name <span class="keyword">IN</span></span><br><span class="line">                      (<span class="keyword">SELECT</span> table_name</span><br><span class="line">                         <span class="keyword">FROM</span> User_Tab_Cols</span><br><span class="line">                        <span class="keyword">WHERE</span> column_name = <span class="string">&#x27;SAASDM&#x27;</span>)</span><br><span class="line">                  <span class="keyword">AND</span> <span class="keyword">temporary</span> = <span class="string">&#x27;N&#x27;</span> <span class="comment">-- 非临时表</span></span><br><span class="line">                  <span class="keyword">AND</span> table_name <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;CQDJ_LCGCB&#x27;</span>)) <span class="keyword">LOOP</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">--保存id, 表名, saasdm</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> REPLACE_DWDM_CHECK_LOG</span><br><span class="line">      (NUMBERID, TABLENAME, NEWSAASDM)</span><br><span class="line">    <span class="keyword">values</span></span><br><span class="line">      (temp.rownum, temp.table_name, NEWSAASDM);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">--构建数量生成语句</span></span><br><span class="line">    str_sql := &#x27;<span class="keyword">update</span> REPLACE_DWDM_CHECK_LOG <span class="keyword">set</span> COUNTNEWSAASDM = (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> <span class="string">&#x27; ||</span></span><br><span class="line"><span class="string">               temp.table_name || &#x27;</span> <span class="keyword">where</span> saasdm = <span class="string">&#x27;&#x27;&#x27; || NEWSAASDM ||</span></span><br><span class="line"><span class="string">               &#x27;&#x27;&#x27;</span> ) <span class="keyword">where</span> NUMBERID = <span class="string">&#x27;&#x27;&#x27; || temp.rownum || &#x27;&#x27;&#x27;&#x27;;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    --执行数量生成语句</span></span><br><span class="line"><span class="string">    EXECUTE IMMEDIATE str_sql;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">    --提交</span></span><br><span class="line"><span class="string">    COMMIT;</span></span><br><span class="line"><span class="string">  END LOOP;</span></span><br><span class="line"><span class="string">END;</span></span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> REPLACE_DWDM_CHECK_DELETE <span class="keyword">AS</span></span><br><span class="line">  str_sql <span class="built_in">VARCHAR2</span>(<span class="number">200</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">FOR</span> temp <span class="keyword">IN</span> (<span class="keyword">select</span> tablename, newsaasdm</span><br><span class="line">                 <span class="keyword">from</span> REPLACE_DWDM_CHECK_LOG</span><br><span class="line">                <span class="keyword">where</span> countnewsaasdm &gt; <span class="number">0</span></span><br><span class="line">                  <span class="keyword">and</span> tablename <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;ZCNB%&#x27;</span></span><br><span class="line">                  <span class="keyword">and</span> tablename <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;GZBB%&#x27;</span></span><br><span class="line">                  <span class="keyword">and</span> tablename <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">&#x27;SWQCBB%&#x27;</span>) <span class="keyword">LOOP</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">--构建删除语句</span></span><br><span class="line">    str_sql := <span class="string">&#x27;delete from &#x27;</span> || temp.tablename || <span class="string">&#x27; where saasdm = &#x27;&#x27;&#x27;</span> ||</span><br><span class="line">               temp.newsaasdm || <span class="string">&#x27;&#x27;&#x27;&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">--执行删除语句</span></span><br><span class="line">    <span class="keyword">EXECUTE</span> <span class="keyword">IMMEDIATE</span> str_sql;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">--提交</span></span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + NexT 主题美化 (NexT v7.2.0)</title>
    <url>/hexo/next_theme_beautify.html</url>
    <content><![CDATA[<blockquote>
<p>**博主的金玉良言: 关于博客的样式, 自己感觉差不多就行了, 这真的是一个无底洞! 尤其是当你像我一样有强迫症的时候, 这也想要, 那也想要, 哇, 那滋味, 别提多酸爽了! **</p>
</blockquote>
<a id="more"></a>

<h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>说实话, 默认的 Hexo 主题我认为不好看, 所以我就上网搜索 Hexo 好看的主题, 最后发现, 最受欢迎的, 也是用的人最多的就是 NexT 主题了. 但是我想了一下, 既然用的人最多, 那么撞车的几率不就很高吗, 那样就没有 <code>独一无二</code> 的感觉了, 所以我坚决不用! <del>真香! ~</del></p>
<p>其实用 NexT 主题是有很大的一个优势的, 因为用户多, 所以教程资料好找啊, 一找一大片, 不像我之前用的 <code>Shana</code> 和 <code>Gal</code> 主题, 教程? 不存在的! </p>
<p>在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQ=">NexT 项目地址 2018<i class="fa fa-external-link-alt"></i></span> 处可以找到 NexT 主题. <code>hexo-theme-next</code> 就是主题项目, 其他的是 NexT 主题的插件项目. 进入 <code>hexo-theme-next</code> 项目, 里面详细说明了如何安装, 启用主题, 这里不再赘述. </p>
<h2 id="NexT-项目地址"><a href="#NexT-项目地址" class="headerlink" title="NexT 项目地址"></a>NexT 项目地址</h2><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0">2014-2017<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0">https://github.com/iissnan/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">2018-2019<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">https://github.com/theme-next/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by10aGVtZS1uZXh0">2020-NOW<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by10aGVtZS1uZXh0">https://github.com/next-theme/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<blockquote>
<p><a href="%E5%88%AB%E5%BF%98%E4%BA%86%E5%9C%A8%E5%AF%B9%E5%BA%94%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E5%A4%B4%E5%83%8F%E6%96%87%E4%BB%B6">注</a> 我在使用 NexT 主题之前, 也使用过几个其他的主题, 在这里也和小伙伴们说一下, 都是比较偏二次元风的, 毕竟我的网站名就是 <strong>&quot;二次元游宅客&quot;</strong> 嘛, 不过最后还是觉得太花里胡哨不好, 眼睛疼! </p>
<ul>
<li><strong>萌娘 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1pFUk9LSVNFS0kvaGV4by10aGVtZS1nYWw=">Gal<i class="fa fa-external-link-alt"></i></span></strong></li>
<li><strong>灼眼的夏娜 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NoYW5hTWFpZC9oZXhvLXRoZW1lLXNoYW5h">Shana<i class="fa fa-external-link-alt"></i></span></strong></li>
<li><strong>埃罗芒阿老师 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RJWWdvZC9oZXhvLXRoZW1lLXNhZ2lyaQ==">Sagiri<i class="fa fa-external-link-alt"></i></span></strong></li>
</ul>
</blockquote>
<h1 id="知识预备"><a href="#知识预备" class="headerlink" title="知识预备"></a>知识预备</h1><p>Hexo 博客的配置文件有两个, <code>站点配置文件</code> 和 <code>主题配置文件</code>, 站点配置文件在博客根目录中, 我的是: <code>F:\WorkSpace\HexoBlog\_config.yml</code>, 主题配置文件在相应的主题文件夹中, 比如我的 NexT 主题配置文件: <code>F:\WorkSpace\HexoBlog\themes\next\_config.yml</code>. </p>
<h1 id="自定义站点配置文件"><a href="#自定义站点配置文件" class="headerlink" title="自定义站点配置文件"></a>自定义站点配置文件</h1><p>我们之前创建的本地博客只有一个空的模板, 还没有进行自定义, 下面我们来设置一下我们博客的标题, 副标题, 描述等等. </p>
<p>打开本地博客根目录下的 _config.yml 文件, 这个文件就是网站的配置文件. </p>
<p>下面是基础设置的介绍: </p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">含义</th>
<th align="left">本人设置</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Title</td>
<td align="left">网站标题</td>
<td align="left">二次元游宅客</td>
</tr>
<tr>
<td align="left">Subtitle</td>
<td align="left">网站副标题</td>
<td align="left">Sword Art Online</td>
</tr>
<tr>
<td align="left">Description</td>
<td align="left">网站描述</td>
<td align="left">一个热爱二次元和游戏开发的宅极客!</td>
</tr>
<tr>
<td align="left">Author</td>
<td align="left">您的昵称</td>
<td align="left">Kuroha</td>
</tr>
<tr>
<td align="left">Language</td>
<td align="left">网站语言</td>
<td align="left">zh-CN</td>
</tr>
<tr>
<td align="left">Timezone</td>
<td align="left">网站时区</td>
<td align="left"></td>
</tr>
</tbody></table>
<ul>
<li>Timezone: 留空的话, Hexo 会使用本地电脑的时区和时区列表. </li>
<li>Description: 用于 SEO（搜索引擎优化）, 告诉搜索引擎一个关于你博客的简单描述, 通常建议在其中包含网站的关键词. </li>
<li>Author: 显示博客中文章的作者. </li>
<li><strong>含义</strong>部分是<strong>常见的</strong>解释, 不同的博客主题或许会有不同的用法, 具体见你使用的网页主题的简介. </li>
</ul>
<p>根据自己的情况修改上面的设置即可. </p>
<p>修改 theme的值为: next, 即可启用 NexT 主题. 前提是你已经安装了. <del>这不废话吗! ~</del></p>
<h1 id="自定义主题配置文件"><a href="#自定义主题配置文件" class="headerlink" title="自定义主题配置文件"></a>自定义主题配置文件</h1><p>其实默认的 NexT 主题就已经很漂亮了, 不过呢, 为了实现更好的效果, 下面我们就开始 NexT 主题的美化. </p>
<h2 id="开启自定义-swig-文件功能"><a href="#开启自定义-swig-文件功能" class="headerlink" title="开启自定义 swig 文件功能"></a>开启自定义 swig 文件功能</h2><p>将 <code>custom_file_path:</code> 属性下面的值全部取消注释, 并且在<strong>网站根目录</strong>下的 source 文件夹中新建 <code>_data</code> 文件夹, 注意不是在主题根目录下的 source 文件夹中新建. 之后在 <code>_data</code> 文件夹中将对应的所有文件全部手动创建好(因为不会自动创建). 之后如果要自定义样式, 直接修改这些文件就行了. </p>
<h2 id="开启-RSS-订阅"><a href="#开启-RSS-订阅" class="headerlink" title="开启 RSS 订阅"></a>开启 RSS 订阅</h2><p>首先安装依赖: <code>npm install --save hexo-generator-feed</code></p>
<p>在主题配置文件中搜索 rss 设置为: <code>rss: /atom.xml</code></p>
<h2 id="设置地址栏的-Favicon-图标"><a href="#设置地址栏的-Favicon-图标" class="headerlink" title="设置地址栏的 Favicon 图标"></a>设置地址栏的 Favicon 图标</h2><p>在主题配置文件中, 搜索: favicon 属性, 修改为自定义值, 下面是我的设置: </p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/sao-16x16.png</span><br><span class="line">  medium: /images/sao-32x32.png</span><br></pre></td></tr></table></figure>

<p>之后根据你的设置, 在主题的 Source/images 文件夹中添加相应的文件即可. <code>[注] 文件名和后缀要和配置文件中的保持一致</code></p>
<h2 id="博客网站页脚设置"><a href="#博客网站页脚设置" class="headerlink" title="博客网站页脚设置"></a>博客网站页脚设置</h2><p>找到 footer 属性, 修改为自定义值, 下面是我的设置: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  since: 2019</span><br><span class="line">  icon:</span><br><span class="line">    # 效果: 一颗跳动的小红心</span><br><span class="line">    name: heart</span><br><span class="line">    animated: true</span><br><span class="line">    color: &quot;#ff0000&quot;</span><br><span class="line">  copyright:</span><br><span class="line">    # 效果: 由 Hexo 强力驱动</span><br><span class="line">  powered:</span><br><span class="line">    enable: true</span><br><span class="line">    version: true</span><br><span class="line">  theme:</span><br><span class="line">    # 效果: 主题-NexT</span><br><span class="line">    enable: true</span><br><span class="line">    version: true</span><br><span class="line">  beian:</span><br><span class="line">    # 效果: 显示备案</span><br><span class="line">    enable: false</span><br><span class="line">    icp:</span><br></pre></td></tr></table></figure>

<h2 id="在文章末尾添加创作协议"><a href="#在文章末尾添加创作协议" class="headerlink" title="在文章末尾添加创作协议"></a>在文章末尾添加创作协议</h2><p>在主题的配置文件中, 搜索: creative_commons, 修改为自定义值, 强烈建议修改前阅读: <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL3NoYXJlLXlvdXItd29yay9saWNlbnNpbmctdHlwZXMtZXhhbXBsZXM=">知识共享许可<i class="fa fa-external-link-alt"></i></span> , 下面是我的配置, 建议使用 <code>by-nc-sa</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: false</span><br><span class="line">  post: true</span><br><span class="line">  language: </span><br></pre></td></tr></table></figure>

<h2 id="添加-Github-快捷关注"><a href="#添加-Github-快捷关注" class="headerlink" title="添加 Github 快捷关注"></a>添加 Github 快捷关注</h2><p>在主题的配置文件中, 搜索: github_banner, 修改为自定义值, 如下: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">github_banner:</span><br><span class="line">  enable: true</span><br><span class="line">  permalink: https://github.com/KurohaKirito</span><br><span class="line">  title: Follow me on GitHub</span><br></pre></td></tr></table></figure>

<h2 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h2><p>在主题的配置文件中, 搜索: social, 修改为自定义值, 如下: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  Telegram: https://t.me/****** || telegram</span><br><span class="line">  QQ: tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=****** || qq</span><br><span class="line">  Steam: https://steamcommunity.com/profiles/******/ || steam</span><br><span class="line">  WeChat: https://kuroha.vip/images/weixin.png || weixin</span><br><span class="line">  E-Mail: mailto:******@***.com || envelope</span><br><span class="line">  GitHub: https://github.com/****** || github</span><br><span class="line"></span><br><span class="line">social_icons:</span><br><span class="line">  enable: true # 是否显示社交链接的图标</span><br><span class="line">  icons_only: false # 是否仅显示图标</span><br><span class="line">  transition: false</span><br></pre></td></tr></table></figure>

<p>**transition: false 说实话, 这个设置我也不知道有什么用! 有知道的请务必告知, 感谢! **</p>
<h2 id="添加友情链接"><a href="#添加友情链接" class="headerlink" title="添加友情链接"></a>添加友情链接</h2><p>在主题配置文件中搜索: links_icon, 修改为自定义值, 如下: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">links_icon: link</span><br><span class="line">links_title: 友情链接</span><br><span class="line">links_layout: inline</span><br><span class="line">links:</span><br><span class="line">  ShyArcher: https://shyarcher.github.io/</span><br><span class="line">  Noah: https://noahapps.github.io/</span><br></pre></td></tr></table></figure>

<p><a href="%E5%88%AB%E5%BF%98%E4%BA%86%E5%9C%A8%E5%AF%B9%E5%BA%94%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E5%A4%B4%E5%83%8F%E6%96%87%E4%BB%B6">注</a>: 这个地方也可以作为 &quot;<strong>推荐阅读</strong>&quot; 功能使用. </p>
<h2 id="网站头像设置"><a href="#网站头像设置" class="headerlink" title="网站头像设置"></a>网站头像设置</h2><p>在主题配置文件中, 搜索: avatar, 修改为自定义值, 如下: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  url: /images/sao-avatar.png # 头像路径</span><br><span class="line">  rounded: false # 头像是否显示为圆形</span><br><span class="line">  rotated: true # 鼠标经过头像时, 头像是否旋转</span><br></pre></td></tr></table></figure>

<h2 id="给文章添加目录"><a href="#给文章添加目录" class="headerlink" title="给文章添加目录"></a>给文章添加目录</h2><p>在主题配置文件中搜索: toc, 修改为自定义值, 如下: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true </span><br><span class="line">  number: true # 是否自动编号</span><br><span class="line">  wrap: true # 标题过长时, 是否换行, 建议开启, 不换行的话有些字就看不见了</span><br><span class="line">  expand_all: true # 标题是否完全展开</span><br><span class="line">  max_depth: 10 # 标题最大级数</span><br></pre></td></tr></table></figure>

<p><a href="%E5%88%AB%E5%BF%98%E4%BA%86%E5%9C%A8%E5%AF%B9%E5%BA%94%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E5%A4%B4%E5%83%8F%E6%96%87%E4%BB%B6">注</a>: wrap 属性还是要解释一下, wrap 设置为 true, 那么当标题过长时, 在目录那里会进行自动换行, 但是如果设置为 false, 那么过长的部分就会用 ... 省略掉! 所以还是设置为 true 吧. </p>
<h2 id="侧边栏属性设置"><a href="#侧边栏属性设置" class="headerlink" title="侧边栏属性设置"></a>侧边栏属性设置</h2><p>在主题配置文件中搜索: sidebar, 修改为自定义值, 如下: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  position: left # 侧边栏显示在左边还是右边</span><br><span class="line">  width: 280 # 侧边栏宽度</span><br><span class="line">  display: post # 侧边栏显示模式, 只有在&quot;Muse&quot;和&quot;Mist&quot;风格下有效</span><br><span class="line">  offset: 10 # 侧边栏和文章页面之间的间隙, 只有在&quot;Pisces&quot;和&quot;Gemini&quot;风格下有效</span><br><span class="line">  onmobile: true # 是否在手机页面上显示, 只有在&quot;Muse&quot;和&quot;Mist&quot;风格下有效</span><br></pre></td></tr></table></figure>

<h2 id="阅读进度百分比显示"><a href="#阅读进度百分比显示" class="headerlink" title="阅读进度百分比显示"></a>阅读进度百分比显示</h2><p>在主题配置文件中搜索: back2top, 修改为自定义值, 如下: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  sidebar: true # true: 将按钮显示在侧边栏, false: 将按钮显示在左下角或者右下角, 取决于侧边栏的位置</span><br><span class="line">  scrollpercent: true # 是否显示百分比</span><br></pre></td></tr></table></figure>

<h2 id="添加预计阅读时间功能"><a href="#添加预计阅读时间功能" class="headerlink" title="添加预计阅读时间功能"></a>添加预计阅读时间功能</h2><p>NexT 主题默认没有安装这个功能所需的依赖, 所以我们要先安装依赖: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by1zeW1ib2xzLWNvdW50LXRpbWU=">hexo-symbols-count-time<i class="fa fa-external-link-alt"></i></span></p>
<p>安装方法 Github 上已经说得很明白了, 这里不再赘述. </p>
<p>在主题配置文件中搜索: symbols_count_time 修改为自定义值, 如下: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br><span class="line">  suffix: mins.</span><br></pre></td></tr></table></figure>

<h2 id="文章底部标签前添加图标"><a href="#文章底部标签前添加图标" class="headerlink" title="文章底部标签前添加图标"></a>文章底部标签前添加图标</h2><p>在主题的配置文件中搜索: tag_icon 设置为 true</p>
<p><code>tag_icon: true</code></p>
<p><del>话说, 之前版本总是没有这个设置好吧, 每次都要自己添加, 哼! ~</del> 这个版本终于有了! </p>
<h2 id="在文章底部添加打赏"><a href="#在文章底部添加打赏" class="headerlink" title="在文章底部添加打赏"></a>在文章底部添加打赏</h2><p>在主题的配置文件中搜索: reward_settings 修改为自定义值, 如下: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false # 关闭抖动动画</span><br><span class="line">  comment: 您的支持将鼓励我继续创作! </span><br><span class="line">reward:</span><br><span class="line">  #wechatpay: /images/wechatpay.png # 微信</span><br><span class="line">  alipay: /images/alipay.png # 支付宝</span><br><span class="line">  #bitcoin: /images/bitcoin.png # 比特币</span><br></pre></td></tr></table></figure>

<h2 id="添加最受欢迎文章功能"><a href="#添加最受欢迎文章功能" class="headerlink" title="添加最受欢迎文章功能"></a>添加最受欢迎文章功能</h2><p>也可以作为 <strong>推荐阅读</strong> 功能使用. </p>
<p>NexT 主题默认没有安装这个功能所需的依赖, 所以我们要先安装依赖: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RlYTMvaGV4by1yZWxhdGVkLXBvcHVsYXItcG9zdHM=">hexo-related-popular-posts<i class="fa fa-external-link-alt"></i></span></p>
<p>安装方法 Github 上已经说得很明白了, 这里不再赘述. </p>
<p>在主题的配置文件中搜索: related_posts 修改为自定义值, 如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">related_posts:</span><br><span class="line">  enable: true</span><br><span class="line">  title: 推荐阅读</span><br><span class="line">  display_in_home: false # 是否在首页摘要处显示</span><br><span class="line">  params:</span><br><span class="line">    maxCount: 5</span><br><span class="line">    PPMixingRate: 0.0</span><br><span class="line">    isDate: false # 是否显示日期</span><br><span class="line">    isImage: false # 是否显示图片</span><br><span class="line">    isExcerpt: false # 是否显示摘要</span><br></pre></td></tr></table></figure>

<h2 id="代码高亮风格设置"><a href="#代码高亮风格设置" class="headerlink" title="代码高亮风格设置"></a>代码高亮风格设置</h2><p>第一步: 在<strong>站点配置文件</strong>中搜索: <code>highlight</code>, 将 <code>auto_detect</code> 设置为 <code>true</code>, 如下:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true # 开启高亮</span><br><span class="line">  line_number: true # 开启标注行号</span><br><span class="line">  auto_detect: true # 开启自动检测</span><br><span class="line">  tab_replace:</span><br></pre></td></tr></table></figure>

<p>第二步: 在<strong>主题配置文件</strong>中搜索: <code>codeblock</code> 修改为自定义值, 如下: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  highlight_theme: night eighties # 代码高亮风格</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true # 是否显示 &quot;复制&quot; 按钮</span><br><span class="line">    show_result: true # 是否显示 &quot;复制成功&quot;</span><br><span class="line">    style: mac # 代码框风格</span><br></pre></td></tr></table></figure>

<h1 id="第三方服务设置"><a href="#第三方服务设置" class="headerlink" title="第三方服务设置"></a>第三方服务设置</h1><p>NexT 主题支持很多第三方服务, 但是默认都没有安装相应的依赖, 所以大部分设置都要先安装相应的依赖才行. </p>
<h2 id="添加图片浏览功能"><a href="#添加图片浏览功能" class="headerlink" title="添加图片浏览功能"></a>添加图片浏览功能</h2><p>NexT 主题默认没有安装这个功能所需的依赖, 所以我们要先安装依赖: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvdGhlbWUtbmV4dC1mYW5jeWJveDM=">theme-next-fancybox3<i class="fa fa-external-link-alt"></i></span></p>
<p>在主题的配置文件中搜索: fancybox 修改为 true, 如下: </p>
<p><code>fancybox: true</code></p>
<p>下面是测试图片, 鼠标点击图片就会进入图片浏览模式. </p>
<p><img data-src="/images/next_theme_beautify/Sword_Art_Online.png" alt="Sword_Art_Online"></p>
<p><img data-src="/images/next_theme_beautify/Sinon.png" alt="Sinon"></p>
<h2 id="添加-lazyload-懒加载"><a href="#添加-lazyload-懒加载" class="headerlink" title="添加 lazyload (懒加载)"></a>添加 lazyload (懒加载)</h2><p>Lazyload 能够让网页只加载在电脑屏幕显示范围内的图片, 让范围外的图片暂时不加载, 来加快网页加载速度. </p>
<p>NexT 主题默认没有安装这个功能所需的依赖, 所以我们要先安装依赖: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvdGhlbWUtbmV4dC1sYXp5bG9hZA==">theme-next-lazyload<i class="fa fa-external-link-alt"></i></span></p>
<p>在主题的配置文件中搜索: lazyload 修改为 true, 如下: </p>
<p><code>lazyload: true</code></p>
<h2 id="添加阅读进度条"><a href="#添加阅读进度条" class="headerlink" title="添加阅读进度条"></a>添加阅读进度条</h2><p>还是老步骤, 安装依赖: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvdGhlbWUtbmV4dC1yZWFkaW5nLXByb2dyZXNz">theme-next-reading-progress<i class="fa fa-external-link-alt"></i></span></p>
<p>在主题配置文件中搜索: reading_progress, 修改为自定义值, 如下: </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  color: &quot;#37c6c0&quot; # 进度条颜色</span><br><span class="line">  height: 5px # 进度条宽度</span><br></pre></td></tr></table></figure>

<p><a href="%E5%88%AB%E5%BF%98%E4%BA%86%E5%9C%A8%E5%AF%B9%E5%BA%94%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E5%A4%B4%E5%83%8F%E6%96%87%E4%BB%B6">注</a> 如果你部署后发现没有效果, 可以试试将宽度调整为 50px, 你就能看到效果了, 之后记得再将宽度改回去. </p>
<h2 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h2><p>NexT 支持很多第三方评论系统: Disqus, 畅言, Valine, LiveRe (来必力), Gitalk. </p>
<blockquote>
<p>Disqus: 不采用, 因为不支持 Markdown 啊喂! 这让人怎么优雅地发评论啊! </p>
</blockquote>
<blockquote>
<p>畅言: 不采用, 因为需要 备案 啊喂! 我一个 &quot;个人博客网站&quot; 备啥案啊! 而且还要手机号验证! 喂! 我就不能匿名评论吗? 话说, 你怎么也不支持 Markdown 啊喂! </p>
</blockquote>
<blockquote>
<p>LiveRe: 同样需要登陆啊喂! 我就不能匿名评论吗? 话说, 你好像也不支持 Markdown 啊喂! </p>
</blockquote>
<blockquote>
<p>Gitalk: 使用 issue 来实现评论功能, 话说我不推荐这种方式! 虽然它支持 Markdown. </p>
</blockquote>
<blockquote>
<p>Valine: **支持 Markdown ! ** **支持 Markdown ! ** **支持 Markdown ! ** **支持匿名! ** **支持匿名! ** **支持匿名! ** 也支持图片评论. </p>
</blockquote>
<p>所以我采用 Valine 作为我的评论系统. </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Q: Valine 支持图片? 我怎么没找到发图片的按钮? 博客主, 你这不骗人嘛! </span><br><span class="line">A: 大哥! Valine 不是支持 Markdown 嘛, 那你告诉我它不支持图片? 你就不能使用 Markdown 语法来显示图片吗? ! </span><br></pre></td></tr></table></figure>

<p>想详细了解 Valine 的朋友们可以点击这里: <span class="exturl" data-url="aHR0cHM6Ly92YWxpbmUuanMub3JnLw==">Valine 中文官方文档<i class="fa fa-external-link-alt"></i></span> ! </p>
<p>在主题配置文件中搜索: valine 修改为自定义值, 如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: ******</span><br><span class="line">  appkey: ******</span><br><span class="line">  notify: true # 谁得到新回复时, 谁就会有邮件提醒, 建议开启, 对博客主和来访者都有好处. </span><br><span class="line">  verify: true # 评论前是否有验证码验证. </span><br><span class="line">  placeholder: ヾﾉ≧∀≦)o来啊, 快活啊! # 评论框提示语句. </span><br><span class="line">  avatar: retro # 匿名评论者的用户头像. </span><br><span class="line">  guest_info: nick,mail,link # 用户选填信息: 昵称, 邮箱(要填写 Gravater 的账号邮箱地址), 个人网站地址. </span><br><span class="line">  pageSize: 10</span><br><span class="line">  language: zh-cn</span><br><span class="line">  visitor: false # 文章阅读数统计, 建议不要使用, 后面会使用不蒜子统计来实现文章阅读数统计功能. </span><br><span class="line">  comment_count: true # 评论数统计. </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>获取上面代码所需的 appid 和 appkey</strong></p>
</blockquote>
<p>Valine 的评论数据其实是保存在 LeanCloud 上面的, 这里所需要的 appid 和 appkey 其实都是 LeanCloud 网站上的, 所以我们要先注册一个 LeanCloud 账号, 点击这里: <span class="exturl" data-url="aHR0cHM6Ly9sZWFuY2xvdWQuY24v">LeanCloud 官网<i class="fa fa-external-link-alt"></i></span>, 不过呢, 从 2019-07-15 开始就需要实名认证了, 这个比较烦, 不过没办法, 忍忍吧, 10 分钟左右就认证好了, 当然如果你脸黑 · · · 呃 · · · 就当我什么也没说! </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Q: 话说回来, 你怎么不早说需要实名认证啊! </span><br><span class="line">A: 如果我提前说了, 那你还会用 Valine 吗? </span><br></pre></td></tr></table></figure>

<p>完成实名认证之后, 就可以新建应用了, 名字呢无所谓, 也支持中文, 起一个你喜欢的名字吧! </p>
<p>创建完应用之后, 点击应用右上角的 齿轮 标记, 进入设置页面, 再次点击左下角的 &quot;设置&quot;, 之后点击 &quot;应用 Key&quot;, 就会出现 App ID 和 App Key 了. </p>
<p>然后填写到主题配置文件的相应位置就可以了, 是不是很简单? ! </p>
<blockquote>
<p>2019-12-20 更新:</p>
</blockquote>
<p><del>所以我采用 Valine 作为我的评论系统</del>. </p>
<blockquote>
<p>すみません, ほんどにすみません! </p>
<p>今天我发现 Leancloud 的使用现在要绑定域名, 而绑定域名需要<font color='red'><strong>备案</strong></font>......(可是我真的不想备案啊~ 因为在我的心中网络世界是不同于现实世界的另一个新世界, 那里充满幻想, 充满热爱, 可以以自己最喜欢的样子去生活, 所以为什么我还要继续使用现实世界的身份啊? ) 所以经过综合考虑, 我换用了 Gitalk !</p>
</blockquote>
<h3 id="使用-Gitalk-评论系统"><a href="#使用-Gitalk-评论系统" class="headerlink" title="使用 Gitalk 评论系统"></a>使用 Gitalk 评论系统</h3><p>简介: Gitalk 是使用 Github 中的 Issues 功能实现的评论系统, 我之前之所以说不推荐使用这种方式, 是因为这种方式有滥用 Github 的嫌疑, 不过有人问过 Github 官方, 官方也回应了说这样不算违反用户协议, 就是说这样用官方也是默许的. </p>
<ol>
<li><p>首先去自己的 Github 上新建一个 Repository, 并开放 Issues 功能. (其实这个是默认开放的) 名字写一个自己比较容易记住的名字即可. 我起的名字是: MyBlogCommentSystem (感觉好中二)</p>
</li>
<li><p>之后新建一个 Application, URL 就填写你的域名即可, 应用名称, 描述什么的按喜好填写. </p>
</li>
<li><p>填写 Next 的主题配置文件, 下面是我的配置:</p>
</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  github_id: Github 用户 ID (注意大小写)</span><br><span class="line">  repo: 仓库名称 (注意大小写)</span><br><span class="line">  client_id: 之前创建的 Application Client ID</span><br><span class="line">  client_secret: 之前创建的 Application Client Secret</span><br><span class="line">  admin_user: Github 用户 ID (注意大小写)</span><br><span class="line">  distraction_free_mode: <span class="literal">true</span></span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>最后去每篇博客的评论区部分, 登录自己的 Github 账号来初始化 Issues 即可使用 Gitalk 评论系统.</li>
</ol>
<h2 id="去掉侧边栏的虚线"><a href="#去掉侧边栏的虚线" class="headerlink" title="去掉侧边栏的虚线"></a>去掉侧边栏的虚线</h2><p>说到这个, 就得提到博客的 &quot;即时聊天功能&quot; 了, 我知道的有: <span class="exturl" data-url="aHR0cDovL2Rhc2hib2FyZC5kYW92b2ljZS5pby8=">DaoVoice<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly93d3cudGlkaW8uY29tLw==">Tidio<i class="fa fa-external-link-alt"></i></span>, <span class="exturl" data-url="aHR0cHM6Ly9jaGF0cmEuaW8v">Chatra<i class="fa fa-external-link-alt"></i></span> 这三个. 点击即可进入官网. </p>
<p>这三个我都用过, 不过就用了几天, &quot;高级版免费试用&quot; 还是有剩余时长的. 有一点点副作用, 就是博客加载时间会变长, 有卡顿感, 说到卡顿, 不得不说的就是这个项目了: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZnaHJzaC9saXZlMmRfZGVtbw==">live2d_demo<i class="fa fa-external-link-alt"></i></span> (一个会说话, 会换装, 能拖动的看板娘). 由于我没有服务器哈, 没办法自己搭建 API 服务器, 就使用的原作者的 API 服务器, 但是你想嘛, 肯定有很多很多人都在用原作者的 API 服务器啊, 所以速度上嘛 · · · 唉, 别提了, **太慢了! ! ** 不过我还能接受, 因为 <del>~</del> 开源啊! ! ! 免费啊! ! ! 对吧? ! </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">我: 哎! 哎! 别打我! 我错了我错了! </span><br><span class="line">看板娘: 谁让你说我主人坏话的! 哼😕! </span><br></pre></td></tr></table></figure>

<p>咱们作为使用者(白嫖者), 要有良心的对吧? 感谢 fghrsh 大佬🙏! </p>
<blockquote>
<p>拓展: 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGl2ZTJkLmNvbS9qYS8=">看板娘<i class="fa fa-external-link-alt"></i></span> 类似的还有一个, 叫做 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuLyVFNSU4MSVCRCVFNiU5OCVBNSVFOCU4RiU5Qw==">伪春菜<i class="fa fa-external-link-alt"></i></span>, 有兴趣的小伙伴可以自行搜索了解. </p>
</blockquote>
<p>哎, 刚才说到哪了? 因为这四者 (DaoVoice, Tidio, Chatra, live2d) 都会让博客的加载时间变长, 而且前三者是 **收费的! 收费的! 收费的! ** (我指的是高级版本, 基础版本都是免费的) 所以到底用还是不用, 就要看各位自己的判断了, 我推荐呢, 各位试用一下, 过过瘾就行了🤣! 感觉即时聊天还不如在简介或者关于页面挂上自己的 QQ, 微信, Telegram 来得实在. </p>
<p>所以呢我并没有使用这个即时聊天功能, 侧边栏的聊天图标我也关闭显示了, 又因为我使用的是 Gemini 风格, 这就导致侧边栏处出现了 **一道虚线, 一道虚线! , 一道虚线! ! ** (终于说到重点了, 之前的废话全是说明这一条虚线出现的原因, 哈哈) 之所以我要强调, 是因为我可是连一丁点前端基础都没有啊! 这个东西折磨了我好久好久, 还好我也是一只程序猿, 耐心什么的, 还不跟玩似的! </p>
<blockquote>
<p>有想要添加  <strong>即时聊天功能</strong> 的小伙伴可以从目录那里找到相关部分说明的位置坐标, 精准定位. </p>
</blockquote>
<p>经过好长好长一段时间的折腾, 其实就是一个 F12 (原谅我真的一点前端知识都没有), 终于被我找到了解决办法: </p>
<p>在 <code>themes\next\source\css\_schemes\Pisces\_sidebar.styl</code> 文件中, 搜索: <code>feed-link</code>, 可以找到如下代码: </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.feed-link</span>, <span class="selector-class">.chat</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> dotted $grey-light;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> dotted $grey-light;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  ······</span><br><span class="line">  省略</span><br><span class="line">  ······</span><br></pre></td></tr></table></figure>

<p>其中的 <code>border-top</code> 和 <code>border-bottom</code> 就是虚线了, 将 <code>1px</code> 修改为 <code>0px</code> 就可以了, 这样虚线就消失了! </p>
<p>随便建议大家把这个也改了:, 找到 <code>themes\next\source\css\_common\components\sidebar\sidebar-author-links.styl</code> 搜索: <code>links-of-author</code>, 将 <code>margin-top</code> 修改为 <code>0px</code> 这样侧边栏社交链接上面的空隙就消失了! </p>
<h2 id="文章分享功能"><a href="#文章分享功能" class="headerlink" title="文章分享功能"></a>文章分享功能</h2><p>NexT 主题集成的分享有3种: <code>Add-this</code>, <code>Likely</code>, <code>NeedMoreShare2</code></p>
<blockquote>
<ul>
<li>add-this: 不知道为什么, 在 NexT 7.2.0 版本中, 无论我怎么设置, 就是无效, 没有任何效果, F12 控制台也没有报任何错误! 很烦! 而且还要注册账号! </li>
<li>Likely: 推荐使用, 因为可以分享 Telegram, 哈哈, 必须用啊! 不用注册账号! </li>
<li>NeedMoreShare2: 不推荐, 它的样式我也不怎么喜欢, 弃用. </li>
</ul>
</blockquote>
<p>在主题配置文件中搜索: likely 修改为自定义值, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">likely:</span><br><span class="line">  enable: true</span><br><span class="line">  look: big </span><br><span class="line">  networks:</span><br><span class="line">    twitter: Tweeter</span><br><span class="line">    facebook: Facebook</span><br><span class="line">    linkedin: LinkedIn</span><br><span class="line">    telegram: Telegram</span><br><span class="line">    whatsapp: WhatApp</span><br></pre></td></tr></table></figure>

<h2 id="搜索引擎收录"><a href="#搜索引擎收录" class="headerlink" title="搜索引擎收录"></a>搜索引擎收录</h2><p>先要判断一下自己的博客是否已经被百度谷歌等搜索引擎收录, 在搜索栏中按下面的格式输入: <code>site:域名</code> 比如我检测的时候就是这样写: <code>site:kuroha.vip</code> 如果能搜索到自己的博客网站, 就说明已经收录了, 相反就是没有收录. 话说, 一个新站, 一上来就被搜索引擎收录, 这可能吗? </p>
<h3 id="百度搜索"><a href="#百度搜索" class="headerlink" title="百度搜索"></a>百度搜索</h3><p>大概 1 年前, 就是 2018 年, 那时候将网站提交到百度是不用注册一个叫做 &quot;熊掌ID&quot; 的东西的, 但是现在不行了, 百度强制用户只有绑定了 &quot;熊掌ID&quot; 之后, 才能开始使用站长之家, 否则什么功能也用不了, 你没看错, 什么也做不了! 所以我就去注册个 &quot;熊掌ID&quot; 试试, 然后我看到了这个: 🤔 </p>
<p><img data-src="/images/next_theme_beautify/xiongzhangID1.png" alt="熊掌ID注册页面"></p>
<p><img data-src="/images/next_theme_beautify/xiongzhangID2.png" alt="熊掌ID注册页面"></p>
<p>于是我默默地将鼠标移动到了浏览器的标签页上, 按下了鼠标中键! 拜拜了您嘞! </p>
<p>如果有小伙伴就是想让百度收录自己的博客, 请参考: <span class="exturl" data-url="aHR0cHM6Ly9sdWFuemh1eGlhbi5naXRodWIuaW8vcG9zdC84MmQ5MmFkNC5odG1s">栾铸显的博客<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="谷歌搜索"><a href="#谷歌搜索" class="headerlink" title="谷歌搜索"></a>谷歌搜索</h3><p>让谷歌搜索收录自己的博客就简单多了. <strong>前提: 你能用 Google Search</strong></p>
<p>进入 <span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2guZ29vZ2xlLmNvbS9zZWFyY2gtY29uc29sZS8=">Google 站点服务平台<i class="fa fa-external-link-alt"></i></span> , 注册登录, 点击 &quot;添加资源&quot;, 选择 &quot;网址前缀&quot;, 默认的验证方法是 &quot;HTML 文件&quot;, 这个方法不适用于解析网址. 比如我的域名 &quot;kuroha.vip&quot; 就是解析到 Github Pages 上的, 所以这个方法不适用, 而且我也不推荐用这个方法. 点击 &quot;HTML文件&quot; 这四个字的位置, 你会发现刚才的页面折叠起来了.  <del>因为我之前弄的时候就卡在这里了, 死活找不到其他方法在哪里. 笨, 没办法. ~</del> 选择 &quot;HTML 标记&quot; 这个方法, 复制 content 后面的内容, 不要复制 引号. 之后打开主题配置文件, 搜索: <code>google_site_verification</code>, 将你刚才复制的一串字符粘贴上就可以了. </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">google_site_verification: xxxxxx99uVjXfXzFHr0M_2lKQ1z_jDOlFl4-6xxxxxx</span><br></pre></td></tr></table></figure>

<h2 id="文章底部打分功能"><a href="#文章底部打分功能" class="headerlink" title="文章底部打分功能"></a>文章底部打分功能</h2><p>在主题配置文件中, 搜索: rating, 修改为自定义值, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rating:</span><br><span class="line">  enable: true</span><br><span class="line">  id: *****</span><br><span class="line">  color: fc6423</span><br></pre></td></tr></table></figure>

<ul>
<li>去<span class="exturl" data-url="aHR0cHM6Ly93aWRnZXRwYWNrLmNvbS8=">这个网站<i class="fa fa-external-link-alt"></i></span>注册账号, 填写网站信息, 获取 id. </li>
<li>颜色可以自定义修改.</li>
<li>个人建议这个功能可以弃用了, 因为访客想要给文章评分的话, 也是要注册账号并登陆的, 试想一下, 有哪个访客会为了打一个没有什么意义的评分而去注册账号呢?</li>
</ul>
<h2 id="不蒜子统计"><a href="#不蒜子统计" class="headerlink" title="不蒜子统计"></a>不蒜子统计</h2><p>在主题配置文件中, 搜索: busuanzi_count, 修改为自定义值, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true # 站点总访问人数</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true # 站点总浏览次数</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true # 单篇博客浏览次数</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>

<h2 id="本地搜索功能"><a href="#本地搜索功能" class="headerlink" title="本地搜索功能"></a>本地搜索功能</h2><p>本地搜索功能需要安装依赖: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by1nZW5lcmF0b3Itc2VhcmNoZGI=">这里! <i class="fa fa-external-link-alt"></i></span></p>
<p>在主题配置文件中, 搜索: local_search, 修改为自定义值, 如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  trigger: auto</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  unescape: false</span><br></pre></td></tr></table></figure>

<h2 id="即时聊天功能"><a href="#即时聊天功能" class="headerlink" title="即时聊天功能"></a>即时聊天功能</h2><p>Next 主题配置文件中直接支持的有 <code>Chatra</code> 和 <code>Tidio</code>, 两者的使用方法基本相同, 先到官网注册账号, 他们的官网分别是 <span class="exturl" data-url="aHR0cHM6Ly9jaGF0cmEuaW8v">Chatra<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cudGlkaW9jaGF0LmNvbS8=">Tidio<i class="fa fa-external-link-alt"></i></span>, 之后在他们的网站上填写上自己的网站信息, 聊天窗口的外观也可以自己定义. </p>
<p>准备工作准备好了之后, 在账号设置中获取 <code>id</code> 和 <code>Key</code>, <code>Chatra</code> 中使用的标识码就做 <code>id</code>, <code>Tidio</code> 使用的标识码叫做 <code>Key</code>, 填写到主题配置文件中, 并将 <code>enable</code> 设置为 <code>true</code> 即可. </p>
<h2 id="博客背景动画效果"><a href="#博客背景动画效果" class="headerlink" title="博客背景动画效果"></a>博客背景动画效果</h2><p>在主题配置文件中, 搜索: canvas_nest, 修改为自定义值即可. </p>
<p>Next 中自带三种背景动画, 下面是效果预览: </p>
<p><img data-src="/images/next_theme_beautify/AnimationEffect1.png" alt="Canvas_nest"></p>
<p><img data-src="/images/next_theme_beautify/AnimationEffect2.png" alt="JavaScript 3D library"></p>
<p><img data-src="/images/next_theme_beautify/AnimationEffect3.png" alt="Canvas_ribbon"></p>
<p>下面是我的设置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: false</span><br><span class="line">  onmobile: true</span><br><span class="line">  color: &quot;0,0,255&quot;</span><br><span class="line">  opacity: 0.5</span><br><span class="line">  zIndex: -1</span><br><span class="line">  count: 99</span><br><span class="line"></span><br><span class="line">three:</span><br><span class="line">  enable: false</span><br><span class="line">  delay: false</span><br><span class="line">  three_waves: true</span><br><span class="line">  canvas_lines: true</span><br><span class="line">  canvas_sphere: true</span><br><span class="line"></span><br><span class="line">canvas_ribbon:</span><br><span class="line">  enable: true</span><br><span class="line">  size: 300</span><br><span class="line">  alpha: 0.6</span><br><span class="line">  zIndex: -1</span><br></pre></td></tr></table></figure>

<h2 id="博客加载进度条"><a href="#博客加载进度条" class="headerlink" title="博客加载进度条"></a>博客加载进度条</h2><p>在主题配置文件中, 搜索: pace, 修改为自定义值即可. 如果要用的话个人推荐 <code>loading-bar</code> 主题, 但是个人建议不要使用, 因为这样会给用户一种博客加载时间特别长, 博客很卡的感觉. </p>
<p>这是我的配置: (很显然, 我已经禁用了)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">  enable: false</span><br><span class="line">  theme: loading-bar</span><br></pre></td></tr></table></figure>

<p>博客在加载的时候, 一般是先加载文章, 之后加载附加功能, 像: Live2D, 音乐播放器, 即时聊天服务等. 所以不使用进度条的话, 在加载完文章后, 访客就可以开始浏览文章了, 这时后台再继续默默加载附加功能. 但是进度条是在博客<strong>完全加载</strong>完成后才会消失的, 所以, 如果使用了进度条功能, 访客就要继续等待, 直到附加功能也完全加载完毕才能开始浏览博客......我想如果我是访客, 我直接就切换标签页, 去逛别人的博客去了. </p>
<h1 id="手动添加华丽效果"><a href="#手动添加华丽效果" class="headerlink" title="手动添加华丽效果"></a>手动添加华丽效果</h1><h2 id="看板娘-Live2D"><a href="#看板娘-Live2D" class="headerlink" title="看板娘 Live2D"></a>看板娘 Live2D</h2><p>第一种: <code>hexo-helper-live2d</code> 优点: 有声音, 缺点: 无法换装, 无法换模型, 响应事件少.</p>
<p>使用方法见官方网址: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VZSE4vaGV4by1oZWxwZXItbGl2ZTJk">hexo-helper-live2d<i class="fa fa-external-link-alt"></i></span></p>
<p>第二种: <code>live2d-widget</code> 优点: 能换装, 能切换模型, 响应事件多, 缺点: 无声音, 配置较复杂.  (现在可能已经有声音了)</p>
<p>使用方法见官方网址: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0ZXZlbmpvZXpoYW5nL2xpdmUyZC13aWRnZXQ=">live2d-widget<i class="fa fa-external-link-alt"></i></span></p>
<p>第三种: <code>live2d_demo</code> 优点: 能换装, 能切换模型, 响应事件多, 缺点: 无声音, 配置较复杂.  (现在可能已经有声音了)</p>
<p>使用方法见官方网址: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZnaHJzaC9saXZlMmRfZGVtbw==">live2d_demo<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="音乐播放器-Aplayer"><a href="#音乐播放器-Aplayer" class="headerlink" title="音乐播放器 Aplayer"></a>音乐播放器 Aplayer</h2><blockquote>
<p>Aplayer 源码地址: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vZVBsYXllci9BUGxheWVy">APlayer<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>首先, 在 <code>next/source/lib</code> 目录下新建 <code>aplayer</code> 文件夹, 之后下载项目源码并解压, 将 <code>APlayer.min.js</code> 和 <code>APlayer.min.css</code> 文件复制到 <code>next/source/lib/aplayer</code> 中. </p>
<p>再之后, 继续在当前目录下新建一个 <code>music.js</code> 文件, 输入以下代码: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ap = <span class="keyword">new</span> APlayer(&#123;</span><br><span class="line">    container: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;aplayer&#x27;</span>),</span><br><span class="line">    fixed: <span class="literal">true</span>,</span><br><span class="line">    autoplay: <span class="literal">false</span>,</span><br><span class="line">    audio: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">&#x27;歌曲的名字&#x27;</span>,</span><br><span class="line">        artist: <span class="string">&#x27;歌手&#x27;</span>,</span><br><span class="line">        url: <span class="string">&#x27;音乐文件的地址&#x27;</span>,</span><br><span class="line">        cover: <span class="string">&#x27;封面图片的地址&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>之后修改 <code>themes/next/layout/_layout.swing</code> 在文件最后添加: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--Aplayer 音乐播放功能--&gt;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.aplayer %&#125;</span><br><span class="line">  &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/lib/aplayer/APlayer.min.css&quot;</span>&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;aplayer&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/lib/aplayer/APlayer.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/lib/aplayer/music.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>最后在 <strong>主题配置文件</strong> 中, 找一个自己喜欢的位置, 写入 <code>aplayer: true</code>. 什么时候想要关闭这个功能了, 直接设置为 false 即可. </p>
<h2 id="鼠标红心效果"><a href="#鼠标红心效果" class="headerlink" title="鼠标红心效果"></a>鼠标红心效果</h2><p>在 <code>themes/next/source/js/src</code> 下创建 <code>love.js</code> 文件, 粘贴以下内容:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params">e, t, a</span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        c(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>), o(), r() </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> e = <span class="number">0</span>; e &lt; d.length; e++)</span><br><span class="line">            d[e].alpha &lt;= <span class="number">0</span> ? (t.body.removeChild(d[e].el), d.splice(e, <span class="number">1</span>)) : (d[e].y-- , d[e].scale += <span class="number">.004</span>, d[e].alpha -= <span class="number">.013</span>, d[e].el.style.cssText = <span class="string">&quot;left:&quot;</span> + d[e].x + <span class="string">&quot;px;top:&quot;</span> + d[e].y + <span class="string">&quot;px;opacity:&quot;</span> + d[e].alpha + <span class="string">&quot;;transform:scale(&quot;</span> + d[e].scale + <span class="string">&quot;,&quot;</span> + d[e].scale + <span class="string">&quot;) rotate(45deg);background:&quot;</span> + d[e].color + <span class="string">&quot;;z-index:99999&quot;</span>); </span><br><span class="line">            </span><br><span class="line">        requestAnimationFrame(r) </span><br><span class="line">    &#125; </span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">var</span> t = <span class="string">&quot;function&quot;</span> == <span class="keyword">typeof</span> e.onclick &amp;&amp; e.onclick; </span><br><span class="line">        </span><br><span class="line">        e.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span></span><br><span class="line"><span class="function">        </span>&#123; </span><br><span class="line">            t &amp;&amp; t(), i(e) </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>) </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">var</span> a = t.createElement(<span class="string">&quot;div&quot;</span>); </span><br><span class="line">        a.className = <span class="string">&quot;heart&quot;</span>, d.push(&#123; <span class="attr">el</span>: a, <span class="attr">x</span>: e.clientX - <span class="number">5</span>, <span class="attr">y</span>: e.clientY - <span class="number">5</span>, <span class="attr">scale</span>: <span class="number">1</span>, <span class="attr">alpha</span>: <span class="number">1</span>, <span class="attr">color</span>: s() &#125;), t.body.appendChild(a)</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>) </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">var</span> a = t.createElement(<span class="string">&quot;style&quot;</span>); </span><br><span class="line">        a.type = <span class="string">&quot;text/css&quot;</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123; </span><br><span class="line">            a.appendChild(t.createTextNode(e)) </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (t) </span><br><span class="line">        &#123; </span><br><span class="line">            a.styleSheet.cssText = e </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        t.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(a) </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;rgb(&quot;</span> + ~~(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">&quot;,&quot;</span> + ~~(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">&quot;,&quot;</span> + ~~(<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">&quot;)&quot;</span> </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> d = []; </span><br><span class="line">    </span><br><span class="line">    e.requestAnimationFrame = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="built_in">setTimeout</span>(e, <span class="number">1e3</span> / <span class="number">60</span>) &#125; </span><br><span class="line">    &#125;(), n()</span><br><span class="line">    </span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>

<p>之后修改 <code>themes/next/layout/_layout.swing</code> 在文件最后添加: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--页面点击小桃心--&gt;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.love %&#125;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/love.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>最后在 <strong>主题配置文件</strong> 中, 找一个自己喜欢的位置, 写入 <code>love: true</code>. 什么时候想要关闭这个功能了, 直接设置为 false 即可. </p>
<h2 id="页面标题欺诈"><a href="#页面标题欺诈" class="headerlink" title="页面标题欺诈"></a>页面标题欺诈</h2><p>在 <code>themes/next/source/js/</code> 下创建 <code>crash_cheat.js</code> 文件, 粘贴以下内容:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--崩溃欺骗--&gt;</span><br><span class="line"><span class="keyword">var</span> OriginTitle = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="keyword">var</span> titleTime;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">        $(<span class="string">&#x27;[rel=&quot;shortcut icon&quot;]&#x27;</span>).attr(<span class="string">&#x27;href&#x27;</span>, <span class="string">&quot;/images/sao-16x16.png&quot;</span>);</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">&#x27;😰 w(ﾟДﾟ)w 页面崩溃啦!  &#x27;</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(titleTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">&#x27;[rel=&quot;shortcut icon&quot;]&#x27;</span>).attr(<span class="string">&#x27;href&#x27;</span>, <span class="string">&quot;/images/sao-16x16.png&quot;</span>);</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">&#x27;😏 ♪(^∇^*) 噫? 又好了! &#x27;</span>;</span><br><span class="line">        titleTime = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.title = <span class="string">&#x27;🤔 啊来来! 原标题是啥来着?  &#x27;</span>;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">		</span><br><span class="line">		titleTime = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.title = <span class="string">&#x27;😮哦~! 想起来了!  &#x27;</span>;</span><br><span class="line">        &#125;, <span class="number">4000</span>);</span><br><span class="line">		</span><br><span class="line">		titleTime = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.title = OriginTitle;</span><br><span class="line">        &#125;, <span class="number">6000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>之后修改 <code>themes/next/layout/_layout.swing</code> 在文件最后添加: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--崩溃欺骗--&gt;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.crashcheat %&#125;</span><br><span class="line">  &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/crash_cheat.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>最后在 <strong>主题配置文件</strong> 中, 找一个自己喜欢的位置, 写入 <code>crashcheat: true</code>. 什么时候想要关闭这个功能了, 直接设置为 false 即可. </p>
<h2 id="球形标签云"><a href="#球形标签云" class="headerlink" title="球形标签云"></a>球形标签云</h2><p>球形标签云其实就是用这个插件 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29hdDEwMDAuY29tL3RhZ2NhbnZhcy5waHA=">TagCanvas<i class="fa fa-external-link-alt"></i></span> 实现的, 点击进入官网. </p>
<p>进入官网后下载 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29hdDEwMDAuY29tL3RhZ2NhbnZhcy5qcw==">tagcanvas.js<i class="fa fa-external-link-alt"></i></span> 文件, 也可以直接在左面我给出的链接那里 &quot;右键-&gt;链接另存为&quot;, 保存到: <code>themes\next\source\js</code> 目录下. </p>
<p>打开 <code>themes\next\layout\page.swig</code> 文件, 如果你已经开启了 &quot;自定义 swig 功能&quot;,  <del>其实开不开也无所谓啦</del> , 进入博客网站根目录下的 <code>source</code> 文件夹, 打开 <code>_data</code> 文件夹, 没有的话就新建一个, 叫做 <code>_data</code> , 在 <code>_data</code> 文件夹中再新建一个 <code>tagcanvas.swig</code> 文件, 打开这个文件, 粘贴以下内容:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tags&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myTags&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">&quot;350&quot;</span> <span class="attr">height</span>=<span class="string">&quot;350&quot;</span> <span class="attr">id</span>=<span class="string">&quot;my3DTags&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> Anything in here will be replaced on browsers that support the canvas element <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tags&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tags&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; tagcloud(&#123;</span><br><span class="line">      min_font: 16,</span><br><span class="line">      max_font: 35,</span><br><span class="line">      amount: 999,</span><br><span class="line">      color: true,</span><br><span class="line">      start_color: &#x27;black&#x27;,</span><br><span class="line">      end_color: &#x27;green&#x27;,</span><br><span class="line">    &#125;) &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcanvas.js&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> &gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">try</span></span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="javascript">      TagCanvas.Start(<span class="string">&#x27;my3DTags&#x27;</span>,<span class="string">&#x27;tags&#x27;</span>,</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="javascript">        textFont: <span class="string">&#x27;Georgia,Optima&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        textColour: <span class="literal">null</span>,</span></span><br><span class="line"><span class="javascript">        outlineColour: <span class="string">&#x27;black&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        weight: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        reverse: <span class="literal">true</span>,</span></span><br><span class="line">        depth: 0.8,</span><br><span class="line">        maxSpeed: 0.05,</span><br><span class="line">        bgRadius: 1,</span><br><span class="line"><span class="javascript">        freezeDecel: <span class="literal">true</span></span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="javascript">    <span class="keyword">catch</span> (e) </span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myTags&#x27;</span>).style.display = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后打开 <code>themes\next\layout\page.swig</code> 文件, 找到 43, 44 行之间的位置, 没有行数标记的话, 就搜索 <code>tag-cloud-tags</code> , 它所在的位置就是第 44 行. 在这一行的上面添加如下内容:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;# 球形云标签 #&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.tagcanvas %&#125;</span><br><span class="line">&#123;% include <span class="string">&#x27;../../../source/_data/tagcanvas.swig&#x27;</span> %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;# 普通云标签 #&#125;</span><br></pre></td></tr></table></figure>

<p>最后在 <strong>主题配置文件</strong> 中, 找一个自己喜欢的位置, 写入 <code>tagcanvas: true</code> 即可. </p>
<blockquote>
<p><a href="%E5%88%AB%E5%BF%98%E4%BA%86%E5%9C%A8%E5%AF%B9%E5%BA%94%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E5%A4%B4%E5%83%8F%E6%96%87%E4%BB%B6">注</a> 球形标签云也可以使用 <code>hexo-tag-cloud</code> 插件来实现, 不过我没用这种方法, 有时间的话我再试试吧. 执行我上面的操作后, 球形标签云和普通标签云是同时存在的, 如果你只想要显示球形标签云, 还是在 <code>page.swig</code> 文件中, 把后面那个 <code>普通云标签</code> 的 <code>div</code> 标签注释掉就行了. 就像这样:</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;# 球形云标签 #&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.tagcanvas %&#125;</span><br><span class="line">&#123;% include <span class="string">&#x27;../../../source/_data/tagcanvas.swig&#x27;</span> %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;# 普通云标签 #&#125;</span><br><span class="line">&#123;# &lt;div class=&quot;tag-cloud-tags&quot;&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> not theme.tagcloud %&#125;</span><br><span class="line">    &#123;&#123; tagcloud(&#123;<span class="attr">min_font</span>: <span class="number">12</span>, <span class="attr">max_font</span>: <span class="number">30</span>, <span class="attr">amount</span>: <span class="number">200</span>, <span class="attr">color</span>: <span class="literal">true</span>, <span class="attr">start_color</span>: <span class="string">&#x27;#ccc&#x27;</span>, <span class="attr">end_color</span>: <span class="string">&#x27;#111&#x27;</span>&#125;) &#125;&#125;</span><br><span class="line">  &#123;% <span class="keyword">else</span> %&#125;</span><br><span class="line">    &#123;&#123; tagcloud(&#123;<span class="attr">min_font</span>: theme.tagcloud.min, <span class="attr">max_font</span>: theme.tagcloud.max, <span class="attr">amount</span>: theme.tagcloud.amount, <span class="attr">color</span>: <span class="literal">true</span>, <span class="attr">start_color</span>: theme.tagcloud.start, <span class="attr">end_color</span>: theme.tagcloud.end&#125;) &#125;&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt; #&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文章写作部分"><a href="#文章写作部分" class="headerlink" title="文章写作部分"></a>文章写作部分</h1><h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><h3 id="Markdown-支持部分-html-标签"><a href="#Markdown-支持部分-html-标签" class="headerlink" title="Markdown 支持部分 html 标签"></a>Markdown 支持部分 html 标签</h3><ol>
<li><p><code>&lt;kbd&gt;</code> 标签</p>
<p> <code>&lt;kbd&gt;</code> 标签可以将其中的文字渲染成一个按键, 虽然目前 <code>&lt;kbd&gt;</code> 已经被标记为了 &quot;过时的&quot; 标签, 但是还是可以使用其来实现简单的效果.</p>
<p> <code>复制的快捷键是: &lt;kbd&gt;Ctrl&lt;/kbd&gt; &lt;kbd&gt;C&lt;/kbd&gt;</code></p>
<p> 复制的快捷键是: <kbd>Ctrl</kbd> <kbd>C</kbd></p>
</li>
<li><p><code>&lt;font&gt;</code> 标签</p>
<p> 利用 font 标签可以简单修改文字的颜色, 加粗斜体这些可以直接使用 Markdown 的语法.</p>
<p> <code>&lt;font color=&#39;red&#39;&gt; *这是红色斜体* &lt;/font&gt; &lt;font color=&#39;green&#39;&gt; **这是绿色粗体** &lt;/font&gt;</code></p>
<p> <font color='red'> <em>这是红色斜体</em> </font> <font color='green'> <strong>这是绿色粗体</strong> </font></p>
</li>
</ol>
<h2 id="Hexo-博客的属性设置"><a href="#Hexo-博客的属性设置" class="headerlink" title="Hexo 博客的属性设置"></a>Hexo 博客的属性设置</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">title: <span class="comment">//文章标题</span></span><br><span class="line">date: <span class="comment">//博客的建立日期, 如果自己手动添加, 请按固定格式添加</span></span><br><span class="line">categories: <span class="comment">//分类, 支持多级</span></span><br><span class="line">tags: <span class="comment">//标签, 多个: [标签1,标签2,标签3]</span></span><br><span class="line">description: <span class="comment">//文章的描述, 在每篇文章标题下方显示, 并且作为网页的 description 元数据. 如果不写, 则自动取 &lt;!-- more --&gt; 之前的文字作为网页的 description 元数据. 建议每篇文章都务必加上!</span></span><br><span class="line">keywords: <span class="comment">//关键字, 并且作为网页的 keywords 元数据. 如果不写, 则自动取 tags 里的项作为网页的 keywords 元数据</span></span><br><span class="line">comments: <span class="literal">true</span> | <span class="literal">false</span> <span class="comment">//是否开启评论</span></span><br><span class="line">layout: <span class="comment">//页面布局, 默认值是 post, 默认值可以在站点配置文件中修改 default_layout</span></span><br></pre></td></tr></table></figure>

<h2 id="Gitpages-支持任务列表"><a href="#Gitpages-支持任务列表" class="headerlink" title="Gitpages 支持任务列表"></a>Gitpages 支持任务列表</h2><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> [X] item 1</span><br><span class="line"><span class="bullet">    *</span> [X] item A</span><br><span class="line"><span class="bullet">    *</span> [ ] item B</span><br><span class="line"><span class="code">        more text</span></span><br><span class="line"><span class="code">        + [x] item a</span></span><br><span class="line"><span class="code">        + [ ] item b</span></span><br><span class="line"><span class="code">        + [x] item c</span></span><br><span class="line"><span class="code">    * [X] item C</span></span><br><span class="line"><span class="code">- [ ] item 2</span></span><br><span class="line"><span class="code">- [ ] item 3</span></span><br></pre></td></tr></table></figure>

<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul>
<li><input checked="" disabled="" type="checkbox"> item 1<ul>
<li><input checked="" disabled="" type="checkbox"> item A</li>
<li><input disabled="" type="checkbox"> item B<br>  more text<ul>
<li><input checked="" disabled="" type="checkbox"> item a</li>
<li><input disabled="" type="checkbox"> item b</li>
<li><input checked="" disabled="" type="checkbox"> item c</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> item C</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> item 2</li>
<li><input disabled="" type="checkbox"> item 3</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 参考手册</title>
    <url>/program/javascript_notes.html</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是<span class="exturl" data-url="aHR0cDovL3d3dy5jbmZhbi5uZXQv">这个网站<i class="fa fa-external-link-alt"></i></span>发布的 Javascript 使用手册的二次整理, 或者说是 Markdown 移植版. 由于本文也是说明手册性质的, 章节之间并没有过渡性语言, 知识点之间是非常零散化的, 所以不适合作为学习型书籍阅读, 而是适合作为手册查询使用. </p>
<h1 id="JavaScript-简介"><a href="#JavaScript-简介" class="headerlink" title="JavaScript 简介"></a>JavaScript 简介</h1><p>JavaScript 是网景 (Netscape) 公司开发的一种基于对象, 事件驱动式的网页脚本语言. JavaScript 语言的前身叫作 Livescript. </p>
<h2 id="JavaScript-的特点"><a href="#JavaScript-的特点" class="headerlink" title="JavaScript 的特点"></a>JavaScript 的特点</h2><ul>
<li>简单, 易学, 易用.  </li>
<li>跨平台: IE, Navigator. </li>
<li>符合 ECMA (欧洲计算机制造协会) 标准, 可移植.  </li>
<li>事件驱动式的脚本程序设计思想.  </li>
<li>动态, 交互式的操作方式. </li>
</ul>
<h2 id="JavaScript-的作用"><a href="#JavaScript-的作用" class="headerlink" title="JavaScript 的作用"></a>JavaScript 的作用</h2><ul>
<li>交互式操作.  </li>
<li>表单验证.  </li>
<li>网页特效.  </li>
<li>Web游戏.</li>
<li>服务器脚本开发等.  </li>
</ul>
<h2 id="JavaScript-的执行平台"><a href="#JavaScript-的执行平台" class="headerlink" title="JavaScript 的执行平台"></a>JavaScript 的执行平台</h2><ul>
<li>浏览器.</li>
</ul>
<h2 id="JavaScript-的执行方式"><a href="#JavaScript-的执行方式" class="headerlink" title="JavaScript 的执行方式"></a>JavaScript 的执行方式</h2><ul>
<li>解释执行 (由上而下).</li>
</ul>
<h2 id="JavaScript-与-Java-的区别"><a href="#JavaScript-与-Java-的区别" class="headerlink" title="JavaScript 与 Java 的区别"></a>JavaScript 与 Java 的区别</h2><ul>
<li>首先, 它们是两个公司开发的不同的两个产品. </li>
</ul>
<p>Java 是 SUN 公司推出的面向对象程序设计语言, 而 JavaScript 是 Netscape 公司的产品, 是为了扩展 Netscape Navigator 功能而开发的一种可以嵌入 Web 页面中的基于对象和事件驱动的解释性语言. </p>
<ul>
<li>其次, JavaScript 是基于对象的, 而 Java 是面向对象的. </li>
</ul>
<p>Java 是一种真正的面向对象的语言, 即使是开发简单的程序, 也必须设计对象. JavaScript 是一种基于对象和事件驱动的脚本语言, 它本身提供了非常丰富的内部对象供设计人员使用. </p>
<ul>
<li>第三, 两种语言在其浏览器中所执行的方式不一样. </li>
</ul>
<p>Java 的源代码在传递到客户端执行之前必须经过编译, 因而客户端上必须具有相应平台上的仿真器或解释器. JavaScript 是一种解释性编程语言, 其源代码在发往客户端执行之前不需经过编译, 而是将文本格式的字符代码直接发送给客户, 由浏览器来解释执行. </p>
<ul>
<li>第四, 两种语言所采取的变量是不一样的. </li>
</ul>
<p>Java 采用强类型变量检查, 即所有变量在编译之前必须作类型的声明. JavaScript 中变量声明, 采用弱类型, 即变量在使用前不需作声明类型, 而是解释器在运行时检查其数据类型. </p>
<ul>
<li>第五, 代码格式不一样. </li>
</ul>
<p>Java 是一种与 HTML 无关的格式, 必须通过像 HTML 中引用外媒体那样进行装载, 其代码以字节代码的形式保存在独立的文档中. JavaScript 的代码是一种文本字符格式, 可以直接嵌入 HTML 文档中, 并且可动态装载. </p>
<ul>
<li>第六, 嵌入方式不一样. </li>
</ul>
<p>在 HTML 文档中, 两种编程语言的标识不同, JavaScript使用 <code>&lt;script&gt;...&lt;/script&gt;</code> 来标识, 而 Java 使用<code>&lt;applet&gt; ... &lt;/applet&gt;</code> 来标识. </p>
<ul>
<li>第七, 静态绑定和动态绑定. </li>
</ul>
<p>Java 采用静态联编, 即 Java 的对象引用必须在编译时的进行, 以使编译器能够实现强类型检查, 如不经编译则就无法实现对象引用的检查. JavaScript 采用动态联编, 即 JavaScript 的对象引用在运行时进行检查. </p>
<h1 id="JavaScript-代码格式"><a href="#JavaScript-代码格式" class="headerlink" title="JavaScript 代码格式"></a>JavaScript 代码格式</h1><ul>
<li>JavaScript 脚本程序代码区分大小写. </li>
<li>JavaScript 脚本程序不能单独运行, 必须嵌入在 HTML 文件中才能执行. </li>
<li>JavaScript 脚本程序中不能包含 HTML 代码, 但是字符串中可以包含</li>
</ul>
<p><code>document.write(&quot;Kirito&lt;br&gt;Asuna&quot;)</code>. </p>
<ul>
<li>JavaScript 脚本程序可以独立保存为一个外部文件, 但其中不能包含 <code>&lt;script&gt; &lt;/script&gt;</code> 标签. </li>
</ul>
<p>HTML 标签语言中引用 JavaScript 脚本语言需要使用 <code>&lt;script&gt; &lt;/script&gt;</code> 标签, 标签内部就是 JavaScript 脚本代码. </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JavaScript&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/JavaScript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">&quot; Hello World &quot;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>HTML 中使用 <code>&lt;!-- 单/多行注释 --&gt;</code> 进行注释, 并且 HTML 的注释只有这一种, 可以注释任意行. </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;JavaScript1.2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/JavaScript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;hello.js&quot;</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="comment">&lt;!-- document.write(&quot;Hello World!!!&quot;); --&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 中使用 <code>// 单行注释</code> 和 <code>/* 多行注释 */</code> 进行注释. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// document.write(&quot;Hello World!!!&quot;);</span></span><br><span class="line"><span class="comment">/* document.write(&quot;Hello World!!!&quot;); */</span></span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h1><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><table>
<thead>
<tr>
<th align="left">转义字符</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\b</td>
<td align="left">退格 (Backspace)</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页 (Form feed)</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行 (New line)</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">返回 (Carriage return)</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">制表符 (Tab)</td>
</tr>
<tr>
<td align="left">\&#39;</td>
<td align="left">单引号 (&#39;)</td>
</tr>
<tr>
<td align="left">\&quot;</td>
<td align="left">双引号 (&quot;)</td>
</tr>
<tr>
<td align="left">\\</td>
<td align="left">反斜线 ()</td>
</tr>
</tbody></table>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">定义: stringArray = [<span class="string">&quot;听音乐&quot;</span>, <span class="string">&quot;看电影&quot;</span>]</span><br><span class="line">取值: stringArray[<span class="number">0</span>] stringArray[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>由于 JavaScript 使用弱类型, 所以一般情况下变量的定义都使用 <code>var</code> 进行定义. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stdId = <span class="number">0001</span>;</span><br><span class="line"><span class="keyword">var</span> notNull = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Kirito&quot;</span>, sex = <span class="string">&quot;Male&quot;</span>;</span><br><span class="line"><span class="comment">// JavaScript 中没有 Char 类型, 只有 String 类型. </span></span><br><span class="line"><span class="comment">// 单引号 &#x27;&#x27; 和 双引号 &quot;&quot; 都表示字符串, 没有区别.  </span></span><br></pre></td></tr></table></figure>

<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数外进行声明, 也可以通过省略掉 var 关键字的方式进行声明, 但是不建议使用这种省略的方式. </p>
<p>全局变量可在整个脚本中被使用, 可在不同的窗口中相互引用. </p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数内声明, 只能在函数内部使用. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> langJS = <span class="string">&quot;JavaScript&quot;</span>; <span class="comment">// langJS 在函数外部进行定义, 是全局变量. </span></span><br><span class="line"></span><br><span class="line">PintString();<span class="comment">// 调用 PintString() 方法. </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PintString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> langVBS = <span class="string">&quot;VBScript&quot;</span>; <span class="comment">// langVBS 在函数内部进行定义, 是局部变量. </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&quot;&lt;br&gt;&quot;</span> + langJS + <span class="string">&quot;&lt;br&gt;&quot;</span>);<span class="comment">// 可以打印 全局变量 langJS</span></span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&quot;&lt;br&gt;&quot;</span> + langVBS + <span class="string">&quot;&lt;br&gt;&quot;</span>);<span class="comment">// 可以打印 局部变量 langVBS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;br&gt;&quot;</span> + langJS + <span class="string">&quot;&lt;br&gt;&quot;</span>);<span class="comment">//函数外部只能打印 全局变量 langJS</span></span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-运算符"><a href="#JavaScript-运算符" class="headerlink" title="JavaScript 运算符"></a>JavaScript 运算符</h1><ul>
<li><code>+</code> 和 <code>+=</code> 在 JavaScript 中也可以进行字符串的拼接. </li>
<li><code>==</code> 和 <code>!=</code> 只用于判断两个变量之间的值是否相等. </li>
<li><code>===</code> 和 <code>!==</code> 用于判断两个变量之间的值以及变量的类型是否相等. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// x 是数值 5</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="string">&#x27;5&#x27;</span>; <span class="comment">// y 是字符串 5</span></span><br><span class="line"><span class="keyword">var</span> z = <span class="string">&quot;5&quot;</span>; <span class="comment">// z 是字符串 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&amp;&amp;</code> 运算符在运算时, 如果左右两方全是逻辑值, 那么此时它和普通的 <code>&amp;&amp;</code> 运算符功能完全一样, 返回逻辑值. </p>
</li>
<li><p><code>&amp;&amp;</code> 运算符在运算时, 如果左右两方中有一方不是逻辑值, 也不是 <code>null</code>, 也不是 <code>数字0</code>, 那么返回的值取决于左面的值, 而且此时返回的值不一定是逻辑值了: </p>
</li>
<li><ul>
<li>如果左面的值是 <code>true</code>, 那么返回右面的值. </li>
</ul>
</li>
<li><ul>
<li>如果左面的值是 <code>false</code>, 那么就返回 <code>false</code>. </li>
</ul>
</li>
<li><ul>
<li>如果左面的值是除了 <code>null</code> 和 <code>数字0</code> 以外的非逻辑值, 那么等同于 <code>true</code>, 返回右面的值. </li>
</ul>
</li>
<li><p><code>&amp;&amp;</code> 运算符在运算时, 如果左右两方中任意一方是 <code>null</code> 或者 <code>数字0</code>, 那么先遇到谁就返回谁. </p>
</li>
<li><p><code>||</code> 运算符在运算时, 如果左右两方全是逻辑值, 那么此时它和普通的 <code>||</code> 运算符功能完全一样. </p>
</li>
<li><p><code>||</code> 运算符在运算时, 如果左右两方中有一方不是逻辑值, 也不是 <code>null</code>, 也不是 <code>数字0</code>, 那么返回的值取决于左面的值, 而且此时返回的值不一定是逻辑值了: </p>
</li>
<li><ul>
<li>如果左面的值是 <code>true</code>, 那么直接返回 <code>true</code>. </li>
</ul>
</li>
<li><ul>
<li>如果左面的值是 <code>false</code> 或 <code>null</code> 或 <code>数字0</code>, 那么返回右面的值, 否则返回左面的值. </li>
</ul>
</li>
<li><ul>
<li><code>||</code> 运算符在运算时, <code>null</code> || <code>null</code> 返回 <code>null</code>. </li>
</ul>
</li>
<li><ul>
<li><code>||</code> 运算符在运算时, <code>数字0</code> || <code>数字0</code> 返回 <code>数字0</code>. </li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>总之, 由于 JavaScript 是弱类型语言, 所以在使用 <code>&amp;&amp;</code> 以及 <code>||</code> 的时候, 一定要确保左右的值都是逻辑值</strong>. </p>
</blockquote>
<ul>
<li><p><code>!</code> 运算符的返回值就很单一了, 只会返回逻辑值. <code>数字0</code> 会被视为 <code>false</code>, 其他除了 <code>null</code> 以外的非逻辑值被视为 <code>true</code>,  <code>null</code> 不能进行取反操作, 会直接报错. </p>
</li>
<li><p>三元运算符, 格式: <code>(条件表达式) ? true 返回值 : false 返回值</code></p>
</li>
</ul>
<h1 id="JavaScript-语句"><a href="#JavaScript-语句" class="headerlink" title="JavaScript 语句"></a>JavaScript 语句</h1><h2 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h2><ul>
<li>功能: 为一段程序建立默认对象, 这样整个 with 语句中的方法就可以不用写默认的对象, 可以直接调用.  </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> (<span class="built_in">document</span>)</span><br><span class="line">&#123;</span><br><span class="line">    write (<span class="string">&quot;┭┮﹏┭┮&quot;</span>);</span><br><span class="line">    write (<span class="string">&quot;o((&gt;ω&lt; ))o&quot;</span>);</span><br><span class="line">    <span class="comment">//document.write (&quot;o((&gt;ω&lt; ))o&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>for, while, do while, if else, switch 等流程控制语句和其他编程语言没有区别.  </p>
<h2 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for in 语句"></a>for in 语句</h2><p>依次取出指定对象的所有属性, 类似于 foreach 语句. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> 临时变量名 <span class="keyword">in</span> 对象 )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 临时变量中就会依次保存对象中的所有属性. </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h1><h2 id="默认对象-之-日期对象-Date"><a href="#默认对象-之-日期对象-Date" class="headerlink" title="默认对象 之 日期对象 (Date)"></a>默认对象 之 日期对象 (Date)</h2><ul>
<li>日期基线</li>
</ul>
<p>1970-01-01 00:00:00</p>
<ul>
<li>实例化一个日期对象</li>
</ul>
<p><code>名称 = new Date (参数)</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 英文-数值格式: 月 日, 公元年</span></span><br><span class="line">today = <span class="keyword">new</span> <span class="built_in">Date</span> (<span class="string">&quot;October 1, 2008&quot;</span>);</span><br><span class="line"><span class="comment">// 英文-数值格式: 月 日, 公元年 [时: 分: 秒] </span></span><br><span class="line">today = <span class="keyword">new</span> <span class="built_in">Date</span> (<span class="string">&quot;October 1, 2008 12:00:00&quot;</span>);</span><br><span class="line"><span class="comment">// 数值格式: 公元年, 月, 日</span></span><br><span class="line">today = <span class="keyword">new</span> <span class="built_in">Date</span> (<span class="number">2008</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 数值格式: 公元年, 月, 日, [时, 分, 秒]</span></span><br><span class="line">today = <span class="keyword">new</span> <span class="built_in">Date</span> (<span class="number">2008</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>日期对象的方法</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getYear()</td>
<td align="left">返回年份数</td>
</tr>
<tr>
<td align="left">getFullYear()</td>
<td align="left">返回年份数</td>
</tr>
<tr>
<td align="left">getMonth()</td>
<td align="left">返回月份数 (0--11)</td>
</tr>
<tr>
<td align="left">getDate()</td>
<td align="left">返回日期数 (1--31)</td>
</tr>
<tr>
<td align="left">getDay()</td>
<td align="left">返回星期数 (0--6)</td>
</tr>
<tr>
<td align="left">getHours()</td>
<td align="left">返回小时数 (0--23)</td>
</tr>
<tr>
<td align="left">getMinutes()</td>
<td align="left">返回分钟数 (0--59)</td>
</tr>
<tr>
<td align="left">getSeconds()</td>
<td align="left">返回秒数 (0--59)</td>
</tr>
<tr>
<td align="left">getMilliseconds()</td>
<td align="left">返回毫秒数 (0--999)</td>
</tr>
<tr>
<td align="left">getTime()</td>
<td align="left">返回对应日期基线的毫秒数</td>
</tr>
<tr>
<td align="left">Date.parse(日期字串)</td>
<td align="left">返回对应日期基线的毫秒</td>
</tr>
<tr>
<td align="left">setTime(时间值)</td>
<td align="left">指定一日期对象的值</td>
</tr>
<tr>
<td align="left">toGMTString()</td>
<td align="left">以 GMT 格式的字符串表示日期对象</td>
</tr>
<tr>
<td align="left">toUTCString()</td>
<td align="left">以 UTC 格式的字符串表示日期对象</td>
</tr>
</tbody></table>
<h2 id="默认对象-之-一维数组-Array"><a href="#默认对象-之-一维数组-Array" class="headerlink" title="默认对象 之 一维数组 (Array)"></a>默认对象 之 一维数组 (Array)</h2><ul>
<li>实例化一个数组对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stringArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);<span class="comment">//先定义数组大小, 再赋值. </span></span><br><span class="line">stringArray[<span class="number">0</span>] = <span class="string">&quot;Kirito&quot;</span>;</span><br><span class="line">stringArray[<span class="number">1</span>] = <span class="string">&quot;Asuna&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stringArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Kirito&quot;</span>, <span class="string">&quot;Asuna&quot;</span>);<span class="comment">//定义的时候直接赋值. </span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">stringArray = [<span class="string">&quot;Kirito&quot;</span>, <span class="string">&quot;Asuna&quot;</span>];<span class="comment">//省略式写法, 使用中括号. (不推荐新人使用这种写法)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>数组对象的属性 <code>length</code>, 返回数组长度. </p>
</li>
<li><p>数组对象的方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">join( )</td>
<td align="left">将所有的数组元素组合成一个字符串, 然后返回. 各个数组元素之间使用英文的 &#39;,&#39; 连接.</td>
</tr>
<tr>
<td align="left">join(&#39;str&#39;)</td>
<td align="left">将所有的数组元素组合成一个字符串, 然后返回, 各个数组元素之间使用 &#39;str&#39; 连接.</td>
</tr>
<tr>
<td align="left">toString( )</td>
<td align="left">将所有的数组元素组合成一个字符串, 然后返回. 各个数组元素之间使用英文的 &#39;,&#39; 连接.</td>
</tr>
<tr>
<td align="left">reverse( )</td>
<td align="left">数组反转</td>
</tr>
<tr>
<td align="left">valueOf( )</td>
<td align="left">将所有的数组元素组合成一个字符串, 然后返回. 各个数组元素之间使用英文的 &#39;,&#39; 连接.</td>
</tr>
</tbody></table>
<h2 id="默认对象-之-交错数组"><a href="#默认对象-之-交错数组" class="headerlink" title="默认对象 之 交错数组"></a>默认对象 之 交错数组</h2><p>交错数组并不是仅仅只有两层, 可以循环定义从而构成多层交错数组, 但是多层交错数组操作难度是相当高的. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fruit = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">fruit[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;苹果&quot;</span>, <span class="number">2</span>);</span><br><span class="line">fruit[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;梨子&quot;</span>, <span class="number">3</span>);</span><br><span class="line">fruit[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;橘子&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fruit.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; fruit[<span class="number">0</span>].length; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&quot;fruit [&quot;</span>, i, <span class="string">&quot;][&quot;</span>, j, <span class="string">&quot;] = &quot;</span>, fruit[i][j],<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认对象-之-字符串对象-String"><a href="#默认对象-之-字符串对象-String" class="headerlink" title="默认对象 之 字符串对象 (String)"></a>默认对象 之 字符串对象 (String)</h2><ul>
<li>实例化一个字符串对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strName = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;Kirito&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> strNameFemale = <span class="string">&#x27;Asuna&#x27;</span>;</span><br><span class="line"><span class="comment">// JavaScript 中 单引号 和 双引号 都表示字符串, JavaScript 中没有 Char 类型. </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>字符串对象的属性: <code>length</code>　返回字符串的长度. </p>
</li>
<li><p>字符串对象的方法: </p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">使用方法: str.bold ( )</th>
<th align="left">实现效果</th>
<th align="left">返回的 HTML 标签</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fixed ( )</td>
<td align="left">以等宽字体显示文本</td>
<td align="left"><code>&lt;tt&gt; &lt;/tt&gt;</code></td>
</tr>
<tr>
<td align="left">bold ( )</td>
<td align="left">以粗体显示文本</td>
<td align="left"><code>&lt;b&gt; &lt;/b&gt;</code></td>
</tr>
<tr>
<td align="left">fontsize ( 字级大小 )</td>
<td align="left">按照字级大小显示文本</td>
<td align="left"><code>&lt;font&gt; &lt;/font&gt;</code></td>
</tr>
<tr>
<td align="left">fontcolor ( #rrggbb )</td>
<td align="left">按照颜色显示文本</td>
<td align="left"><code>&lt;font&gt; &lt;/font&gt;</code></td>
</tr>
<tr>
<td align="left">sup ( )</td>
<td align="left">将文本显示为上标</td>
<td align="left"><code>&lt;sup&gt; &lt;/sup&gt;</code></td>
</tr>
<tr>
<td align="left">sub ( )</td>
<td align="left">将文本显示为下标</td>
<td align="left"><code>&lt;sub&gt; &lt;/sub&gt;</code></td>
</tr>
<tr>
<td align="left">toUpperCase ( )</td>
<td align="left">返回将字符串中的英文字母全部转换为大写后的新字符串</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">toLowerCase ( )</td>
<td align="left">返回将字符串中的英文字母全部转换为小写后的新字符串</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">charAt ( 索引 )</td>
<td align="left">返回索引位置的字符</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">charCodeAt ( 索引 )</td>
<td align="left">返回索引位置的 ASCII 字符码, 用十进制表示</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">indexOf ( &quot;strSearch&quot; )</td>
<td align="left">返回 strSearch 在对象中的索引位置</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">lastIndexOf ( &quot;strSearch&quot; )</td>
<td align="left">返回 strSearch 在对象中的索引位置 (反向搜索)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">search ( &quot;strSearch&quot; )</td>
<td align="left">返回 strSearch 在对象中的索引位置</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">replace ( &quot;strReplace1&quot;, &quot;strReplace2&quot; )</td>
<td align="left">将 strReplace1 使用 strReplace2 进行替换</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">substring ( startIndex, length )</td>
<td align="left">返回从 startIndex 下标开始, 长度为 length 的子字符串</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="默认对象-之-布尔对象-Boolean"><a href="#默认对象-之-布尔对象-Boolean" class="headerlink" title="默认对象 之 布尔对象 (Boolean)"></a>默认对象 之 布尔对象 (Boolean)</h2><ul>
<li>实例化一个布尔对象实例: </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span> (转换值); </span><br><span class="line"><span class="comment">// 转换值: null, 未定义, 0, false 返回 false, 其他情况都返回 true. </span></span><br></pre></td></tr></table></figure>

<h2 id="默认对象-之-数学对象-Math"><a href="#默认对象-之-数学对象-Math" class="headerlink" title="默认对象 之 数学对象 (Math)"></a>默认对象 之 数学对象 (Math)</h2><ul>
<li>Math 中包含的属性:</li>
</ul>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">保存的数值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">E</td>
<td align="left">自然数 e</td>
</tr>
<tr>
<td align="left">LN2</td>
<td align="left">以 e 为底 2 的对数</td>
</tr>
<tr>
<td align="left">LN10</td>
<td align="left">以 e 为底 10 的对数</td>
</tr>
<tr>
<td align="left">LOG2E</td>
<td align="left">以 2 为底 e 的对数</td>
</tr>
<tr>
<td align="left">LOG10E</td>
<td align="left">以 10 为底 e 的对数</td>
</tr>
<tr>
<td align="left">PI</td>
<td align="left">圆周率</td>
</tr>
<tr>
<td align="left">SQRT1_2</td>
<td align="left">1/2的平方根</td>
</tr>
<tr>
<td align="left">SQRT2</td>
<td align="left">2的平方根</td>
</tr>
</tbody></table>
<ul>
<li>Math 中包含的方法: </li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ceil ( 数值 )</td>
<td align="left">大于等于该数值的最小整数</td>
</tr>
<tr>
<td align="left">floor ( 数值 )</td>
<td align="left">小于等于该数值的最大整数</td>
</tr>
<tr>
<td align="left">min ( 数值1, 数值2 )</td>
<td align="left">返回参数中的最小值</td>
</tr>
<tr>
<td align="left">max ( 数值1, 数值2 )</td>
<td align="left">返回参数中的最大值</td>
</tr>
<tr>
<td align="left">pow ( 数值1, 数值2 )</td>
<td align="left">返回数值1的数值2次方</td>
</tr>
<tr>
<td align="left">random ( )</td>
<td align="left">返回随机数 0-1</td>
</tr>
<tr>
<td align="left">round ( 数值 )</td>
<td align="left">返回最接近该数字的整数</td>
</tr>
<tr>
<td align="left">sqrt ( 数值 )</td>
<td align="left">返回数值的平方根</td>
</tr>
<tr>
<td align="left">abs ( 数值 )</td>
<td align="left">返回数值的绝对值</td>
</tr>
<tr>
<td align="left">sin ( 数值 )</td>
<td align="left">返回数值的 sin</td>
</tr>
<tr>
<td align="left">cos ( 数值 )</td>
<td align="left">返回数值的 cos</td>
</tr>
<tr>
<td align="left">tan ( 数值 )</td>
<td align="left">返回数值的 tan</td>
</tr>
<tr>
<td align="left">asin ( 数值 )</td>
<td align="left">返回数值的 arcsin</td>
</tr>
<tr>
<td align="left">acos ( 数值 )</td>
<td align="left">返回数值的 arccos</td>
</tr>
<tr>
<td align="left">atan ( 数值 )</td>
<td align="left">返回数值的 arctan</td>
</tr>
<tr>
<td align="left">exp ( 数值 )</td>
<td align="left">返回 e 的数值次方</td>
</tr>
<tr>
<td align="left">log ( 数值 )</td>
<td align="left">返回以 e 为底数值的对数</td>
</tr>
</tbody></table>
<h2 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h2><ul>
<li>自定义对象的定义方法</li>
</ul>
<p>可以使用构造函数语法格式来定义一个 &quot;自定义对象&quot; 类型. </p>
<p></Script></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Member</span>(<span class="params">name, sex</span>)//定义一个类, 名字是 <span class="title">Member</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;<span class="comment">//定义一个属性, 名字是 name, 由外部赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.sex = sex;<span class="comment">//定义一个属性, 名字是 sex, 由外部赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.number = <span class="number">3</span>;<span class="comment">//定义一个属性, 名字是 number, 由内部赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.Display = Display;<span class="comment">//声明一个方法, 名字是 display</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Display</span>(<span class="params"></span>)//定义上面已经声明的 <span class="title">Display</span> 方法</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// JavaScript 中没有 Char 类型, 单引号 和 双引号 都表示字符串. </span></span><br><span class="line">    <span class="keyword">var</span> strName = <span class="built_in">this</span>.name + <span class="string">&#x27; 是 &#x27;</span> + <span class="built_in">this</span>.sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> strNumber = <span class="string">&#x27;number 的值是 &#x27;</span> + <span class="built_in">this</span>.number;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&quot;&lt;UL&gt; &lt;LI&gt;&quot;</span>, strName);<span class="comment">//开启一个无序列表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&quot;&lt;LI&gt;&quot;</span>, strNumber, <span class="string">&quot;&lt;/UL&gt;&quot;</span>);<span class="comment">//结束一个无序列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>new</code> 来实例化自定义对象. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> papa = <span class="keyword">new</span> Member(<span class="string">&quot;杨宏文&quot;</span>, <span class="string">&quot;男生&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> mama = <span class="keyword">new</span> Member(<span class="string">&quot;黄雅玲&quot;</span>, <span class="string">&quot;女生&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> doggy = <span class="keyword">new</span> Member(<span class="string">&quot;奇奇&quot;</span>, <span class="string">&quot;宠物狗&quot;</span>);</span><br><span class="line"></span><br><span class="line">papa.Display();<span class="comment">//调用类型中的 Display() 方法. </span></span><br><span class="line">mama.Display();</span><br><span class="line">doggy.Display();</span><br></pre></td></tr></table></figure>

<h2 id="为对象动态添加属性和方法"><a href="#为对象动态添加属性和方法" class="headerlink" title="为对象动态添加属性和方法"></a>为对象动态添加属性和方法</h2><h3 id="为-quot-默认对象-quot-添加属性和方法"><a href="#为-quot-默认对象-quot-添加属性和方法" class="headerlink" title="为 &quot;默认对象&quot; 添加属性和方法"></a>为 &quot;默认对象&quot; 添加属性和方法</h3><p>JavaScript 允许程序员修改 Javascript 所提供的默认对象, 程序员可以利用对象原型 <code>prototype</code> 为默认对象添加自身定义属性以及方法. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 prototype 为默认对象 String 添加一个自定义方法, 名字是: replaceAll, </span></span><br><span class="line"><span class="comment">// 并设置 replaceAll 方法指向自定义的 strReplace 方法. </span></span><br><span class="line"><span class="built_in">String</span>.prototype.replaceAll = strReplace;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的 strReplace 方法: </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strReplace</span> (<span class="params">findText, replaceText</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// this 代指调用这个方法的对象. </span></span><br><span class="line">    <span class="comment">// strReplace 被调用时的语句是: str.strReplace(); this 指代的就是 str</span></span><br><span class="line">    <span class="comment">// 所以下面的语句可以获取调用这个方法的实例的值. </span></span><br><span class="line">    <span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (str.indexOf(findText) != <span class="number">-1</span>)<span class="comment">//只要存在 findText</span></span><br><span class="line">    &#123;</span><br><span class="line">        str = str.replace(findText, replaceText);<span class="comment">// 便使用 replaceText 进行替换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为-quot-自定义对象-quot-添加属性和方法"><a href="#为-quot-自定义对象-quot-添加属性和方法" class="headerlink" title="为 &quot;自定义对象&quot; 添加属性和方法"></a>为 &quot;自定义对象&quot; 添加属性和方法</h3><p>JavaScript 也允许程序员使用对象原型 <code>prototype</code> 为自己的 &quot;自定义类型&quot; 动态添加属性和方法. </p>
<ul>
<li>为 &quot;自定义类型&quot; 添加属性和方法. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 prototype 添加属性 hobby</span></span><br><span class="line">Member.prototype.hobby = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新属性也可以直接使用</span></span><br><span class="line">papa.hobby=<span class="string">&quot;上网&quot;</span>;</span><br><span class="line">mama.hobby=<span class="string">&quot;逛街&quot;</span>;</span><br><span class="line">doggy.hobby=<span class="string">&quot;啃骨头&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-默认函数"><a href="#JavaScript-默认函数" class="headerlink" title="JavaScript 默认函数"></a>JavaScript 默认函数</h1><h2 id="编码函数"><a href="#编码函数" class="headerlink" title="编码函数"></a>编码函数</h2><ul>
<li><p><code>escape( &#39;str&#39; )</code></p>
</li>
<li><p>将字符串 <code>str</code> 中所有的 <code>非 ASCII 字符</code> 转换成 <code>URL 编码</code>, <code>ASCII 字符</code> 保持不变, 之后返回新字符串. </p>
</li>
</ul>
<p>如: 普通空格 (space) =&gt; %20</p>
<h2 id="译码函数"><a href="#译码函数" class="headerlink" title="译码函数"></a>译码函数</h2><ul>
<li><p><code>unescape()</code></p>
</li>
<li><p>将 <code>URL 编码</code> 转换成相应的字符. </p>
</li>
</ul>
<h2 id="求值函数"><a href="#求值函数" class="headerlink" title="求值函数"></a>求值函数</h2><ul>
<li><p><code>eval(&#39;str&#39;)</code></p>
</li>
<li><p>将 <code>str</code> 中的表达式计算出结果之后返回. </p>
</li>
<li><p>例如 <code>eval(&quot;1 + 2&quot;);</code> 返回的值就是 <code>3</code></p>
</li>
</ul>
<h2 id="数值判断函数"><a href="#数值判断函数" class="headerlink" title="数值判断函数"></a>数值判断函数</h2><ul>
<li><p><code>isNaN( 变量 )</code></p>
</li>
<li><p>判断参数变量的类型是否为数值类型, 返回 <code>true</code> 或 <code>false</code>. </p>
</li>
</ul>
<h2 id="整数转换函数"><a href="#整数转换函数" class="headerlink" title="整数转换函数"></a>整数转换函数</h2><ul>
<li><p><code>parseInt(&#39;str_number&#39;, 底数)</code></p>
</li>
<li><p>将不同进制的数值 ( 比如二进制, 八进制, 十六进制) 转换成十进制整数. </p>
</li>
<li><p>虽然第二个参数 <code>底数</code> 可以省略, 但是用于进制转换的时候强烈建议不要省略. </p>
</li>
<li><p>这个方法还有一种用途, 如 <code>parseInt(&quot;3.1234A56&quot;);</code> 只会返回整数 <code>3</code>. </p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">底数</th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2: parseInt( &#39;110&#39;, 2 )</td>
<td align="left">按照二进制将数字 <code>110</code> 转换为十进制</td>
</tr>
<tr>
<td align="left">8: parseInt( &#39;110&#39;, 8 )</td>
<td align="left">按照八进制将数字 <code>110</code> 转换为十进制</td>
</tr>
<tr>
<td align="left">16: parseInt( &#39;FE&#39;, 16 )</td>
<td align="left">按照十六进制将数字 <code>FE</code> 转换为十进制</td>
</tr>
</tbody></table>
<h2 id="浮点数转换函数"><a href="#浮点数转换函数" class="headerlink" title="浮点数转换函数"></a>浮点数转换函数</h2><ul>
<li><p><code>parseFloat(&#39;str_number&#39;)</code></p>
</li>
<li><p>将 数值字符串 转换成 浮点数, 如 <code>parseFloat(&quot;3.1234A56&quot;);</code> 返回浮点数 <code>3.1234</code>. </p>
</li>
</ul>
<h1 id="JavaScript-自定义函数"><a href="#JavaScript-自定义函数" class="headerlink" title="JavaScript 自定义函数"></a>JavaScript 自定义函数</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数<span class="number">1</span>, 参数<span class="number">2</span>, ..., 参数n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//TODO</span></span><br><span class="line">    &lt;语句组&gt;</span><br><span class="line">    <span class="comment">//return 语句可以省略, 但是强烈建议不要省略. </span></span><br><span class="line">    [<span class="keyword">return</span> &lt;表达式&gt;;]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-事件"><a href="#JavaScript-事件" class="headerlink" title="JavaScript 事件"></a>JavaScript 事件</h1><ul>
<li>事件就是指用户对浏览器所做的特定的动作会触发相应的方法, 它是实现交互操作的一种机制. </li>
</ul>
<table>
<thead>
<tr>
<th align="left">事件名称</th>
<th align="left">适用对象</th>
<th align="left">意义</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Abort</td>
<td align="left">image</td>
<td align="left">终止</td>
<td align="left">当图形尚未完全加载前</td>
</tr>
<tr>
<td align="left">Blur</td>
<td align="left"></td>
<td align="left">失去焦点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Change</td>
<td align="left">t/pw/ta/select</td>
<td align="left">改变</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">DragDrop</td>
<td align="left">window</td>
<td align="left">拖曳</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Error</td>
<td align="left">img/win</td>
<td align="left"></td>
<td align="left">错误加载文件或图形时发生错误</td>
</tr>
<tr>
<td align="left">Focus</td>
<td align="left"></td>
<td align="left">取得焦点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Move</td>
<td align="left">window</td>
<td align="left">移动</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Reset</td>
<td align="left">form</td>
<td align="left">重置</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Submit</td>
<td align="left">form</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>其他事件: <code>Click/DblClick</code>, <code>KeyDown/KeyPress/KeyUp</code>, <code>Load/Unload</code>, <code>MouseDown/MouseUp/MouseOver/MouseOut/MouseMove</code>. </p>
<h2 id="事件写法一"><a href="#事件写法一" class="headerlink" title="事件写法一"></a>事件写法一</h2><ul>
<li>直接使用 HTML 中 body 标签的 onload 事件属性. </li>
</ul>
<p><code>&lt;body onload = &quot;alert(&#39;Star Buster Stream!&#39;);&quot;&gt; &lt;/body&gt;</code></p>
<h2 id="事件写法二"><a href="#事件写法二" class="headerlink" title="事件写法二"></a>事件写法二</h2><ul>
<li>使用对象中的 on(...) 事件属性. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Star Buster Stream!&#x27;</span>; </span><br><span class="line"><span class="built_in">document</span>.onload = alert(str);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;Star Buster Stream!&quot;</span>;</span><br><span class="line">    alert(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.onload = Show();</span><br></pre></td></tr></table></figure>

<h1 id="JavaScript-定时器"><a href="#JavaScript-定时器" class="headerlink" title="JavaScript 定时器"></a>JavaScript 定时器</h1><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout ( )"></a>setTimeout ( )</h2><ul>
<li><code>定时器对象名 = setTimeout(&quot;&lt;表达式&gt;&quot;, time);</code> : 等待 time 毫秒后只执行一次&lt;表达式&gt;. </li>
</ul>
<h2 id="clearTimeout"><a href="#clearTimeout" class="headerlink" title="clearTimeout ( )"></a>clearTimeout ( )</h2><ul>
<li><code>clearTimeout (定时器对象名)</code> : 终止一个 Timeout 定时器. </li>
</ul>
<h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval ( )"></a>setInterval ( )</h2><ul>
<li><code>定时器对象名 = setInterval (&quot;&lt;表达式&gt;&quot;, time)</code> : 每等待 time 毫秒后便执行一次&lt;表达式&gt;, 直至窗口, 框架被关闭或执行 <code>clearInterval</code>. </li>
</ul>
<h2 id="clearInterval"><a href="#clearInterval" class="headerlink" title="clearInterval ( )"></a>clearInterval ( )</h2><ul>
<li><code>clearInterval (定时器对象名)</code> : 终止一个 Interval 定时器. </li>
</ul>
<h1 id="JavaScript-图像对象"><a href="#JavaScript-图像对象" class="headerlink" title="JavaScript 图像对象"></a>JavaScript 图像对象</h1><ul>
<li><p>网页中的图像均会被自动看作图像对象, 并依顺序, 分别表示为 document.images[0], document.images[1], ...</p>
</li>
<li><p><code>图像对象名称 = new Image ( [宽度], [高度] ); //px</code></p>
</li>
<li><p>图像对象的属性: border complete height hspace lowsrc name src vspace width</p>
</li>
<li><p>图像对象的事件: onAbort onError onKeyDown onKeyPress onKeyUp onLoad</p>
</li>
</ul>
<h1 id="JavaScript-Navigator-对象"><a href="#JavaScript-Navigator-对象" class="headerlink" title="JavaScript Navigator 对象"></a>JavaScript Navigator 对象</h1><ul>
<li>检测浏览器的版本, 所支持的 MIME 类型, 已安装的插件程序(plug-in). </li>
</ul>
<h2 id="Navigator-对象的属性"><a href="#Navigator-对象的属性" class="headerlink" title="Navigator 对象的属性"></a>Navigator 对象的属性</h2><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">appCodeName</td>
<td align="left">代码</td>
</tr>
<tr>
<td align="left">appName</td>
<td align="left">名称</td>
</tr>
<tr>
<td align="left">appVersion</td>
<td align="left">版本</td>
</tr>
<tr>
<td align="left">language</td>
<td align="left">语言</td>
</tr>
<tr>
<td align="left">mimeType</td>
<td align="left">以数组表示所支持的 MIME 类型</td>
</tr>
<tr>
<td align="left">platform</td>
<td align="left">编译浏览器的机器类型</td>
</tr>
<tr>
<td align="left">plugins</td>
<td align="left">以数组表示已安装的插件程序</td>
</tr>
<tr>
<td align="left">userAgent</td>
<td align="left">用户代理程序的表头</td>
</tr>
</tbody></table>
<ul>
<li>该对象还包含两个子对象: plugin mimeType</li>
</ul>
<h2 id="plugin-对象的属性"><a href="#plugin-对象的属性" class="headerlink" title="plugin 对象的属性"></a>plugin 对象的属性</h2><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">description</td>
<td align="left">插件程序模块的描述</td>
</tr>
<tr>
<td align="left">filename</td>
<td align="left">插件程序模块的文件名</td>
</tr>
<tr>
<td align="left">length</td>
<td align="left">插件程序模块的个数</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">插件程序模块的名称</td>
</tr>
</tbody></table>
<h2 id="mimeType-对象的属性"><a href="#mimeType-对象的属性" class="headerlink" title="mimeType 对象的属性"></a>mimeType 对象的属性</h2><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">description</td>
<td align="left">MIME 类型的描述</td>
</tr>
<tr>
<td align="left">enablePlugin</td>
<td align="left">对应到哪个插件模块</td>
</tr>
<tr>
<td align="left">length</td>
<td align="left">MIME 类型的数目</td>
</tr>
<tr>
<td align="left">suffixes</td>
<td align="left">MIME 类型的扩展名</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">MIME 类型的名称</td>
</tr>
</tbody></table>
<h1 id="JavaScript-窗口对象"><a href="#JavaScript-窗口对象" class="headerlink" title="JavaScript 窗口对象"></a>JavaScript 窗口对象</h1><h2 id="窗口对象的属性"><a href="#窗口对象的属性" class="headerlink" title="窗口对象的属性"></a>窗口对象的属性</h2><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">document</td>
<td align="left">当前文件的信息</td>
</tr>
<tr>
<td align="left">location</td>
<td align="left">当前URL的信息</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">窗口名称</td>
</tr>
<tr>
<td align="left">status</td>
<td align="left">状态栏的临时信息</td>
</tr>
<tr>
<td align="left">defaultStatus</td>
<td align="left">状态栏默认信息</td>
</tr>
<tr>
<td align="left">history</td>
<td align="left">该窗口最近查阅过的网页</td>
</tr>
<tr>
<td align="left">closed</td>
<td align="left">判断窗口是否关闭, 返回布尔值</td>
</tr>
<tr>
<td align="left">opner</td>
<td align="left">open方法打开的窗口的源窗口</td>
</tr>
<tr>
<td align="left">outerHeight</td>
<td align="left">窗口边界的垂直尺寸, px</td>
</tr>
<tr>
<td align="left">outerWidth</td>
<td align="left">窗口边界的水平尺寸, px</td>
</tr>
<tr>
<td align="left">pageXOffset</td>
<td align="left">网页x-position的位置</td>
</tr>
<tr>
<td align="left">pageYOffset</td>
<td align="left">网页y-position的位置</td>
</tr>
<tr>
<td align="left">innerHeight</td>
<td align="left">窗口内容区的垂直尺寸, px</td>
</tr>
<tr>
<td align="left">innerWidth</td>
<td align="left">窗口内容区的水平尺寸, px</td>
</tr>
<tr>
<td align="left">screenX</td>
<td align="left">窗口左边界的X坐标</td>
</tr>
<tr>
<td align="left">screenY</td>
<td align="left">窗口上边界的Y坐标</td>
</tr>
<tr>
<td align="left">self</td>
<td align="left">当前窗口</td>
</tr>
<tr>
<td align="left">top</td>
<td align="left">最上方的窗口</td>
</tr>
<tr>
<td align="left">parent</td>
<td align="left">当前窗口或框架的框架组</td>
</tr>
<tr>
<td align="left">frames</td>
<td align="left">对应到窗口中的框架</td>
</tr>
<tr>
<td align="left">length</td>
<td align="left">框架的个数</td>
</tr>
<tr>
<td align="left">locationbar</td>
<td align="left">浏览器地址栏</td>
</tr>
<tr>
<td align="left">menubar</td>
<td align="left">浏览器菜单栏</td>
</tr>
<tr>
<td align="left">scrollbars</td>
<td align="left">浏览器滚动条</td>
</tr>
<tr>
<td align="left">statusbar</td>
<td align="left">浏览器状态栏</td>
</tr>
<tr>
<td align="left">toolbar</td>
<td align="left">浏览器工具栏</td>
</tr>
<tr>
<td align="left">offscreenBuffering</td>
<td align="left">是否更新窗口外的区域</td>
</tr>
<tr>
<td align="left">personalbars</td>
<td align="left">浏览器的个人工具栏, 仅 Navigator</td>
</tr>
</tbody></table>
<h2 id="窗口对象的方法"><a href="#窗口对象的方法" class="headerlink" title="窗口对象的方法"></a>窗口对象的方法</h2><table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">alert(信息字串)</td>
<td align="left">弹出警告信息</td>
</tr>
<tr>
<td align="left">confirm(信息字串)</td>
<td align="left">显示确认信息对话框</td>
</tr>
<tr>
<td align="left">prompt(提示字串[, 默认值])</td>
<td align="left">显示提示信息, 并提供可输入的字段</td>
</tr>
<tr>
<td align="left">atob(译码字串)</td>
<td align="left">对base-64编码字串进行译码</td>
</tr>
<tr>
<td align="left">btoa(字串)</td>
<td align="left">将进行base-64编码</td>
</tr>
<tr>
<td align="left">back()</td>
<td align="left">回到历史记录的上一网页</td>
</tr>
<tr>
<td align="left">forward()</td>
<td align="left">加载历史记录中的下一网页</td>
</tr>
<tr>
<td align="left">open(URL, 窗口名称[, 窗口规格])</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">focus()</td>
<td align="left">焦点移到该窗口</td>
</tr>
<tr>
<td align="left">blur()</td>
<td align="left">窗口转成背景</td>
</tr>
<tr>
<td align="left">stop()</td>
<td align="left">停止加载网页</td>
</tr>
<tr>
<td align="left">close()</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">enableExternalCapture()</td>
<td align="left">允许有框架的窗口获取事件</td>
</tr>
<tr>
<td align="left">disableExternalCapture()</td>
<td align="left">关闭enableExternalCapture()</td>
</tr>
<tr>
<td align="left">captureEvents(事件类型)</td>
<td align="left">捕捉窗口的特定事件</td>
</tr>
<tr>
<td align="left">routeEvent(事件)</td>
<td align="left">传送已捕捉的事件</td>
</tr>
<tr>
<td align="left">handleEvent(事件)</td>
<td align="left">使特定事件的处理生效</td>
</tr>
<tr>
<td align="left">releaseEvents(事件类型)</td>
<td align="left">释放已获取的事件</td>
</tr>
<tr>
<td align="left">moveBy(水平点数, 垂直点数)</td>
<td align="left">相对定位</td>
</tr>
<tr>
<td align="left">moveTo(x坐标, y坐标)</td>
<td align="left">绝对定位</td>
</tr>
<tr>
<td align="left">setResizable(true</td>
<td align="left">false)</td>
</tr>
<tr>
<td align="left">resizeBy(水平点数, 垂直点数)</td>
<td align="left">相对调整窗口大小</td>
</tr>
<tr>
<td align="left">resizeTo(宽度, 高度)</td>
<td align="left">绝对调整窗口大小</td>
</tr>
<tr>
<td align="left">scroll(x坐标, y坐标)</td>
<td align="left">绝对滚动窗口</td>
</tr>
<tr>
<td align="left">scrollBy(水平点数, 垂直点数)</td>
<td align="left">相对滚动窗口</td>
</tr>
<tr>
<td align="left">scrollTo(x坐标, y坐标)</td>
<td align="left">绝对滚动窗口</td>
</tr>
<tr>
<td align="left">setInterval(表达式, 毫秒)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">setTimeout(表达式, 毫秒)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">clearInterval(定时器对象)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">clearTimeout(定时器对象)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">home()</td>
<td align="left">进入浏览器设置的主页</td>
</tr>
<tr>
<td align="left">find([字串[,caseSensitivr,backward]])</td>
<td align="left">查找窗口中特定的字串</td>
</tr>
<tr>
<td align="left">print()</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">setHotKeys(true</td>
<td align="left">false)</td>
</tr>
<tr>
<td align="left">setZOptions()</td>
<td align="left">设置窗口重叠时的堆栈顺序</td>
</tr>
</tbody></table>
<h2 id="窗口对象的事件处理程序"><a href="#窗口对象的事件处理程序" class="headerlink" title="窗口对象的事件处理程序"></a>窗口对象的事件处理程序</h2><p>onBlur onDragDrop onError onFocus onLoad onMove onResize onUnload </p>
<h2 id="open-方法"><a href="#open-方法" class="headerlink" title="open 方法"></a>open 方法</h2><ul>
<li>open 方法的窗口规格参数 ( yes/no, 1/0 )</li>
</ul>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">alwaysLowered</td>
<td align="left">是否将窗口显示的堆栈后推一层</td>
</tr>
<tr>
<td align="left">alwaysRaised</td>
<td align="left">是否将窗口显示的堆栈上推一层</td>
</tr>
<tr>
<td align="left">dependent</td>
<td align="left">是否将该窗口与当前窗口产生依存关系</td>
</tr>
<tr>
<td align="left">fullscreen</td>
<td align="left">是否满屏显示</td>
</tr>
<tr>
<td align="left">directories</td>
<td align="left">是否显示连接工具栏</td>
</tr>
<tr>
<td align="left">location</td>
<td align="left">是否显示网址工具栏</td>
</tr>
<tr>
<td align="left">menubar</td>
<td align="left">是否显示菜单工具栏</td>
</tr>
<tr>
<td align="left">scrollbars</td>
<td align="left">是否显示滚动条</td>
</tr>
<tr>
<td align="left">status</td>
<td align="left">是否显示状态栏</td>
</tr>
<tr>
<td align="left">titlebar</td>
<td align="left">是否显示标题栏</td>
</tr>
<tr>
<td align="left">toolbar</td>
<td align="left">是否显示标准工具栏</td>
</tr>
<tr>
<td align="left">resizable</td>
<td align="left">是否可以改变窗口的大小</td>
</tr>
<tr>
<td align="left">screenX</td>
<td align="left">窗口左边界距离</td>
</tr>
<tr>
<td align="left">screenY</td>
<td align="left">窗口上边界距离</td>
</tr>
<tr>
<td align="left">top</td>
<td align="left">窗口上边界</td>
</tr>
<tr>
<td align="left">width</td>
<td align="left">窗口宽度</td>
</tr>
<tr>
<td align="left">height</td>
<td align="left">窗口高度</td>
</tr>
<tr>
<td align="left">left</td>
<td align="left">窗口左边界</td>
</tr>
<tr>
<td align="left">outerHeight</td>
<td align="left">窗口外边界的高度</td>
</tr>
<tr>
<td align="left">personalbar</td>
<td align="left">是否显示个人工具栏</td>
</tr>
</tbody></table>
<h1 id="JavaScript-屏幕对象"><a href="#JavaScript-屏幕对象" class="headerlink" title="JavaScript 屏幕对象"></a>JavaScript 屏幕对象</h1><ul>
<li><p>描述屏幕的显示及颜色属性. </p>
</li>
<li><p>格式:  screen.属性 </p>
</li>
</ul>
<h2 id="屏幕对象的属性"><a href="#屏幕对象的属性" class="headerlink" title="屏幕对象的属性:"></a>屏幕对象的属性:</h2><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">availHeight</td>
<td align="left">屏幕区域的可用高度</td>
</tr>
<tr>
<td align="left">availWidth</td>
<td align="left">屏幕区域的可用宽度</td>
</tr>
<tr>
<td align="left">colorDepth</td>
<td align="left">颜色深度 256/8 16/16 32M/32</td>
</tr>
<tr>
<td align="left">height</td>
<td align="left">屏幕区域的实际高度</td>
</tr>
<tr>
<td align="left">width</td>
<td align="left">屏幕区域的实际宽度</td>
</tr>
</tbody></table>
<h1 id="JavaScript-事件对象"><a href="#JavaScript-事件对象" class="headerlink" title="JavaScript 事件对象"></a>JavaScript 事件对象</h1><ul>
<li><p>当事件发生时, 浏览器自动建立该对象, 并包含该事件的类型, 鼠标坐标等.  </p>
</li>
<li><p>格式: event.属性 </p>
</li>
</ul>
<h2 id="事件对象的属性"><a href="#事件对象的属性" class="headerlink" title="事件对象的属性"></a>事件对象的属性</h2><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">data</td>
<td align="left">返回拖拽对象的URL字符串 (dragDrop)</td>
</tr>
<tr>
<td align="left">width</td>
<td align="left">该窗口或框架的高度</td>
</tr>
<tr>
<td align="left">height</td>
<td align="left">该窗口或框架的高度</td>
</tr>
<tr>
<td align="left">pageX</td>
<td align="left">光标相对于该网页的水平位置</td>
</tr>
<tr>
<td align="left">pageY</td>
<td align="left">光标相对于该网页的垂直位置</td>
</tr>
<tr>
<td align="left">screenX</td>
<td align="left">光标相对于该屏幕的水平位置</td>
</tr>
<tr>
<td align="left">screenY</td>
<td align="left">光标相对于该屏幕的垂直位置</td>
</tr>
<tr>
<td align="left">target</td>
<td align="left">该事件被传送到的对象</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">事件的类型</td>
</tr>
<tr>
<td align="left">which</td>
<td align="left">数值表示的键盘或鼠标键: 1/2/3 (左键/中键/右键)</td>
</tr>
<tr>
<td align="left">layerX</td>
<td align="left">光标相对于事件发生层的水平位置</td>
</tr>
<tr>
<td align="left">layerY</td>
<td align="left">光标相对于事件发生层的垂直位置</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">相当于layerX</td>
</tr>
<tr>
<td align="left">y</td>
<td align="left">相当于layerY</td>
</tr>
</tbody></table>
<h1 id="JavaScript-历史对象"><a href="#JavaScript-历史对象" class="headerlink" title="JavaScript 历史对象"></a>JavaScript 历史对象</h1><ul>
<li><p>用以存储客户端最近访问的网址清单.  </p>
</li>
<li><p>格式: history.属性. history.方法 (参数)  </p>
</li>
</ul>
<h2 id="历史对象的属性"><a href="#历史对象的属性" class="headerlink" title="历史对象的属性:"></a>历史对象的属性:</h2><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">current</td>
<td align="left">当前历史记录的网址</td>
</tr>
<tr>
<td align="left">length</td>
<td align="left">存储在记录清单中的网址数目</td>
</tr>
<tr>
<td align="left">next</td>
<td align="left">下一个历史记录的网址</td>
</tr>
<tr>
<td align="left">previous</td>
<td align="left">上一个历史记录的网址</td>
</tr>
</tbody></table>
<h2 id="历史对象的方法"><a href="#历史对象的方法" class="headerlink" title="历史对象的方法:"></a>历史对象的方法:</h2><table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">back( )</td>
<td align="left">回到上一个历史记录中的网址</td>
</tr>
<tr>
<td align="left">forward( )</td>
<td align="left">回到下一个历史记录中的网址</td>
</tr>
<tr>
<td align="left">go ( 整数或URL )</td>
<td align="left">前往历史记录中的网址</td>
</tr>
</tbody></table>
<h1 id="JavaScript-位置对象"><a href="#JavaScript-位置对象" class="headerlink" title="JavaScript 位置对象"></a>JavaScript 位置对象</h1><ul>
<li><p>用来代表特定窗口的 URL 信息. </p>
</li>
<li><p>格式: location.属性. location.方法 (参数)  </p>
</li>
<li><p>URL的格式: protocol//host:port/path#hash?search </p>
</li>
<li><p>URL的种类: </p>
</li>
<li><ul>
<li>javascript: javascript 程序代码 </li>
</ul>
</li>
<li><ul>
<li>view-source: 显示源代码 </li>
</ul>
</li>
<li><ul>
<li>http:   </li>
</ul>
</li>
<li><ul>
<li>file:   </li>
</ul>
</li>
<li><ul>
<li>ftp:   </li>
</ul>
</li>
<li><ul>
<li>mailto:   </li>
</ul>
</li>
<li><ul>
<li>news:   </li>
</ul>
</li>
<li><ul>
<li>gopher   </li>
</ul>
</li>
</ul>
<h2 id="位置对象的属性"><a href="#位置对象的属性" class="headerlink" title="位置对象的属性"></a>位置对象的属性</h2><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hash</td>
<td align="left">锚点名称</td>
</tr>
<tr>
<td align="left">host</td>
<td align="left">主机名称</td>
</tr>
<tr>
<td align="left">hostname</td>
<td align="left">host:port</td>
</tr>
<tr>
<td align="left">href</td>
<td align="left">完整的URL字符串</td>
</tr>
<tr>
<td align="left">pathname</td>
<td align="left">路径</td>
</tr>
<tr>
<td align="left">port</td>
<td align="left">端口</td>
</tr>
<tr>
<td align="left">protocol</td>
<td align="left">协议</td>
</tr>
<tr>
<td align="left">search</td>
<td align="left">查询信息</td>
</tr>
</tbody></table>
<h2 id="位置对象的方法"><a href="#位置对象的方法" class="headerlink" title="位置对象的方法"></a>位置对象的方法</h2><table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">reload()</td>
<td align="left">重新加载</td>
</tr>
<tr>
<td align="left">replace(网址)</td>
<td align="left">用指定的网页取代当前网页</td>
</tr>
</tbody></table>
<h1 id="JavaScript-文件对象"><a href="#JavaScript-文件对象" class="headerlink" title="JavaScript 文件对象"></a>JavaScript 文件对象</h1><ul>
<li><p>代表当前 HTML 对象, 是由 <code>&lt;body&gt;</code> 标签组构成的, 对每个 HTML 文件会自动建立一个文件对象. </p>
</li>
<li><p>格式: document.属性. document.方法 (参数)  </p>
</li>
</ul>
<h2 id="文件对象的属性"><a href="#文件对象的属性" class="headerlink" title="文件对象的属性"></a>文件对象的属性</h2><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">linkColor</td>
<td align="left">设置超链接的颜色</td>
</tr>
<tr>
<td align="left">alinkColor</td>
<td align="left">作用中的超链接的颜色</td>
</tr>
<tr>
<td align="left">vlinkColor</td>
<td align="left">链接的超链接颜色</td>
</tr>
<tr>
<td align="left">links</td>
<td align="left">以数组索引值表示所有超链接</td>
</tr>
<tr>
<td align="left">URL</td>
<td align="left">该文件的网址</td>
</tr>
<tr>
<td align="left">anchors</td>
<td align="left">以数组索引值表示所有锚点</td>
</tr>
<tr>
<td align="left">bgColor</td>
<td align="left">背景颜色</td>
</tr>
<tr>
<td align="left">fgColor</td>
<td align="left">前景颜色</td>
</tr>
<tr>
<td align="left">classes</td>
<td align="left">文件中的class属性</td>
</tr>
<tr>
<td align="left">cookie</td>
<td align="left">设置cookie</td>
</tr>
<tr>
<td align="left">domain</td>
<td align="left">指定服务器的域名</td>
</tr>
<tr>
<td align="left">formName</td>
<td align="left">以表单名称表示所有表单</td>
</tr>
<tr>
<td align="left">forms</td>
<td align="left">以数组索引值表示所有表单</td>
</tr>
<tr>
<td align="left">images</td>
<td align="left">以数组索引值表示所有图像</td>
</tr>
<tr>
<td align="left">layers</td>
<td align="left">以数组索引值表示所有layer</td>
</tr>
<tr>
<td align="left">embeds</td>
<td align="left">文件中的plug-in</td>
</tr>
<tr>
<td align="left">applets</td>
<td align="left">以数组索引值表示所有applet</td>
</tr>
<tr>
<td align="left">plugins</td>
<td align="left">以数组索引值表示所有插件程序</td>
</tr>
<tr>
<td align="left">referrer</td>
<td align="left">代表当前打开文件的网页的网址</td>
</tr>
<tr>
<td align="left">tags</td>
<td align="left">指出HTML标签的样式</td>
</tr>
<tr>
<td align="left">title</td>
<td align="left">该文档的标题</td>
</tr>
<tr>
<td align="left">width</td>
<td align="left">该文件的宽度 (px)</td>
</tr>
<tr>
<td align="left">lastModified</td>
<td align="left">文件最后修改时间</td>
</tr>
</tbody></table>
<h2 id="文件对象的方法"><a href="#文件对象的方法" class="headerlink" title="文件对象的方法"></a>文件对象的方法</h2><table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">captureEvents(事件)</td>
<td align="left">设置要获取指定的事件</td>
</tr>
<tr>
<td align="left">close()</td>
<td align="left">关闭输出字符流, 强制显示数据内容</td>
</tr>
<tr>
<td align="left">getSelection()</td>
<td align="left">取得当前选取的字串</td>
</tr>
<tr>
<td align="left">handleEvent(事件)</td>
<td align="left">使事件处理器生效</td>
</tr>
<tr>
<td align="left">open([mimeType,[replace]])</td>
<td align="left">打开字符流</td>
</tr>
<tr>
<td align="left">releaseEvents(事件类型)</td>
<td align="left">释放已获取的事件</td>
</tr>
<tr>
<td align="left">routeEvent(事件)</td>
<td align="left">传送已捕捉的事件</td>
</tr>
<tr>
<td align="left">write(字串)</td>
<td align="left">写字串或数值到文件中</td>
</tr>
<tr>
<td align="left">writeln(字串)</td>
<td align="left">分行写字串或数值到文件中 (<code>&lt;pre&gt;..&lt;/pre&gt;</code>)</td>
</tr>
</tbody></table>
<h1 id="JavaScript-锚点对象"><a href="#JavaScript-锚点对象" class="headerlink" title="JavaScript 锚点对象"></a>JavaScript 锚点对象</h1><ul>
<li><p>网页中的锚点均会被自动看作锚点对象, 并依顺序, 分别表示为 document.anchors[0], document.anchors[1]...</p>
</li>
<li><p>定义锚点对象的格式: 字串.anchor ( 属性 )</p>
</li>
</ul>
<h2 id="锚点对象的属性"><a href="#锚点对象的属性" class="headerlink" title="锚点对象的属性"></a>锚点对象的属性</h2><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name</td>
<td align="left">锚点名称</td>
</tr>
<tr>
<td align="left">text</td>
<td align="left">锚点字串</td>
</tr>
</tbody></table>
<h1 id="JavaScript-链接对象"><a href="#JavaScript-链接对象" class="headerlink" title="JavaScript 链接对象"></a>JavaScript 链接对象</h1><ul>
<li><p>网页中的链接均会被自动看作链接对象, 并依顺序, 分别表示为 document.links[0], document.links[1]...</p>
</li>
<li><p>定义链接对象的格式: 字串.link(属性)</p>
</li>
</ul>
<h2 id="链接对象的属性"><a href="#链接对象的属性" class="headerlink" title="链接对象的属性:"></a>链接对象的属性:</h2><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hash</td>
<td align="left">URL中的锚点名称</td>
</tr>
<tr>
<td align="left">host</td>
<td align="left">主机域名或IP地址</td>
</tr>
<tr>
<td align="left">hostname</td>
<td align="left">URL中的host+port</td>
</tr>
<tr>
<td align="left">href</td>
<td align="left">完整的URL字串</td>
</tr>
<tr>
<td align="left">pathname</td>
<td align="left">URL中path部分</td>
</tr>
<tr>
<td align="left">port</td>
<td align="left">URL中端口部分</td>
</tr>
<tr>
<td align="left">protocol</td>
<td align="left">URL中通讯协议部分</td>
</tr>
<tr>
<td align="left">search</td>
<td align="left">URL中查询字串部分</td>
</tr>
<tr>
<td align="left">target</td>
<td align="left">代表目标的窗口</td>
</tr>
<tr>
<td align="left">text</td>
<td align="left">表示A标签中的文字</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">链接对象的左边界</td>
</tr>
<tr>
<td align="left">y</td>
<td align="left">链接对象的右边界</td>
</tr>
</tbody></table>
<h2 id="链接对象的方法"><a href="#链接对象的方法" class="headerlink" title="链接对象的方法"></a>链接对象的方法</h2><table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">handleEvent(事件)</td>
<td align="left">激活对某事件的处理程序</td>
</tr>
</tbody></table>
<h2 id="链接对象的事件处理程序"><a href="#链接对象的事件处理程序" class="headerlink" title="链接对象的事件处理程序"></a>链接对象的事件处理程序</h2><p>onClick onDbClick onKeyDown onKeyPress onKeyUp onMouseDown onMouseUp onMouseOver onMouseOut </p>
<h1 id="JavaScript-框架对象"><a href="#JavaScript-框架对象" class="headerlink" title="JavaScript 框架对象"></a>JavaScript 框架对象</h1><ul>
<li><p>可以被窗口中的框架引用的对象, 具有窗口对象的属性和方法. </p>
</li>
<li><p>格式: </p>
</li>
<li><ul>
<li>top.frameName|frames[n].属性|方法</li>
</ul>
</li>
<li><ul>
<li>parent.frameName|frames[n].属性|方法</li>
</ul>
</li>
</ul>
<h1 id="JavaScript-Cookie-对象"><a href="#JavaScript-Cookie-对象" class="headerlink" title="JavaScript Cookie 对象"></a>JavaScript Cookie 对象</h1><ul>
<li><p>是一种以文件 (Cookie文件) 的形式保存在客户端硬盘的 Cookies 文件夹中的用户数据信息 (Cookie数据) . </p>
</li>
<li><p>Cookie 文件由所访问的 Web 站点建立, 以长久的保存客户端与 Web 站点间的会话数据, 并且该 Cookie 数据只允许被所访问的 Web 站点进行读取. </p>
</li>
<li><p>Cookie文件的格式:  </p>
</li>
<li><ul>
<li>NS: Cookie.txt</li>
</ul>
</li>
<li><ul>
<li>IE: 用户名@域名.txt</li>
</ul>
</li>
</ul>
<h2 id="写入Cookie"><a href="#写入Cookie" class="headerlink" title="写入Cookie"></a>写入Cookie</h2><ul>
<li><p>格式: <code>document.cookie = &quot; 关键字 = 值 [ ; expires = 有效日期 ] [;...] &quot;</code></p>
</li>
<li><p>备注: </p>
</li>
<li><ul>
<li>有效日期格式: <code>Wdy,DD-Mon-YY HH:MM:SS GMT</code>, Wdy: 英文星期, Mon: 月份.  </li>
</ul>
</li>
<li><ul>
<li>还包含 path, domain, secure 属性.  </li>
</ul>
</li>
<li><ul>
<li>每个 Web 站点 (domain) 可建立 20 个 Cookie 数据.  </li>
</ul>
</li>
<li><ul>
<li>每个浏览器可存储 300 个 Cookie 数据, 4k字节.  </li>
</ul>
</li>
<li><ul>
<li>客户有权禁止 Cookie 数据的写入. </li>
</ul>
</li>
</ul>
<h2 id="读取Cookie"><a href="#读取Cookie" class="headerlink" title="读取Cookie"></a>读取Cookie</h2><ul>
<li>格式: <code>document.cookie</code></li>
</ul>
<h2 id="删除Cookie"><a href="#删除Cookie" class="headerlink" title="删除Cookie"></a>删除Cookie</h2><ul>
<li>格式: <code>document.cookie = &quot; 关键字 = ; expires = 当前日期&quot;</code></li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
